# 操作系统 lab2 Report

## 练习1：实现 first-fit 连续物理内存分配算法

原算法已经可以正常运行，只是原算法将原本生成的新块放在了链表头部，要实现FFMA只需对`default_alloc_pages`， `default_free_pages`两个函数进行修改即可。

### 分配

相对释放算法而言比较简单，只需要将新的小块放在原块后再删去原块即可。需要注意的是，应将新的小块`property`置位，否则新的小块无法被使用，修改部分的代码：

````C
    if (page != NULL) {
        if (page->property > n) {
            struct Page *p = page + n;
            p->property = page->property - n;
            list_add(&(page->page_link), &(p->page_link));	//将原空闲块剩余部分放在原块后
			SetPageProperty(p);	//将新块property置位
		}
        list_del(&(page->page_link));	//删去原块
        nr_free -= n;
        ClearPageProperty(page);
    }
````

### 释放

释放算法比较麻烦，但是实现起来其实很简单，难点在于容易漏想情况和`debug`不方便，在释放块时，我按如下情况进行了考虑：

+ 释放的块尾部恰好和另一块头部相接
+ 释放的块头部恰好和另一块尾部相接
+ 释放的块恰好嵌在某两块中间
+ 释放的块无法和其他块合并（最后实现时将如下两种子情况合并）
  + 原链表为空
  + 原链表不为空

实现过程中，也需要考虑`property`的置位，代码修改部分及解释：

````C
int flag = 1;	//用来表示当前情况，1表示没有和其他块连接
while (le != &free_list) {
		p = le2page(le, page_link);
		if (base + base->property == p) {	//若尾部与其他块头部相接
		    base->property += p->property;
            //头部和其他块相接，此时base已经在链表中，直接删去p并修改p的有效位
			if(flag == 0){
				list_del(&(p->page_link));
				ClearPageProperty(p);
			}
            //否则，base不在链表中，需要将原块放在p后一个，然后删去p，最后修改有效位即可
            else{
				list_add(&(p->page_link),&(base->page_link));
				list_del(&(p->page_link));
				SetPageProperty(base);
				ClearPageProperty(p);
			}
            flag = 0;
            break;	//不可能再和后面的块连接在一块，故可以终止
		}
    
    //若头部与其他块尾部相接，此时还需要继续扫描，因为尾部可能还有其他块相接（嵌在两块中间）
		else if (p + p->property == base) {	
            //修改p的长度以及p和base的有效位后，直接让base指向p
		    p->property += base->property;
			SetPageProperty(p);
			flag = 0;	//方便尾部还有相接块情况时判断。
			ClearPageProperty(base);
			base = p;
		}     
    	//若当前块已经大于base的尾部，无需继续遍历
    	else if(base + base->property < p){
            break;
        }
        le = list_next(le);
	}
	//若到最后还没将base加入链表，直接加入当前块的前一块即可；当前块只能是链表头（链表为空的情况）或者base后一块
	if(flag){
		list_add_before(le,&(base->page_link));
	}
    nr_free += n;
	}
````

### 可改进空间

+ 释放算法
  + 在释放时，应该不需要遍历整个链表，只需要计算出相邻块并直接判断状态即可

和答案相比，我的分配算法和答案一致，释放算法更加复杂，但只需要遍历一次链表中前一部分（地址小于base部分）即可，实际效率应该更高。



## 练习2：实现寻找虚拟地址对应的页表项（需要编程）

### 设计实现过程

此题按照注释一步一步实现即可，只是虚拟地址/线性地址/物理地址三者在此时的区别容易让人混淆。按照注释内容，实现步骤如下

1. 获得对应一级页目录表项
2. 判断表项Present位，如果项的Present位为1,则表明其对应页表不在内存中，转步骤3,否则转步骤5
3. 检查是否有需要分配页，若有则分配，进行步骤3
4. 设置页表引用次数，获得页表线性地址（此处就是物理地址），使用0初始化页（此处应该使用虚地址填充，因为已经使能了页机制），置位各标志位
5. 使用页目录项中页表基址加上偏移得到页表项的虚地址。

### 请描述页目录项（Page Directory Entry）和页表项（Page Table Entry）中每个组成部分的含义以及对ucore而言的潜在用处。

#### 页目录项

+ 组成

  + ````
    31							 12 11  9  8 7 6 5   4  3    2   1  0
    |------------页表基址------------|-Avl-|G|PS|0|A|PCD|PWT|U/S|R/W|P|
    ````

  + 页表基址：页表物理地址高20位。

  + Avl:保留位，可用于内存空间拓展。

  + G：全局位，指示该页是否是全局的,页目录项实际不用。

  + PS：页面大小，0表示4kb，1通常表示4MB.Ucore只使用0。

  + A：访问位，表示次页表项是否被访问过，CPU不会将其清零。

  + PCD：`Cache Disable`标志位。为1时不允许Cache；为0时允许Cache。

  + PWT：`Write-Through`标志位。为1时`write-through`；为0时`write-back`。

  + U/S:权限标志位。为0时页表只能内核态访问，否则用户态也可以访问。

  + R/W：读写标志。为1可读写，为0只读。

  + P：存在位，对应页表是否在内存中。

#### 页表项

- 组成 大部分与页目录项相同，仅解释不同部分

  - ```
    31						 12 11    9  8 7 6 5   4  3    2   1  0
    |------------页基址------------|-Avail-|G|0|D|A|PCD|PWT|U/S|R/W|P|
    ```

  - 页基址：页面物理地址高20位。

  - G：页表项需要使用该全局位，该位置1,则CR3改变时，表项可在TLB中不被清除

  - D：脏位，表示该页面是否被写过。

  - P：存在位，对应页是否在内存中。

潜在用处：D位/A位均可以用来在ucore实现页替换算法时发挥作用，G位则可以在某些ucore需要全局频繁访问的表项处实现访问加速。

### 如果ucore执行过程中访问内存，出现了页访问异常，请问硬件要做哪些事情？

首先将要访问的异常地址保存至CR2寄存器，然后查询IDT找到异常处理例程，此时已经在内核态，只需要在栈中存储ERROR CODE/CS/EIP/EFLAGS，ucore可以根据error code得到错误信息，然后跳转到处理例程。



此题实现和答案基本一致，但是我没有处理分配页失败的情况，已修改。

## 练习三： 释放某虚地址所在的页并取消对应二级页表项的映射

### 设计实现过程

做了练习二再做这个练习相对而言比较简单，根据注释基本上可以直接实现。步骤如下：

1. 通过存在位判断表项对应页是否存在，若存在，则继续，否则结束。
2. 得到表项对应页
3. 页引用次数减一
4. 若引用次数为0,清空该页。
5. 取消二级页表项映射
6. 删去对应tlb表项

此题实现和答案基本一致。

### 数据结构Page的全局变量（其实是一个数组）的每一项与页表中的页目录项和页表项有无对应关系？如果有，其对应关系是啥？

有对应关系，可以通过页表项或者也目录项的高20位作为页号对应着Page全局变量数组的下标，通过页号可以直接计算出物理页在Page全局变量数组中的下标，通过下标也可以计算出页号。

### 如果希望虚拟地址与物理地址相等，则需要如何修改lab2，完成此事？

需要修改`KERNBASE`为`0x0`，其次需要链接脚本时的内核地址改为`0x00100000`,同时，还应该在`entry.S`中注释掉取消临时映射到0-4M那两行。

entry.S中对应行

````assembly
    # unmap va 0 ~ 4M, it's temporary mapping
    # xorl %eax, %eax
    # movl %eax, __boot_pgdir
````

如此修改后，ucore可以正常启动并实现对等映射，但是还需要修改一些内容才能够通过测试。



## 知识点

本次实验中原理课上的知识点：

+ First Fit连续内存分配算法
+ 页机制/二级页表

原理课上有，本次实验没有的知识点：

+ 其他连续内存分配算法（最佳匹配/最差匹配/碎片整理）
+ 段机制
+ 反置页表

