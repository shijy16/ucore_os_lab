# Lab 5 Report

石景宜 2016011395

> 由于前几次实验很多都已经按照参考答案做了相应修改，需要修改的地方实际不多。

## 练习1: 加载应用程序并执行

#### 设计实现过程

直接按照注释，将`trapframe`的相应结构设置为注释中提示的值即可。

#### 请在实验报告中描述当创建一个用户态进程并加载了应用程序后，CPU是如何让这个应用程序最终在用户态执行起来的。即这个用户态进程被ucore选择占用CPU执行（RUNNING态）到具体执行应用程序第一条指令的整个经过。

进程被选择后，内核首先调用`proc_run`函数，在该函数中，进行了如下操作：

+ 将`current`设置为目标进程
+ 加载目标进程的栈基址到esp，页目录基址到cr3
+ 调用switch_to函数进行相关寄存器的保存和修改，恢复上下文，跳转到`forkret`
+ `forkret`跳转到`__trapret`
+ `__trapret`恢复各寄存器，最后进行中断返回，跳转到用户态，执行用户进程

#### 与参考答案对比

在给`tf->tf_eflags`赋值时，我使用了`tf->tf_eflags |= FL_IF;`，而实际上这时候`tf_eflags`还未被初始化，应用等于号，直接赋值。

## 练习2: 父进程复制自己的内存空间给子进程

#### 设计实现过程

直接按照注释实现即可。获得两个页都虚拟地址后直接拷贝，然后将新页插入链表中，建立映射关系即可。

#### 请在实验报告中简要说明如何设计实现”Copy on Write 机制“，给出概要设计，鼓励给出详细设计。

`copy_range`中有一个`shared`位，可以用来做是否赋值的标志。若该位置位，则可以直接将原进程页插入到新进程的页表中，无需分配新页和赋值，除此之外，应该把页的`W`置0，这样的话，每当进程需要写入页的时候，会发生异常，只需要在发生异常时复制页并写入新的页即可，此时可以将新的页`W`位置为1，且需要置为`dirty`。

#### 与参考答案对比

我的实现与参考答案基本一致

## 练习3: 阅读分析源代码，理解进程执行 fork/exec/wait/exit 的实现，以及系统调用的实现

