# Lab 5 Report

石景宜 2016011395

练习0

> 由于前几次实验很多都已经按照参考答案做了相应修改，需要修改的地方实际不多。

## 练习1: 加载应用程序并执行

#### 设计实现过程

直接按照注释，将`trapframe`的相应结构设置为注释中提示的值即可。

#### 请在实验报告中描述当创建一个用户态进程并加载了应用程序后，CPU是如何让这个应用程序最终在用户态执行起来的。即这个用户态进程被ucore选择占用CPU执行（RUNNING态）到具体执行应用程序第一条指令的整个经过。

进程被选择后，内核首先调用`proc_run`函数，在该函数中，进行了如下操作：

+ 将`current`设置为目标进程
+ 加载目标进程的栈基址到esp，页目录基址到cr3
+ 调用switch_to函数进行相关寄存器的保存和修改，恢复上下文，跳转到`forkret`
+ `forkret`跳转到`__trapret`
+ `__trapret`恢复各寄存器，最后进行中断返回，跳转到用户态，执行用户进程

#### 与参考答案对比

在给`tf->tf_eflags`赋值时，我使用了`tf->tf_eflags |= FL_IF;`，而实际上这时候`tf_eflags`还未被初始化，应用等于号，直接赋值。

## 练习2: 父进程复制自己的内存空间给子进程

#### 设计实现过程

直接按照注释实现即可。获得两个页都虚拟地址后直接拷贝，然后将新页插入链表中，建立映射关系即可。

#### 请在实验报告中简要说明如何设计实现”Copy on Write 机制“，给出概要设计，鼓励给出详细设计。

+ fork过程

`copy_range`中有一个`shared`位，可以用来做是否赋值的标志。若该位置位，则可以直接将原进程页插入到新进程的页表中，无需分配新页和赋值，除此之外，应该把页的`W`置0，这样的话，每当进程需要写入页的时候，会发生异常。

+ 写入处理

COW进程在写入时会触发异常，只需要在发生异常时复制页并写入新的页即可，此时可以将新的页`W`位置为1，除此之外，还需要将新的页的D位置为`1`，并修改页表项的映射物理位置。至此，COW机制实现完成

#### 与参考答案对比

我的实现与参考答案基本一致

## 练习3: 阅读分析源代码，理解进程执行 fork/exec/wait/exit 的实现，以及系统调用的实现

+ fork
  + 分析：新建了一个进程控制块，并拷贝了父进程的进程控制块，设置了子进程的栈和mm，将进程插入进程链表，最后通过`wakeup_proc`来把子进程状态修改为`RUNNABLE`
  + 进程状态变化：在fork中的`alloc_proc`调用后，新进程控制块被分配，此时其状态为`UNINT`，在完成了初始化、拷贝等工作后，通过`wakeup_proc`修改为了`RUNNABLE`状态。
+ exec
  + 分析：清空进程内存，加载新进程的elf格式文件的代码段。将旧进程的进程名拷贝给新进程。
  + 进程状态变化：在`RUNNING`状态下进行，不会引起状态变化。
+ wait
  + 分析：根据子进程状态，做出不同反应。若存在子进程，且子进程处于`ZOMBIE`状态，则获得子进程返回值后释放子进程；若存在子进程，且子进程不处于`ZOMBIE`状态，则进入`SLEEPING`状态开始休眠。若不存在子进程，则返回错误。
  + 进程状态变化：在找到僵尸子进程或没有子进程的情况下，不改变当前状态，否则改为`SLEEPING`状态等待子进程结束。
+ exit
  + 分析：清理当前进程内存资源，设置返回值并将状态改为`ZOMBIE`。若父进程正在等待子进程，则唤醒父进程。将所有子进程的父进程设置为`initproc`。
  + 进程状态变化：从`RUNNING`变为`ZOMBIE`。

状态转移图：

````

						+-----------+---------------+--⑦-->ZOMBIE--⑧-->NONE
						|			|				|
NONE--①-->UNINT--②-->RUNNABLE--③-->RUNNING--④-->SLEEPING
                        A            `|             |
                        |             ⑥             |
                        |<------------+             |
						|							|
						|							|
                         +------------⑤-------------+



````

① alloc_proc

② wakeup_proc/proc_init

③ proc_run中被调用

④ wait/sleep

⑤wakeup_poc (即wait系统调用返回)

⑥ 调用proc_run

⑦ exit调用

⑧ 父进程调用wait清理该进程。

## 知识点总结

本实验中包含的课程知识点

- elf格式文件的加载
- PCB
- 进程控制
- COW

本实验中没有涉及到的课程重要知识点

- 无