Binary files lab2/bin/bootblock and lab1/bin/bootblock differ
Binary files lab2/bin/kernel and lab1/bin/kernel differ
Binary files lab2/bin/sign and lab1/bin/sign differ
Binary files lab2/bin/ucore.img and lab1/bin/ucore.img differ
diff -urN lab2/boot/bootasm.S lab1/boot/bootasm.S
--- lab2/boot/bootasm.S	2019-02-26 21:54:43.932194340 +0800
+++ lab1/boot/bootasm.S	2019-02-28 18:26:57.000000000 +0800
@@ -8,7 +8,6 @@
 .set PROT_MODE_CSEG,        0x8                     # kernel code segment selector
 .set PROT_MODE_DSEG,        0x10                    # kernel data segment selector
 .set CR0_PE_ON,             0x1                     # protected mode enable flag
-.set SMAP,                  0x534d4150
 
 # start address should be 0:7c00, in real mode, the beginning address of the running bootloader
 .globl start
@@ -43,25 +42,6 @@
     movb $0xdf, %al                                 # 0xdf -> port 0x60
     outb %al, $0x60                                 # 0xdf = 11011111, means set P2's A20 bit(the 1 bit) to 1
 
-probe_memory:
-    movl $0, 0x8000
-    xorl %ebx, %ebx
-    movw $0x8004, %di
-start_probe:
-    movl $0xE820, %eax
-    movl $20, %ecx
-    movl $SMAP, %edx
-    int $0x15
-    jnc cont
-    movw $12345, 0x8000
-    jmp finish_probe
-cont:
-    addw $20, %di
-    incl 0x8000
-    cmpl $0, %ebx
-    jnz start_probe
-finish_probe:
-
     # Switch from real to protected mode, using a bootstrap GDT
     # and segment translation that makes virtual addresses
     # identical to physical addresses, so that the
@@ -94,7 +74,6 @@
 spin:
     jmp spin
 
-.data
 # Bootstrap GDT
 .p2align 2                                          # force 4 byte alignment
 gdt:
diff -urN lab2/kern/debug/kdebug.c lab1/kern/debug/kdebug.c
--- lab2/kern/debug/kdebug.c	2019-02-26 21:54:43.932194340 +0800
+++ lab1/kern/debug/kdebug.c	2019-03-08 19:48:53.095424785 +0800
@@ -3,10 +3,7 @@
 #include <stab.h>
 #include <stdio.h>
 #include <string.h>
-#include <sync.h>
 #include <kdebug.h>
-#include <kmonitor.h>
-#include <assert.h>
 
 #define STACKFRAME_DEPTH 20
 
@@ -305,5 +302,19 @@
       *           NOTICE: the calling funciton's return addr eip  = ss:[ebp+4]
       *                   the calling funciton's ebp = ss:[ebp]
       */
+	uint32_t ebp = read_ebp();
+	uint32_t eip = read_eip();
+	int i;
+	for(i = 0;i < STACKFRAME_DEPTH;i++){
+		cprintf("ebp:0x%08x eip:0x%08x ",ebp,eip);
+		cprintf("args:");
+		uint32_t *args = (uint32_t *)ebp + 2;
+		cprintf("0x%08x 0x%08x 0x%08x 0x%08x",args[0],args[1],args[2],args[3]);
+		cprintf("\n");
+		print_debuginfo(eip - 1);
+		eip =  ((uint32_t *) ebp)[1];
+		ebp = ((uint32_t *) ebp)[0];
+		if(ebp == 0) break;
+	}
 }
 
diff -urN lab2/kern/debug/kdebug.h lab1/kern/debug/kdebug.h
--- lab2/kern/debug/kdebug.h	2019-02-26 21:54:43.932194340 +0800
+++ lab1/kern/debug/kdebug.h	2019-02-28 18:26:57.000000000 +0800
@@ -2,7 +2,6 @@
 #define __KERN_DEBUG_KDEBUG_H__
 
 #include <defs.h>
-#include <trap.h>
 
 void print_kerninfo(void);
 void print_stackframe(void);
diff -urN lab2/kern/debug/kmonitor.c lab1/kern/debug/kmonitor.c
--- lab2/kern/debug/kmonitor.c	2019-02-26 21:54:43.932194340 +0800
+++ lab1/kern/debug/kmonitor.c	2019-02-28 18:26:57.000000000 +0800
@@ -1,6 +1,5 @@
 #include <stdio.h>
 #include <string.h>
-#include <mmu.h>
 #include <trap.h>
 #include <kmonitor.h>
 #include <kdebug.h>
@@ -23,9 +22,6 @@
     {"backtrace", "Print backtrace of stack frame.", mon_backtrace},
 };
 
-/* return if kernel is panic, in kern/debug/panic.c */
-bool is_kernel_panic(void);
-
 #define NCOMMANDS (sizeof(commands)/sizeof(struct command))
 
 /***** Kernel monitor command interpreter *****/
diff -urN lab2/kern/debug/kmonitor.h lab1/kern/debug/kmonitor.h
--- lab2/kern/debug/kmonitor.h	2019-02-26 21:54:43.932194340 +0800
+++ lab1/kern/debug/kmonitor.h	2019-02-28 18:26:57.000000000 +0800
@@ -8,12 +8,6 @@
 int mon_help(int argc, char **argv, struct trapframe *tf);
 int mon_kerninfo(int argc, char **argv, struct trapframe *tf);
 int mon_backtrace(int argc, char **argv, struct trapframe *tf);
-int mon_continue(int argc, char **argv, struct trapframe *tf);
-int mon_step(int argc, char **argv, struct trapframe *tf);
-int mon_breakpoint(int argc, char **argv, struct trapframe *tf);
-int mon_watchpoint(int argc, char **argv, struct trapframe *tf);
-int mon_delete_dr(int argc, char **argv, struct trapframe *tf);
-int mon_list_dr(int argc, char **argv, struct trapframe *tf);
 
 #endif /* !__KERN_DEBUG_MONITOR_H__ */
 
diff -urN lab2/kern/driver/console.c lab1/kern/driver/console.c
--- lab2/kern/driver/console.c	2019-02-26 21:54:43.932194340 +0800
+++ lab1/kern/driver/console.c	2019-02-28 18:26:57.000000000 +0800
@@ -5,8 +5,6 @@
 #include <kbdreg.h>
 #include <picirq.h>
 #include <trap.h>
-#include <memlayout.h>
-#include <sync.h>
 
 /* stupid I/O delay routine necessitated by historical PC design flaws */
 static void
@@ -54,30 +52,41 @@
 static uint16_t crt_pos;
 static uint16_t addr_6845;
 
-/* TEXT-mode CGA/VGA display output */
+// 显示器初始化，CGA 是 Color Graphics Adapter 的缩写
+// CGA显存按照下面的方式映射：
+//   -- 0xB0000 - 0xB7FFF 单色字符模式
+//   -- 0xB8000 - 0xBFFFF 彩色字符模式及 CGA 兼容图形模式
+// 6845芯片是IBM PC中的视频控制器
+// CPU通过IO地址0x3B4-0x3B5来驱动6845控制单色显示，通过IO地址0x3D4-0x3D5来控制彩色显示。
+//    -- 数据寄存器 映射 到 端口 0x3D5或0x3B5 
+//    -- 索引寄存器 0x3D4或0x3B4,决定在数据寄存器中的数据表示什么。
 
+/* TEXT-mode CGA/VGA display output */
 static void
 cga_init(void) {
-    volatile uint16_t *cp = (uint16_t *)(CGA_BUF + KERNBASE);
-    uint16_t was = *cp;
-    *cp = (uint16_t) 0xA55A;
-    if (*cp != 0xA55A) {
-        cp = (uint16_t*)(MONO_BUF + KERNBASE);
-        addr_6845 = MONO_BASE;
-    } else {
-        *cp = was;
-        addr_6845 = CGA_BASE;
+    volatile uint16_t *cp = (uint16_t *)CGA_BUF;   //CGA_BUF: 0xB8000 (彩色显示的显存物理基址)
+    uint16_t was = *cp;                                            //保存当前显存0xB8000处的值
+    *cp = (uint16_t) 0xA55A;                                   // 给这个地址随便写个值，看看能否再读出同样的值
+    if (*cp != 0xA55A) {                                            // 如果读不出来，说明没有这块显存，即是单显配置
+        cp = (uint16_t*)MONO_BUF;                         //设置为单显的显存基址 MONO_BUF： 0xB0000
+        addr_6845 = MONO_BASE;                           //设置为单显控制的IO地址，MONO_BASE: 0x3B4
+    } else {                                                                // 如果读出来了，有这块显存，即是彩显配置
+        *cp = was;                                                      //还原原来显存位置的值
+        addr_6845 = CGA_BASE;                               // 设置为彩显控制的IO地址，CGA_BASE: 0x3D4 
     }
 
     // Extract cursor location
+    // 6845索引寄存器的index 0x0E（及十进制的14）== 光标位置(高位)
+    // 6845索引寄存器的index 0x0F（及十进制的15）== 光标位置(低位)
+    // 6845 reg 15 : Cursor Address (Low Byte)
     uint32_t pos;
-    outb(addr_6845, 14);
-    pos = inb(addr_6845 + 1) << 8;
+    outb(addr_6845, 14);                                        
+    pos = inb(addr_6845 + 1) << 8;                       //读出了光标位置(高位)
     outb(addr_6845, 15);
-    pos |= inb(addr_6845 + 1);
+    pos |= inb(addr_6845 + 1);                             //读出了光标位置(低位)
 
-    crt_buf = (uint16_t*) cp;
-    crt_pos = pos;
+    crt_buf = (uint16_t*) cp;                                  //crt_buf是CGA显存起始地址
+    crt_pos = pos;                                                  //crt_pos是CGA当前光标位置
 }
 
 static bool serial_exists = 0;
@@ -425,14 +434,9 @@
 /* cons_putc - print a single character @c to console devices */
 void
 cons_putc(int c) {
-    bool intr_flag;
-    local_intr_save(intr_flag);
-    {
-        lpt_putc(c);
-        cga_putc(c);
-        serial_putc(c);
-    }
-    local_intr_restore(intr_flag);
+    lpt_putc(c);
+    cga_putc(c);
+    serial_putc(c);
 }
 
 /* *
@@ -441,25 +445,22 @@
  * */
 int
 cons_getc(void) {
-    int c = 0;
-    bool intr_flag;
-    local_intr_save(intr_flag);
-    {
-        // poll for any pending input characters,
-        // so that this function works even when interrupts are disabled
-        // (e.g., when called from the kernel monitor).
-        serial_intr();
-        kbd_intr();
-
-        // grab the next character from the input buffer.
-        if (cons.rpos != cons.wpos) {
-            c = cons.buf[cons.rpos ++];
-            if (cons.rpos == CONSBUFSIZE) {
-                cons.rpos = 0;
-            }
+    int c;
+
+    // poll for any pending input characters,
+    // so that this function works even when interrupts are disabled
+    // (e.g., when called from the kernel monitor).
+    serial_intr();
+    kbd_intr();
+
+    // grab the next character from the input buffer.
+    if (cons.rpos != cons.wpos) {
+        c = cons.buf[cons.rpos ++];
+        if (cons.rpos == CONSBUFSIZE) {
+            cons.rpos = 0;
         }
+        return c;
     }
-    local_intr_restore(intr_flag);
-    return c;
+    return 0;
 }
 
diff -urN lab2/kern/init/entry.S lab1/kern/init/entry.S
--- lab2/kern/init/entry.S	2019-02-26 21:54:43.932194340 +0800
+++ lab1/kern/init/entry.S	1970-01-01 08:00:00.000000000 +0800
@@ -1,70 +0,0 @@
-#include <mmu.h>
-#include <memlayout.h>
-
-#define REALLOC(x) (x - KERNBASE)
-
-.text
-.globl kern_entry
-kern_entry:
-    # load pa of boot pgdir
-    movl $REALLOC(__boot_pgdir), %eax
-    movl %eax, %cr3
-
-    # enable paging
-    movl %cr0, %eax
-    orl $(CR0_PE | CR0_PG | CR0_AM | CR0_WP | CR0_NE | CR0_TS | CR0_EM | CR0_MP), %eax
-    andl $~(CR0_TS | CR0_EM), %eax
-    movl %eax, %cr0
-
-    # update eip
-    # now, eip = 0x1.....
-    leal next, %eax
-    # set eip = KERNBASE + 0x1.....
-    jmp *%eax
-next:
-
-    # unmap va 0 ~ 4M, it's temporary mapping
-    xorl %eax, %eax
-    movl %eax, __boot_pgdir
-
-    # set ebp, esp
-    movl $0x0, %ebp
-    # the kernel stack region is from bootstack -- bootstacktop,
-    # the kernel stack size is KSTACKSIZE (8KB)defined in memlayout.h
-    movl $bootstacktop, %esp
-    # now kernel stack is ready , call the first C function
-    call kern_init
-
-# should never get here
-spin:
-    jmp spin
-
-.data
-.align PGSIZE
-    .globl bootstack
-bootstack:
-    .space KSTACKSIZE
-    .globl bootstacktop
-bootstacktop:
-
-# kernel builtin pgdir
-# an initial page directory (Page Directory Table, PDT)
-# These page directory table and page table can be reused!
-.section .data.pgdir
-.align PGSIZE
-__boot_pgdir:
-.globl __boot_pgdir
-    # map va 0 ~ 4M to pa 0 ~ 4M (temporary)
-    .long REALLOC(__boot_pt1) + (PTE_P | PTE_U | PTE_W)
-    .space (KERNBASE >> PGSHIFT >> 10 << 2) - (. - __boot_pgdir) # pad to PDE of KERNBASE
-    # map va KERNBASE + (0 ~ 4M) to pa 0 ~ 4M
-    .long REALLOC(__boot_pt1) + (PTE_P | PTE_U | PTE_W)
-    .space PGSIZE - (. - __boot_pgdir) # pad to PGSIZE
-
-.set i, 0
-__boot_pt1:
-.rept 1024
-    .long i * PGSIZE + (PTE_P | PTE_W)
-    .set i, i + 1
-.endr
-
diff -urN lab2/kern/init/init.c lab1/kern/init/init.c
--- lab2/kern/init/init.c	2019-02-26 21:54:43.932194340 +0800
+++ lab1/kern/init/init.c	2019-02-28 18:26:57.000000000 +0800
@@ -9,7 +9,6 @@
 #include <intr.h>
 #include <pmm.h>
 #include <kmonitor.h>
-
 int kern_init(void) __attribute__((noreturn));
 void grade_backtrace(void);
 static void lab1_switch_test(void);
diff -urN lab2/kern/libs/readline.c lab1/kern/libs/readline.c
--- lab2/kern/libs/readline.c	2019-02-26 21:54:43.932194340 +0800
+++ lab1/kern/libs/readline.c	2019-02-28 18:26:57.000000000 +0800
@@ -1,11 +1,11 @@
 #include <stdio.h>
 
-#define BUFSIZE 1024
+#define BUFSIZE    1024
 static char buf[BUFSIZE];
 
 /* *
  * readline - get a line from stdin
- * @prompt:     the string to be written to stdout
+ * @prompt:        the string to be written to stdout
  *
  * The readline() function will write the input string @prompt to
  * stdout first. If the @prompt is NULL or the empty string,
diff -urN lab2/kern/mm/default_pmm.c lab1/kern/mm/default_pmm.c
--- lab2/kern/mm/default_pmm.c	2019-02-26 21:54:43.932194340 +0800
+++ lab1/kern/mm/default_pmm.c	1970-01-01 08:00:00.000000000 +0800
@@ -1,311 +0,0 @@
-#include <pmm.h>
-#include <list.h>
-#include <string.h>
-#include <default_pmm.h>
-
-/*  In the First Fit algorithm, the allocator keeps a list of free blocks
- * (known as the free list). Once receiving a allocation request for memory,
- * it scans along the list for the first block that is large enough to satisfy
- * the request. If the chosen block is significantly larger than requested, it
- * is usually splitted, and the remainder will be added into the list as
- * another free block.
- *  Please refer to Page 196~198, Section 8.2 of Yan Wei Min's Chinese book
- * "Data Structure -- C programming language".
-*/
-// LAB2 EXERCISE 1: YOUR CODE
-// you should rewrite functions: `default_init`, `default_init_memmap`,
-// `default_alloc_pages`, `default_free_pages`.
-/*
- * Details of FFMA
- * (1) Preparation:
- *  In order to implement the First-Fit Memory Allocation (FFMA), we should
- * manage the free memory blocks using a list. The struct `free_area_t` is used
- * for the management of free memory blocks.
- *  First, you should get familiar with the struct `list` in list.h. Struct
- * `list` is a simple doubly linked list implementation. You should know how to
- * USE `list_init`, `list_add`(`list_add_after`), `list_add_before`, `list_del`,
- * `list_next`, `list_prev`.
- *  There's a tricky method that is to transform a general `list` struct to a
- * special struct (such as struct `page`), using the following MACROs: `le2page`
- * (in memlayout.h), (and in future labs: `le2vma` (in vmm.h), `le2proc` (in
- * proc.h), etc).
- * (2) `default_init`:
- *  You can reuse the demo `default_init` function to initialize the `free_list`
- * and set `nr_free` to 0. `free_list` is used to record the free memory blocks.
- * `nr_free` is the total number of the free memory blocks.
- * (3) `default_init_memmap`:
- *  CALL GRAPH: `kern_init` --> `pmm_init` --> `page_init` --> `init_memmap` -->
- * `pmm_manager` --> `init_memmap`.
- *  This function is used to initialize a free block (with parameter `addr_base`,
- * `page_number`). In order to initialize a free block, firstly, you should
- * initialize each page (defined in memlayout.h) in this free block. This
- * procedure includes:
- *  - Setting the bit `PG_property` of `p->flags`, which means this page is
- * valid. P.S. In function `pmm_init` (in pmm.c), the bit `PG_reserved` of
- * `p->flags` is already set.
- *  - If this page is free and is not the first page of a free block,
- * `p->property` should be set to 0.
- *  - If this page is free and is the first page of a free block, `p->property`
- * should be set to be the total number of pages in the block.
- *  - `p->ref` should be 0, because now `p` is free and has no reference.
- *  After that, We can use `p->page_link` to link this page into `free_list`.
- * (e.g.: `list_add_before(&free_list, &(p->page_link));` )
- *  Finally, we should update the sum of the free memory blocks: `nr_free += n`.
- * (4) `default_alloc_pages`:
- *  Search for the first free block (block size >= n) in the free list and reszie
- * the block found, returning the address of this block as the address required by
- * `malloc`.
- *  (4.1)
- *      So you should search the free list like this:
- *          list_entry_t le = &free_list;
- *          while((le=list_next(le)) != &free_list) {
- *          ...
- *      (4.1.1)
- *          In the while loop, get the struct `page` and check if `p->property`
- *      (recording the num of free pages in this block) >= n.
- *              struct Page *p = le2page(le, page_link);
- *              if(p->property >= n){ ...
- *      (4.1.2)
- *          If we find this `p`, it means we've found a free block with its size
- *      >= n, whose first `n` pages can be malloced. Some flag bits of this page
- *      should be set as the following: `PG_reserved = 1`, `PG_property = 0`.
- *      Then, unlink the pages from `free_list`.
- *          (4.1.2.1)
- *              If `p->property > n`, we should re-calculate number of the rest
- *          pages of this free block. (e.g.: `le2page(le,page_link))->property
- *          = p->property - n;`)
- *          (4.1.3)
- *              Re-caluclate `nr_free` (number of the the rest of all free block).
- *          (4.1.4)
- *              return `p`.
- *      (4.2)
- *          If we can not find a free block with its size >=n, then return NULL.
- * (5) `default_free_pages`:
- *  re-link the pages into the free list, and may merge small free blocks into
- * the big ones.
- *  (5.1)
- *      According to the base address of the withdrawed blocks, search the free
- *  list for its correct position (with address from low to high), and insert
- *  the pages. (May use `list_next`, `le2page`, `list_add_before`)
- *  (5.2)
- *      Reset the fields of the pages, such as `p->ref` and `p->flags` (PageProperty)
- *  (5.3)
- *      Try to merge blocks at lower or higher addresses. Notice: This should
- *  change some pages' `p->property` correctly.
- */
-free_area_t free_area;
-
-#define free_list (free_area.free_list)
-#define nr_free (free_area.nr_free)
-
-static void
-default_init(void) {
-    list_init(&free_list);
-    nr_free = 0;
-}
-
-static void
-default_init_memmap(struct Page *base, size_t n) {
-    assert(n > 0);
-    struct Page *p = base;
-    for (; p != base + n; p ++) {
-        assert(PageReserved(p));
-        p->flags = p->property = 0;
-        set_page_ref(p, 0);
-    }
-    base->property = n;
-    SetPageProperty(base);
-    nr_free += n;
-    list_add(&free_list, &(base->page_link));
-}
-
-static struct Page *
-default_alloc_pages(size_t n) {
-    assert(n > 0);
-    if (n > nr_free) {
-        return NULL;
-    }
-    struct Page *page = NULL;
-    list_entry_t *le = &free_list;
-    while ((le = list_next(le)) != &free_list) {
-        struct Page *p = le2page(le, page_link);
-        if (p->property >= n) {
-            page = p;
-            break;
-        }
-    }
-    if (page != NULL) {
-        list_del(&(page->page_link));
-        if (page->property > n) {
-            struct Page *p = page + n;
-            p->property = page->property - n;
-            list_add(&free_list, &(p->page_link));
-    }
-        nr_free -= n;
-        ClearPageProperty(page);
-    }
-    return page;
-}
-
-static void
-default_free_pages(struct Page *base, size_t n) {
-    assert(n > 0);
-    struct Page *p = base;
-    for (; p != base + n; p ++) {
-        assert(!PageReserved(p) && !PageProperty(p));
-        p->flags = 0;
-        set_page_ref(p, 0);
-    }
-    base->property = n;
-    SetPageProperty(base);
-    list_entry_t *le = list_next(&free_list);
-    while (le != &free_list) {
-        p = le2page(le, page_link);
-        le = list_next(le);
-        if (base + base->property == p) {
-            base->property += p->property;
-            ClearPageProperty(p);
-            list_del(&(p->page_link));
-        }
-        else if (p + p->property == base) {
-            p->property += base->property;
-            ClearPageProperty(base);
-            base = p;
-            list_del(&(p->page_link));
-        }
-    }
-    nr_free += n;
-    list_add(&free_list, &(base->page_link));
-}
-
-static size_t
-default_nr_free_pages(void) {
-    return nr_free;
-}
-
-static void
-basic_check(void) {
-    struct Page *p0, *p1, *p2;
-    p0 = p1 = p2 = NULL;
-    assert((p0 = alloc_page()) != NULL);
-    assert((p1 = alloc_page()) != NULL);
-    assert((p2 = alloc_page()) != NULL);
-
-    assert(p0 != p1 && p0 != p2 && p1 != p2);
-    assert(page_ref(p0) == 0 && page_ref(p1) == 0 && page_ref(p2) == 0);
-
-    assert(page2pa(p0) < npage * PGSIZE);
-    assert(page2pa(p1) < npage * PGSIZE);
-    assert(page2pa(p2) < npage * PGSIZE);
-
-    list_entry_t free_list_store = free_list;
-    list_init(&free_list);
-    assert(list_empty(&free_list));
-
-    unsigned int nr_free_store = nr_free;
-    nr_free = 0;
-
-    assert(alloc_page() == NULL);
-
-    free_page(p0);
-    free_page(p1);
-    free_page(p2);
-    assert(nr_free == 3);
-
-    assert((p0 = alloc_page()) != NULL);
-    assert((p1 = alloc_page()) != NULL);
-    assert((p2 = alloc_page()) != NULL);
-
-    assert(alloc_page() == NULL);
-
-    free_page(p0);
-    assert(!list_empty(&free_list));
-
-    struct Page *p;
-    assert((p = alloc_page()) == p0);
-    assert(alloc_page() == NULL);
-
-    assert(nr_free == 0);
-    free_list = free_list_store;
-    nr_free = nr_free_store;
-
-    free_page(p);
-    free_page(p1);
-    free_page(p2);
-}
-
-// LAB2: below code is used to check the first fit allocation algorithm (your EXERCISE 1) 
-// NOTICE: You SHOULD NOT CHANGE basic_check, default_check functions!
-static void
-default_check(void) {
-    int count = 0, total = 0;
-    list_entry_t *le = &free_list;
-    while ((le = list_next(le)) != &free_list) {
-        struct Page *p = le2page(le, page_link);
-        assert(PageProperty(p));
-        count ++, total += p->property;
-    }
-    assert(total == nr_free_pages());
-
-    basic_check();
-
-    struct Page *p0 = alloc_pages(5), *p1, *p2;
-    assert(p0 != NULL);
-    assert(!PageProperty(p0));
-
-    list_entry_t free_list_store = free_list;
-    list_init(&free_list);
-    assert(list_empty(&free_list));
-    assert(alloc_page() == NULL);
-
-    unsigned int nr_free_store = nr_free;
-    nr_free = 0;
-
-    free_pages(p0 + 2, 3);
-    assert(alloc_pages(4) == NULL);
-    assert(PageProperty(p0 + 2) && p0[2].property == 3);
-    assert((p1 = alloc_pages(3)) != NULL);
-    assert(alloc_page() == NULL);
-    assert(p0 + 2 == p1);
-
-    p2 = p0 + 1;
-    free_page(p0);
-    free_pages(p1, 3);
-    assert(PageProperty(p0) && p0->property == 1);
-    assert(PageProperty(p1) && p1->property == 3);
-
-    assert((p0 = alloc_page()) == p2 - 1);
-    free_page(p0);
-    assert((p0 = alloc_pages(2)) == p2 + 1);
-
-    free_pages(p0, 2);
-    free_page(p2);
-
-    assert((p0 = alloc_pages(5)) != NULL);
-    assert(alloc_page() == NULL);
-
-    assert(nr_free == 0);
-    nr_free = nr_free_store;
-
-    free_list = free_list_store;
-    free_pages(p0, 5);
-
-    le = &free_list;
-    while ((le = list_next(le)) != &free_list) {
-        struct Page *p = le2page(le, page_link);
-        count --, total -= p->property;
-    }
-    assert(count == 0);
-    assert(total == 0);
-}
-
-const struct pmm_manager default_pmm_manager = {
-    .name = "default_pmm_manager",
-    .init = default_init,
-    .init_memmap = default_init_memmap,
-    .alloc_pages = default_alloc_pages,
-    .free_pages = default_free_pages,
-    .nr_free_pages = default_nr_free_pages,
-    .check = default_check,
-};
-
diff -urN lab2/kern/mm/default_pmm.h lab1/kern/mm/default_pmm.h
--- lab2/kern/mm/default_pmm.h	2019-02-26 21:54:43.932194340 +0800
+++ lab1/kern/mm/default_pmm.h	1970-01-01 08:00:00.000000000 +0800
@@ -1,9 +0,0 @@
-#ifndef __KERN_MM_DEFAULT_PMM_H__
-#define  __KERN_MM_DEFAULT_PMM_H__
-
-#include <pmm.h>
-
-extern const struct pmm_manager default_pmm_manager;
-
-#endif /* ! __KERN_MM_DEFAULT_PMM_H__ */
-
diff -urN lab2/kern/mm/memlayout.h lab1/kern/mm/memlayout.h
--- lab2/kern/mm/memlayout.h	2019-02-26 21:54:43.932194340 +0800
+++ lab1/kern/mm/memlayout.h	2019-02-28 18:26:57.000000000 +0800
@@ -4,127 +4,26 @@
 /* This file contains the definitions for memory management in our OS. */
 
 /* global segment number */
-#define SEG_KTEXT   1
-#define SEG_KDATA   2
-#define SEG_UTEXT   3
-#define SEG_UDATA   4
-#define SEG_TSS     5
-
-/* global descrptor numbers */
-#define GD_KTEXT    ((SEG_KTEXT) << 3)      // kernel text
-#define GD_KDATA    ((SEG_KDATA) << 3)      // kernel data
-#define GD_UTEXT    ((SEG_UTEXT) << 3)      // user text
-#define GD_UDATA    ((SEG_UDATA) << 3)      // user data
-#define GD_TSS      ((SEG_TSS) << 3)        // task segment selector
+#define SEG_KTEXT    1
+#define SEG_KDATA    2
+#define SEG_UTEXT    3
+#define SEG_UDATA    4
+#define SEG_TSS        5
+
+/* global descriptor numbers */
+#define GD_KTEXT    ((SEG_KTEXT) << 3)        // kernel text
+#define GD_KDATA    ((SEG_KDATA) << 3)        // kernel data
+#define GD_UTEXT    ((SEG_UTEXT) << 3)        // user text
+#define GD_UDATA    ((SEG_UDATA) << 3)        // user data
+#define GD_TSS        ((SEG_TSS) << 3)        // task segment selector
 
-#define DPL_KERNEL  (0)
+#define DPL_KERNEL    (0)
 #define DPL_USER    (3)
 
-#define KERNEL_CS   ((GD_KTEXT) | DPL_KERNEL)
-#define KERNEL_DS   ((GD_KDATA) | DPL_KERNEL)
-#define USER_CS     ((GD_UTEXT) | DPL_USER)
-#define USER_DS     ((GD_UDATA) | DPL_USER)
-
-/* *
- * Virtual memory map:                                          Permissions
- *                                                              kernel/user
- *
- *     4G ------------------> +---------------------------------+
- *                            |                                 |
- *                            |         Empty Memory (*)        |
- *                            |                                 |
- *                            +---------------------------------+ 0xFB000000
- *                            |   Cur. Page Table (Kern, RW)    | RW/-- PTSIZE
- *     VPT -----------------> +---------------------------------+ 0xFAC00000
- *                            |        Invalid Memory (*)       | --/--
- *     KERNTOP -------------> +---------------------------------+ 0xF8000000
- *                            |                                 |
- *                            |    Remapped Physical Memory     | RW/-- KMEMSIZE
- *                            |                                 |
- *     KERNBASE ------------> +---------------------------------+ 0xC0000000
- *                            |                                 |
- *                            |                                 |
- *                            |                                 |
- *                            ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
- * (*) Note: The kernel ensures that "Invalid Memory" is *never* mapped.
- *     "Empty Memory" is normally unmapped, but user programs may map pages
- *     there if desired.
- *
- * */
-
-/* All physical memory mapped at this address */
-#define KERNBASE            0xC0000000
-#define KMEMSIZE            0x38000000                  // the maximum amount of physical memory
-#define KERNTOP             (KERNBASE + KMEMSIZE)
-
-/* *
- * Virtual page table. Entry PDX[VPT] in the PD (Page Directory) contains
- * a pointer to the page directory itself, thereby turning the PD into a page
- * table, which maps all the PTEs (Page Table Entry) containing the page mappings
- * for the entire virtual address space into that 4 Meg region starting at VPT.
- * */
-#define VPT                 0xFAC00000
-
-#define KSTACKPAGE          2                           // # of pages in kernel stack
-#define KSTACKSIZE          (KSTACKPAGE * PGSIZE)       // sizeof kernel stack
-
-#ifndef __ASSEMBLER__
-
-#include <defs.h>
-#include <atomic.h>
-#include <list.h>
-
-typedef uintptr_t pte_t;
-typedef uintptr_t pde_t;
-
-// some constants for bios interrupt 15h AX = 0xE820
-#define E820MAX             20      // number of entries in E820MAP
-#define E820_ARM            1       // address range memory
-#define E820_ARR            2       // address range reserved
-
-struct e820map {
-    int nr_map;
-    struct {
-        uint64_t addr;
-        uint64_t size;
-        uint32_t type;
-    } __attribute__((packed)) map[E820MAX];
-};
-
-/* *
- * struct Page - Page descriptor structures. Each Page describes one
- * physical page. In kern/mm/pmm.h, you can find lots of useful functions
- * that convert Page to other data types, such as phyical address.
- * */
-struct Page {
-    int ref;                        // page frame's reference counter
-    uint32_t flags;                 // array of flags that describe the status of the page frame
-    unsigned int property;          // the num of free block, used in first fit pm manager
-    list_entry_t page_link;         // free list link
-};
-
-/* Flags describing the status of a page frame */
-#define PG_reserved                 0       // if this bit=1: the Page is reserved for kernel, cannot be used in alloc/free_pages; otherwise, this bit=0 
-#define PG_property                 1       // if this bit=1: the Page is the head page of a free memory block(contains some continuous_addrress pages), and can be used in alloc_pages; if this bit=0: if the Page is the the head page of a free memory block, then this Page and the memory block is alloced. Or this Page isn't the head page.
-
-#define SetPageReserved(page)       set_bit(PG_reserved, &((page)->flags))
-#define ClearPageReserved(page)     clear_bit(PG_reserved, &((page)->flags))
-#define PageReserved(page)          test_bit(PG_reserved, &((page)->flags))
-#define SetPageProperty(page)       set_bit(PG_property, &((page)->flags))
-#define ClearPageProperty(page)     clear_bit(PG_property, &((page)->flags))
-#define PageProperty(page)          test_bit(PG_property, &((page)->flags))
-
-// convert list entry to page
-#define le2page(le, member)                 \
-    to_struct((le), struct Page, member)
-
-/* free_area_t - maintains a doubly linked list to record free (unused) pages */
-typedef struct {
-    list_entry_t free_list;         // the list header
-    unsigned int nr_free;           // # of free pages in this free list
-} free_area_t;
-
-#endif /* !__ASSEMBLER__ */
+#define KERNEL_CS    ((GD_KTEXT) | DPL_KERNEL)
+#define KERNEL_DS    ((GD_KDATA) | DPL_KERNEL)
+#define USER_CS        ((GD_UTEXT) | DPL_USER)
+#define USER_DS        ((GD_UDATA) | DPL_USER)
 
 #endif /* !__KERN_MM_MEMLAYOUT_H__ */
 
diff -urN lab2/kern/mm/mmu.h lab1/kern/mm/mmu.h
--- lab2/kern/mm/mmu.h	2019-02-26 21:54:43.932194340 +0800
+++ lab1/kern/mm/mmu.h	2019-02-28 18:26:57.000000000 +0800
@@ -2,76 +2,61 @@
 #define __KERN_MM_MMU_H__
 
 /* Eflags register */
-#define FL_CF           0x00000001  // Carry Flag
-#define FL_PF           0x00000004  // Parity Flag
-#define FL_AF           0x00000010  // Auxiliary carry Flag
-#define FL_ZF           0x00000040  // Zero Flag
-#define FL_SF           0x00000080  // Sign Flag
-#define FL_TF           0x00000100  // Trap Flag
-#define FL_IF           0x00000200  // Interrupt Flag
-#define FL_DF           0x00000400  // Direction Flag
-#define FL_OF           0x00000800  // Overflow Flag
-#define FL_IOPL_MASK    0x00003000  // I/O Privilege Level bitmask
-#define FL_IOPL_0       0x00000000  //   IOPL == 0
-#define FL_IOPL_1       0x00001000  //   IOPL == 1
-#define FL_IOPL_2       0x00002000  //   IOPL == 2
-#define FL_IOPL_3       0x00003000  //   IOPL == 3
-#define FL_NT           0x00004000  // Nested Task
-#define FL_RF           0x00010000  // Resume Flag
-#define FL_VM           0x00020000  // Virtual 8086 mode
-#define FL_AC           0x00040000  // Alignment Check
-#define FL_VIF          0x00080000  // Virtual Interrupt Flag
-#define FL_VIP          0x00100000  // Virtual Interrupt Pending
-#define FL_ID           0x00200000  // ID flag
+#define FL_CF            0x00000001    // Carry Flag
+#define FL_PF            0x00000004    // Parity Flag
+#define FL_AF            0x00000010    // Auxiliary carry Flag
+#define FL_ZF            0x00000040    // Zero Flag
+#define FL_SF            0x00000080    // Sign Flag
+#define FL_TF            0x00000100    // Trap Flag
+#define FL_IF            0x00000200    // Interrupt Flag
+#define FL_DF            0x00000400    // Direction Flag
+#define FL_OF            0x00000800    // Overflow Flag
+#define FL_IOPL_MASK    0x00003000    // I/O Privilege Level bitmask
+#define FL_IOPL_0        0x00000000    //   IOPL == 0
+#define FL_IOPL_1        0x00001000    //   IOPL == 1
+#define FL_IOPL_2        0x00002000    //   IOPL == 2
+#define FL_IOPL_3        0x00003000    //   IOPL == 3
+#define FL_NT            0x00004000    // Nested Task
+#define FL_RF            0x00010000    // Resume Flag
+#define FL_VM            0x00020000    // Virtual 8086 mode
+#define FL_AC            0x00040000    // Alignment Check
+#define FL_VIF            0x00080000    // Virtual Interrupt Flag
+#define FL_VIP            0x00100000    // Virtual Interrupt Pending
+#define FL_ID            0x00200000    // ID flag
 
 /* Application segment type bits */
-#define STA_X           0x8         // Executable segment
-#define STA_E           0x4         // Expand down (non-executable segments)
-#define STA_C           0x4         // Conforming code segment (executable only)
-#define STA_W           0x2         // Writeable (non-executable segments)
-#define STA_R           0x2         // Readable (executable segments)
-#define STA_A           0x1         // Accessed
+#define STA_X            0x8            // Executable segment
+#define STA_E            0x4            // Expand down (non-executable segments)
+#define STA_C            0x4            // Conforming code segment (executable only)
+#define STA_W            0x2            // Writeable (non-executable segments)
+#define STA_R            0x2            // Readable (executable segments)
+#define STA_A            0x1            // Accessed
 
 /* System segment type bits */
-#define STS_T16A        0x1         // Available 16-bit TSS
-#define STS_LDT         0x2         // Local Descriptor Table
-#define STS_T16B        0x3         // Busy 16-bit TSS
-#define STS_CG16        0x4         // 16-bit Call Gate
-#define STS_TG          0x5         // Task Gate / Coum Transmitions
-#define STS_IG16        0x6         // 16-bit Interrupt Gate
-#define STS_TG16        0x7         // 16-bit Trap Gate
-#define STS_T32A        0x9         // Available 32-bit TSS
-#define STS_T32B        0xB         // Busy 32-bit TSS
-#define STS_CG32        0xC         // 32-bit Call Gate
-#define STS_IG32        0xE         // 32-bit Interrupt Gate
-#define STS_TG32        0xF         // 32-bit Trap Gate
-
-#ifdef __ASSEMBLER__
-
-#define SEG_NULL                                                \
-    .word 0, 0;                                                 \
-    .byte 0, 0, 0, 0
-
-#define SEG_ASM(type,base,lim)                                  \
-    .word (((lim) >> 12) & 0xffff), ((base) & 0xffff);          \
-    .byte (((base) >> 16) & 0xff), (0x90 | (type)),             \
-        (0xC0 | (((lim) >> 28) & 0xf)), (((base) >> 24) & 0xff)
-
-#else /* not __ASSEMBLER__ */
-
-#include <defs.h>
+#define STS_T16A        0x1            // Available 16-bit TSS
+#define STS_LDT            0x2            // Local Descriptor Table
+#define STS_T16B        0x3            // Busy 16-bit TSS
+#define STS_CG16        0x4            // 16-bit Call Gate
+#define STS_TG            0x5            // Task Gate / Coum Transmitions
+#define STS_IG16        0x6            // 16-bit Interrupt Gate
+#define STS_TG16        0x7            // 16-bit Trap Gate
+#define STS_T32A        0x9            // Available 32-bit TSS
+#define STS_T32B        0xB            // Busy 32-bit TSS
+#define STS_CG32        0xC            // 32-bit Call Gate
+#define STS_IG32        0xE            // 32-bit Interrupt Gate
+#define STS_TG32        0xF            // 32-bit Trap Gate
 
 /* Gate descriptors for interrupts and traps */
 struct gatedesc {
-    unsigned gd_off_15_0 : 16;      // low 16 bits of offset in segment
+    unsigned gd_off_15_0 : 16;        // low 16 bits of offset in segment
     unsigned gd_ss : 16;            // segment selector
-    unsigned gd_args : 5;           // # args, 0 for interrupt/trap gates
-    unsigned gd_rsv1 : 3;           // reserved(should be zero I guess)
-    unsigned gd_type : 4;           // type(STS_{TG,IG32,TG32})
-    unsigned gd_s : 1;              // must be 0 (system)
+    unsigned gd_args : 5;            // # args, 0 for interrupt/trap gates
+    unsigned gd_rsv1 : 3;            // reserved(should be zero I guess)
+    unsigned gd_type : 4;            // type(STS_{TG,IG32,TG32})
+    unsigned gd_s : 1;                // must be 0 (system)
     unsigned gd_dpl : 2;            // descriptor(meaning new) privilege level
-    unsigned gd_p : 1;              // Present
-    unsigned gd_off_31_16 : 16;     // high bits of offset in segment
+    unsigned gd_p : 1;                // Present
+    unsigned gd_off_31_16 : 16;        // high bits of offset in segment
 };
 
 /* *
@@ -83,71 +68,71 @@
  *          for software to invoke this interrupt/trap gate explicitly
  *          using an int instruction.
  * */
-#define SETGATE(gate, istrap, sel, off, dpl) {               \
-        (gate).gd_off_15_0 = (uint32_t)(off) & 0xffff;      \
-        (gate).gd_ss = (sel);                                \
-        (gate).gd_args = 0;                                 \
-        (gate).gd_rsv1 = 0;                                 \
-        (gate).gd_type = (istrap) ? STS_TG32 : STS_IG32;    \
-        (gate).gd_s = 0;                                    \
-        (gate).gd_dpl = (dpl);                              \
-        (gate).gd_p = 1;                                    \
-        (gate).gd_off_31_16 = (uint32_t)(off) >> 16;        \
-    }
+#define SETGATE(gate, istrap, sel, off, dpl) {            \
+    (gate).gd_off_15_0 = (uint32_t)(off) & 0xffff;        \
+    (gate).gd_ss = (sel);                                \
+    (gate).gd_args = 0;                                    \
+    (gate).gd_rsv1 = 0;                                    \
+    (gate).gd_type = (istrap) ? STS_TG32 : STS_IG32;    \
+    (gate).gd_s = 0;                                    \
+    (gate).gd_dpl = (dpl);                                \
+    (gate).gd_p = 1;                                    \
+    (gate).gd_off_31_16 = (uint32_t)(off) >> 16;        \
+}
 
 /* Set up a call gate descriptor */
-#define SETCALLGATE(gate, ss, off, dpl) {                   \
-        (gate).gd_off_15_0 = (uint32_t)(off) & 0xffff;      \
-        (gate).gd_ss = (ss);                                \
-        (gate).gd_args = 0;                                 \
-        (gate).gd_rsv1 = 0;                                 \
-        (gate).gd_type = STS_CG32;                          \
-        (gate).gd_s = 0;                                    \
-        (gate).gd_dpl = (dpl);                              \
-        (gate).gd_p = 1;                                    \
-        (gate).gd_off_31_16 = (uint32_t)(off) >> 16;        \
-    }
+#define SETCALLGATE(gate, ss, off, dpl) {                \
+    (gate).gd_off_15_0 = (uint32_t)(off) & 0xffff;        \
+    (gate).gd_ss = (ss);                                \
+    (gate).gd_args = 0;                                    \
+    (gate).gd_rsv1 = 0;                                    \
+    (gate).gd_type = STS_CG32;                            \
+    (gate).gd_s = 0;                                    \
+    (gate).gd_dpl = (dpl);                                \
+    (gate).gd_p = 1;                                    \
+    (gate).gd_off_31_16 = (uint32_t)(off) >> 16;        \
+}
 
 /* segment descriptors */
 struct segdesc {
-    unsigned sd_lim_15_0 : 16;      // low bits of segment limit
-    unsigned sd_base_15_0 : 16;     // low bits of segment base address
-    unsigned sd_base_23_16 : 8;     // middle bits of segment base address
-    unsigned sd_type : 4;           // segment type (see STS_ constants)
-    unsigned sd_s : 1;              // 0 = system, 1 = application
+    unsigned sd_lim_15_0 : 16;        // low bits of segment limit
+    unsigned sd_base_15_0 : 16;        // low bits of segment base address
+    unsigned sd_base_23_16 : 8;        // middle bits of segment base address
+    unsigned sd_type : 4;            // segment type (see STS_ constants)
+    unsigned sd_s : 1;                // 0 = system, 1 = application
     unsigned sd_dpl : 2;            // descriptor Privilege Level
-    unsigned sd_p : 1;              // present
-    unsigned sd_lim_19_16 : 4;      // high bits of segment limit
+    unsigned sd_p : 1;                // present
+    unsigned sd_lim_19_16 : 4;        // high bits of segment limit
     unsigned sd_avl : 1;            // unused (available for software use)
-    unsigned sd_rsv1 : 1;           // reserved
-    unsigned sd_db : 1;             // 0 = 16-bit segment, 1 = 32-bit segment
-    unsigned sd_g : 1;              // granularity: limit scaled by 4K when set
-    unsigned sd_base_31_24 : 8;     // high bits of segment base address
+    unsigned sd_rsv1 : 1;            // reserved
+    unsigned sd_db : 1;                // 0 = 16-bit segment, 1 = 32-bit segment
+    unsigned sd_g : 1;                // granularity: limit scaled by 4K when set
+    unsigned sd_base_31_24 : 8;        // high bits of segment base address
 };
 
 #define SEG_NULL                                            \
-    (struct segdesc) {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}
+    (struct segdesc){0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}
 
-#define SEG(type, base, lim, dpl)                           \
-    (struct segdesc) {                                      \
-        ((lim) >> 12) & 0xffff, (base) & 0xffff,            \
-        ((base) >> 16) & 0xff, type, 1, dpl, 1,             \
-        (unsigned)(lim) >> 28, 0, 0, 1, 1,                  \
-        (unsigned) (base) >> 24                             \
+#define SEG(type, base, lim, dpl)                        \
+    (struct segdesc){                                    \
+        ((lim) >> 12) & 0xffff, (base) & 0xffff,        \
+        ((base) >> 16) & 0xff, type, 1, dpl, 1,            \
+        (unsigned)(lim) >> 28, 0, 0, 1, 1,                \
+        (unsigned) (base) >> 24                            \
     }
 
-#define SEGTSS(type, base, lim, dpl)                        \
-    (struct segdesc) {                                      \
-        (lim) & 0xffff, (base) & 0xffff,                    \
-        ((base) >> 16) & 0xff, type, 0, dpl, 1,             \
-        (unsigned) (lim) >> 16, 0, 0, 1, 0,                 \
-        (unsigned) (base) >> 24                             \
+#define SEG16(type, base, lim, dpl)                        \
+    (struct segdesc){                                    \
+        (lim) & 0xffff, (base) & 0xffff,                \
+        ((base) >> 16) & 0xff, type, 1, dpl, 1,            \
+        (unsigned) (lim) >> 16, 0, 0, 1, 0,                \
+        (unsigned) (base) >> 24                            \
     }
 
 /* task state segment format (as described by the Pentium architecture book) */
 struct taskstate {
-    uint32_t ts_link;       // old ts selector
-    uintptr_t ts_esp0;      // stack pointers and segment selectors
+    uint32_t ts_link;        // old ts selector
+    uintptr_t ts_esp0;        // stack pointers and segment selectors
     uint16_t ts_ss0;        // after an increase in privilege level
     uint16_t ts_padding1;
     uintptr_t ts_esp1;
@@ -156,8 +141,8 @@
     uintptr_t ts_esp2;
     uint16_t ts_ss2;
     uint16_t ts_padding3;
-    uintptr_t ts_cr3;       // page directory base
-    uintptr_t ts_eip;       // saved state from last task switch
+    uintptr_t ts_cr3;        // page directory base
+    uintptr_t ts_eip;        // saved state from last task switch
     uint32_t ts_eflags;
     uint32_t ts_eax;        // more saved state (registers)
     uint32_t ts_ecx;
@@ -167,7 +152,7 @@
     uintptr_t ts_ebp;
     uint32_t ts_esi;
     uint32_t ts_edi;
-    uint16_t ts_es;         // even more saved state (segment selectors)
+    uint16_t ts_es;            // even more saved state (segment selectors)
     uint16_t ts_padding4;
     uint16_t ts_cs;
     uint16_t ts_padding5;
@@ -181,92 +166,9 @@
     uint16_t ts_padding9;
     uint16_t ts_ldt;
     uint16_t ts_padding10;
-    uint16_t ts_t;          // trap on task switch
-    uint16_t ts_iomb;       // i/o map base address
-} __attribute__((packed));
-
-#endif /* !__ASSEMBLER__ */
-
-// A linear address 'la' has a three-part structure as follows:
-//
-// +--------10------+-------10-------+---------12----------+
-// | Page Directory |   Page Table   | Offset within Page  |
-// |      Index     |     Index      |                     |
-// +----------------+----------------+---------------------+
-//  \--- PDX(la) --/ \--- PTX(la) --/ \---- PGOFF(la) ----/
-//  \----------- PPN(la) -----------/
-//
-// The PDX, PTX, PGOFF, and PPN macros decompose linear addresses as shown.
-// To construct a linear address la from PDX(la), PTX(la), and PGOFF(la),
-// use PGADDR(PDX(la), PTX(la), PGOFF(la)).
-
-// page directory index
-#define PDX(la) ((((uintptr_t)(la)) >> PDXSHIFT) & 0x3FF)
-
-// page table index
-#define PTX(la) ((((uintptr_t)(la)) >> PTXSHIFT) & 0x3FF)
-
-// page number field of address
-#define PPN(la) (((uintptr_t)(la)) >> PTXSHIFT)
-
-// offset in page
-#define PGOFF(la) (((uintptr_t)(la)) & 0xFFF)
-
-// construct linear address from indexes and offset
-#define PGADDR(d, t, o) ((uintptr_t)((d) << PDXSHIFT | (t) << PTXSHIFT | (o)))
-
-// address in page table or page directory entry
-#define PTE_ADDR(pte)   ((uintptr_t)(pte) & ~0xFFF)
-#define PDE_ADDR(pde)   PTE_ADDR(pde)
-
-/* page directory and page table constants */
-#define NPDEENTRY       1024                    // page directory entries per page directory
-#define NPTEENTRY       1024                    // page table entries per page table
-
-#define PGSIZE          4096                    // bytes mapped by a page
-#define PGSHIFT         12                      // log2(PGSIZE)
-#define PTSIZE          (PGSIZE * NPTEENTRY)    // bytes mapped by a page directory entry
-#define PTSHIFT         22                      // log2(PTSIZE)
-
-#define PTXSHIFT        12                      // offset of PTX in a linear address
-#define PDXSHIFT        22                      // offset of PDX in a linear address
-
-/* page table/directory entry flags */
-#define PTE_P           0x001                   // Present
-#define PTE_W           0x002                   // Writeable
-#define PTE_U           0x004                   // User
-#define PTE_PWT         0x008                   // Write-Through
-#define PTE_PCD         0x010                   // Cache-Disable
-#define PTE_A           0x020                   // Accessed
-#define PTE_D           0x040                   // Dirty
-#define PTE_PS          0x080                   // Page Size
-#define PTE_MBZ         0x180                   // Bits must be zero
-#define PTE_AVAIL       0xE00                   // Available for software use
-                                                // The PTE_AVAIL bits aren't used by the kernel or interpreted by the
-                                                // hardware, so user processes are allowed to set them arbitrarily.
-
-#define PTE_USER        (PTE_U | PTE_W | PTE_P)
-
-/* Control Register flags */
-#define CR0_PE          0x00000001              // Protection Enable
-#define CR0_MP          0x00000002              // Monitor coProcessor
-#define CR0_EM          0x00000004              // Emulation
-#define CR0_TS          0x00000008              // Task Switched
-#define CR0_ET          0x00000010              // Extension Type
-#define CR0_NE          0x00000020              // Numeric Errror
-#define CR0_WP          0x00010000              // Write Protect
-#define CR0_AM          0x00040000              // Alignment Mask
-#define CR0_NW          0x20000000              // Not Writethrough
-#define CR0_CD          0x40000000              // Cache Disable
-#define CR0_PG          0x80000000              // Paging
-
-#define CR4_PCE         0x00000100              // Performance counter enable
-#define CR4_MCE         0x00000040              // Machine Check Enable
-#define CR4_PSE         0x00000010              // Page Size Extensions
-#define CR4_DE          0x00000008              // Debugging Extensions
-#define CR4_TSD         0x00000004              // Time Stamp Disable
-#define CR4_PVI         0x00000002              // Protected-Mode Virtual Interrupts
-#define CR4_VME         0x00000001              // V86 Mode Extensions
+    uint16_t ts_t;            // trap on task switch
+    uint16_t ts_iomb;        // i/o map base address
+};
 
 #endif /* !__KERN_MM_MMU_H__ */
 
diff -urN lab2/kern/mm/pmm.c lab1/kern/mm/pmm.c
--- lab2/kern/mm/pmm.c	2019-02-26 21:54:43.932194340 +0800
+++ lab1/kern/mm/pmm.c	2019-02-28 18:26:57.000000000 +0800
@@ -1,13 +1,8 @@
 #include <defs.h>
 #include <x86.h>
-#include <stdio.h>
-#include <string.h>
 #include <mmu.h>
 #include <memlayout.h>
 #include <pmm.h>
-#include <default_pmm.h>
-#include <sync.h>
-#include <error.h>
 
 /* *
  * Task State Segment:
@@ -31,36 +26,6 @@
  * */
 static struct taskstate ts = {0};
 
-// virtual address of physicall page array
-struct Page *pages;
-// amount of physical memory (in pages)
-size_t npage = 0;
-
-// virtual address of boot-time page directory
-extern pde_t __boot_pgdir;
-pde_t *boot_pgdir = &__boot_pgdir;
-// physical address of boot-time page directory
-uintptr_t boot_cr3;
-
-// physical memory management
-const struct pmm_manager *pmm_manager;
-
-/* *
- * The page directory entry corresponding to the virtual address range
- * [VPT, VPT + PTSIZE) points to the page directory itself. Thus, the page
- * directory is treated as a page table as well as a page directory.
- *
- * One result of treating the page directory as a page table is that all PTEs
- * can be accessed though a "virtual page table" at virtual address VPT. And the
- * PTE for number n is stored in vpt[n].
- *
- * A second consequence is that the contents of the current page directory will
- * always available at virtual address PGADDR(PDX(VPT), PDX(VPT), 0), to which
- * vpd is set bellow.
- * */
-pte_t * const vpt = (pte_t *)VPT;
-pde_t * const vpd = (pde_t *)PGADDR(PDX(VPT), PDX(VPT), 0);
-
 /* *
  * Global Descriptor Table:
  *
@@ -80,17 +45,13 @@
     [SEG_KDATA] = SEG(STA_W, 0x0, 0xFFFFFFFF, DPL_KERNEL),
     [SEG_UTEXT] = SEG(STA_X | STA_R, 0x0, 0xFFFFFFFF, DPL_USER),
     [SEG_UDATA] = SEG(STA_W, 0x0, 0xFFFFFFFF, DPL_USER),
-    [SEG_TSS]   = SEG_NULL,
+    [SEG_TSS]    = SEG_NULL,
 };
 
 static struct pseudodesc gdt_pd = {
-    sizeof(gdt) - 1, (uintptr_t)gdt
+    sizeof(gdt) - 1, (uint32_t)gdt
 };
 
-static void check_alloc_page(void);
-static void check_pgdir(void);
-static void check_boot_pgdir(void);
-
 /* *
  * lgdt - load the global descriptor table register and reset the
  * data/code segement registers for kernel.
@@ -107,25 +68,21 @@
     asm volatile ("ljmp %0, $1f\n 1:\n" :: "i" (KERNEL_CS));
 }
 
-/* *
- * load_esp0 - change the ESP0 in default task state segment,
- * so that we can use different kernel stack when we trap frame
- * user to kernel.
- * */
-void
-load_esp0(uintptr_t esp0) {
-    ts.ts_esp0 = esp0;
-}
+/* temporary kernel stack */
+uint8_t stack0[1024];
 
 /* gdt_init - initialize the default GDT and TSS */
 static void
 gdt_init(void) {
-    // set boot kernel stack and default SS0
-    load_esp0((uintptr_t)bootstacktop);
+    // Setup a TSS so that we can get the right stack when we trap from
+    // user to the kernel. But not safe here, it's only a temporary value,
+    // it will be set to KSTACKTOP in lab2.
+    ts.ts_esp0 = (uint32_t)&stack0 + sizeof(stack0);
     ts.ts_ss0 = KERNEL_DS;
 
     // initialize the TSS filed of the gdt
-    gdt[SEG_TSS] = SEGTSS(STS_T32A, (uintptr_t)&ts, sizeof(ts), DPL_KERNEL);
+    gdt[SEG_TSS] = SEG16(STS_T32A, (uint32_t)&ts, sizeof(ts), DPL_KERNEL);
+    gdt[SEG_TSS].sd_s = 0;
 
     // reload all segment registers
     lgdt(&gdt_pd);
@@ -134,473 +91,9 @@
     ltr(GD_TSS);
 }
 
-//init_pmm_manager - initialize a pmm_manager instance
-static void
-init_pmm_manager(void) {
-    pmm_manager = &default_pmm_manager;
-    cprintf("memory management: %s\n", pmm_manager->name);
-    pmm_manager->init();
-}
-
-//init_memmap - call pmm->init_memmap to build Page struct for free memory  
-static void
-init_memmap(struct Page *base, size_t n) {
-    pmm_manager->init_memmap(base, n);
-}
-
-//alloc_pages - call pmm->alloc_pages to allocate a continuous n*PAGESIZE memory 
-struct Page *
-alloc_pages(size_t n) {
-    struct Page *page=NULL;
-    bool intr_flag;
-    local_intr_save(intr_flag);
-    {
-        page = pmm_manager->alloc_pages(n);
-    }
-    local_intr_restore(intr_flag);
-    return page;
-}
-
-//free_pages - call pmm->free_pages to free a continuous n*PAGESIZE memory 
-void
-free_pages(struct Page *base, size_t n) {
-    bool intr_flag;
-    local_intr_save(intr_flag);
-    {
-        pmm_manager->free_pages(base, n);
-    }
-    local_intr_restore(intr_flag);
-}
-
-//nr_free_pages - call pmm->nr_free_pages to get the size (nr*PAGESIZE) 
-//of current free memory
-size_t
-nr_free_pages(void) {
-    size_t ret;
-    bool intr_flag;
-    local_intr_save(intr_flag);
-    {
-        ret = pmm_manager->nr_free_pages();
-    }
-    local_intr_restore(intr_flag);
-    return ret;
-}
-
 /* pmm_init - initialize the physical memory management */
-static void
-page_init(void) {
-    struct e820map *memmap = (struct e820map *)(0x8000 + KERNBASE);
-    uint64_t maxpa = 0;
-
-    cprintf("e820map:\n");
-    int i;
-    for (i = 0; i < memmap->nr_map; i ++) {
-        uint64_t begin = memmap->map[i].addr, end = begin + memmap->map[i].size;
-        cprintf("  memory: %08llx, [%08llx, %08llx], type = %d.\n",
-                memmap->map[i].size, begin, end - 1, memmap->map[i].type);
-        if (memmap->map[i].type == E820_ARM) {
-            if (maxpa < end && begin < KMEMSIZE) {
-                maxpa = end;
-            }
-        }
-    }
-    if (maxpa > KMEMSIZE) {
-        maxpa = KMEMSIZE;
-    }
-
-    extern char end[];
-
-    npage = maxpa / PGSIZE;
-    pages = (struct Page *)ROUNDUP((void *)end, PGSIZE);
-
-    for (i = 0; i < npage; i ++) {
-        SetPageReserved(pages + i);
-    }
-
-    uintptr_t freemem = PADDR((uintptr_t)pages + sizeof(struct Page) * npage);
-
-    for (i = 0; i < memmap->nr_map; i ++) {
-        uint64_t begin = memmap->map[i].addr, end = begin + memmap->map[i].size;
-        if (memmap->map[i].type == E820_ARM) {
-            if (begin < freemem) {
-                begin = freemem;
-            }
-            if (end > KMEMSIZE) {
-                end = KMEMSIZE;
-            }
-            if (begin < end) {
-                begin = ROUNDUP(begin, PGSIZE);
-                end = ROUNDDOWN(end, PGSIZE);
-                if (begin < end) {
-                    init_memmap(pa2page(begin), (end - begin) / PGSIZE);
-                }
-            }
-        }
-    }
-}
-
-//boot_map_segment - setup&enable the paging mechanism
-// parameters
-//  la:   linear address of this memory need to map (after x86 segment map)
-//  size: memory size
-//  pa:   physical address of this memory
-//  perm: permission of this memory  
-static void
-boot_map_segment(pde_t *pgdir, uintptr_t la, size_t size, uintptr_t pa, uint32_t perm) {
-    assert(PGOFF(la) == PGOFF(pa));
-    size_t n = ROUNDUP(size + PGOFF(la), PGSIZE) / PGSIZE;
-    la = ROUNDDOWN(la, PGSIZE);
-    pa = ROUNDDOWN(pa, PGSIZE);
-    for (; n > 0; n --, la += PGSIZE, pa += PGSIZE) {
-        pte_t *ptep = get_pte(pgdir, la, 1);
-        assert(ptep != NULL);
-        *ptep = pa | PTE_P | perm;
-    }
-}
-
-//boot_alloc_page - allocate one page using pmm->alloc_pages(1) 
-// return value: the kernel virtual address of this allocated page
-//note: this function is used to get the memory for PDT(Page Directory Table)&PT(Page Table)
-static void *
-boot_alloc_page(void) {
-    struct Page *p = alloc_page();
-    if (p == NULL) {
-        panic("boot_alloc_page failed.\n");
-    }
-    return page2kva(p);
-}
-
-//pmm_init - setup a pmm to manage physical memory, build PDT&PT to setup paging mechanism 
-//         - check the correctness of pmm & paging mechanism, print PDT&PT
 void
 pmm_init(void) {
-    // We've already enabled paging
-    boot_cr3 = PADDR(boot_pgdir);
-
-    //We need to alloc/free the physical memory (granularity is 4KB or other size). 
-    //So a framework of physical memory manager (struct pmm_manager)is defined in pmm.h
-    //First we should init a physical memory manager(pmm) based on the framework.
-    //Then pmm can alloc/free the physical memory. 
-    //Now the first_fit/best_fit/worst_fit/buddy_system pmm are available.
-    init_pmm_manager();
-
-    // detect physical memory space, reserve already used memory,
-    // then use pmm->init_memmap to create free page list
-    page_init();
-
-    //use pmm->check to verify the correctness of the alloc/free function in a pmm
-    check_alloc_page();
-
-    check_pgdir();
-
-    static_assert(KERNBASE % PTSIZE == 0 && KERNTOP % PTSIZE == 0);
-
-    // recursively insert boot_pgdir in itself
-    // to form a virtual page table at virtual address VPT
-    boot_pgdir[PDX(VPT)] = PADDR(boot_pgdir) | PTE_P | PTE_W;
-
-    // map all physical memory to linear memory with base linear addr KERNBASE
-    // linear_addr KERNBASE ~ KERNBASE + KMEMSIZE = phy_addr 0 ~ KMEMSIZE
-    boot_map_segment(boot_pgdir, KERNBASE, KMEMSIZE, 0, PTE_W);
-
-    // Since we are using bootloader's GDT,
-    // we should reload gdt (second time, the last time) to get user segments and the TSS
-    // map virtual_addr 0 ~ 4G = linear_addr 0 ~ 4G
-    // then set kernel stack (ss:esp) in TSS, setup TSS in gdt, load TSS
     gdt_init();
-
-    //now the basic virtual memory map(see memalyout.h) is established.
-    //check the correctness of the basic virtual memory map.
-    check_boot_pgdir();
-
-    print_pgdir();
-
-}
-
-//get_pte - get pte and return the kernel virtual address of this pte for la
-//        - if the PT contians this pte didn't exist, alloc a page for PT
-// parameter:
-//  pgdir:  the kernel virtual base address of PDT
-//  la:     the linear address need to map
-//  create: a logical value to decide if alloc a page for PT
-// return vaule: the kernel virtual address of this pte
-pte_t *
-get_pte(pde_t *pgdir, uintptr_t la, bool create) {
-    /* LAB2 EXERCISE 2: YOUR CODE
-     *
-     * If you need to visit a physical address, please use KADDR()
-     * please read pmm.h for useful macros
-     *
-     * Maybe you want help comment, BELOW comments can help you finish the code
-     *
-     * Some Useful MACROs and DEFINEs, you can use them in below implementation.
-     * MACROs or Functions:
-     *   PDX(la) = the index of page directory entry of VIRTUAL ADDRESS la.
-     *   KADDR(pa) : takes a physical address and returns the corresponding kernel virtual address.
-     *   set_page_ref(page,1) : means the page be referenced by one time
-     *   page2pa(page): get the physical address of memory which this (struct Page *) page  manages
-     *   struct Page * alloc_page() : allocation a page
-     *   memset(void *s, char c, size_t n) : sets the first n bytes of the memory area pointed by s
-     *                                       to the specified value c.
-     * DEFINEs:
-     *   PTE_P           0x001                   // page table/directory entry flags bit : Present
-     *   PTE_W           0x002                   // page table/directory entry flags bit : Writeable
-     *   PTE_U           0x004                   // page table/directory entry flags bit : User can access
-     */
-#if 0
-    pde_t *pdep = NULL;   // (1) find page directory entry
-    if (0) {              // (2) check if entry is not present
-                          // (3) check if creating is needed, then alloc page for page table
-                          // CAUTION: this page is used for page table, not for common data page
-                          // (4) set page reference
-        uintptr_t pa = 0; // (5) get linear address of page
-                          // (6) clear page content using memset
-                          // (7) set page directory entry's permission
-    }
-    return NULL;          // (8) return page table entry
-#endif
-}
-
-//get_page - get related Page struct for linear address la using PDT pgdir
-struct Page *
-get_page(pde_t *pgdir, uintptr_t la, pte_t **ptep_store) {
-    pte_t *ptep = get_pte(pgdir, la, 0);
-    if (ptep_store != NULL) {
-        *ptep_store = ptep;
-    }
-    if (ptep != NULL && *ptep & PTE_P) {
-        return pte2page(*ptep);
-    }
-    return NULL;
-}
-
-//page_remove_pte - free an Page sturct which is related linear address la
-//                - and clean(invalidate) pte which is related linear address la
-//note: PT is changed, so the TLB need to be invalidate 
-static inline void
-page_remove_pte(pde_t *pgdir, uintptr_t la, pte_t *ptep) {
-    /* LAB2 EXERCISE 3: YOUR CODE
-     *
-     * Please check if ptep is valid, and tlb must be manually updated if mapping is updated
-     *
-     * Maybe you want help comment, BELOW comments can help you finish the code
-     *
-     * Some Useful MACROs and DEFINEs, you can use them in below implementation.
-     * MACROs or Functions:
-     *   struct Page *page pte2page(*ptep): get the according page from the value of a ptep
-     *   free_page : free a page
-     *   page_ref_dec(page) : decrease page->ref. NOTICE: ff page->ref == 0 , then this page should be free.
-     *   tlb_invalidate(pde_t *pgdir, uintptr_t la) : Invalidate a TLB entry, but only if the page tables being
-     *                        edited are the ones currently in use by the processor.
-     * DEFINEs:
-     *   PTE_P           0x001                   // page table/directory entry flags bit : Present
-     */
-#if 0
-    if (0) {                      //(1) check if this page table entry is present
-        struct Page *page = NULL; //(2) find corresponding page to pte
-                                  //(3) decrease page reference
-                                  //(4) and free this page when page reference reachs 0
-                                  //(5) clear second page table entry
-                                  //(6) flush tlb
-    }
-#endif
-}
-
-//page_remove - free an Page which is related linear address la and has an validated pte
-void
-page_remove(pde_t *pgdir, uintptr_t la) {
-    pte_t *ptep = get_pte(pgdir, la, 0);
-    if (ptep != NULL) {
-        page_remove_pte(pgdir, la, ptep);
-    }
-}
-
-//page_insert - build the map of phy addr of an Page with the linear addr la
-// paramemters:
-//  pgdir: the kernel virtual base address of PDT
-//  page:  the Page which need to map
-//  la:    the linear address need to map
-//  perm:  the permission of this Page which is setted in related pte
-// return value: always 0
-//note: PT is changed, so the TLB need to be invalidate 
-int
-page_insert(pde_t *pgdir, struct Page *page, uintptr_t la, uint32_t perm) {
-    pte_t *ptep = get_pte(pgdir, la, 1);
-    if (ptep == NULL) {
-        return -E_NO_MEM;
-    }
-    page_ref_inc(page);
-    if (*ptep & PTE_P) {
-        struct Page *p = pte2page(*ptep);
-        if (p == page) {
-            page_ref_dec(page);
-        }
-        else {
-            page_remove_pte(pgdir, la, ptep);
-        }
-    }
-    *ptep = page2pa(page) | PTE_P | perm;
-    tlb_invalidate(pgdir, la);
-    return 0;
-}
-
-// invalidate a TLB entry, but only if the page tables being
-// edited are the ones currently in use by the processor.
-void
-tlb_invalidate(pde_t *pgdir, uintptr_t la) {
-    if (rcr3() == PADDR(pgdir)) {
-        invlpg((void *)la);
-    }
-}
-
-static void
-check_alloc_page(void) {
-    pmm_manager->check();
-    cprintf("check_alloc_page() succeeded!\n");
-}
-
-static void
-check_pgdir(void) {
-    assert(npage <= KMEMSIZE / PGSIZE);
-    assert(boot_pgdir != NULL && (uint32_t)PGOFF(boot_pgdir) == 0);
-    assert(get_page(boot_pgdir, 0x0, NULL) == NULL);
-
-    struct Page *p1, *p2;
-    p1 = alloc_page();
-    assert(page_insert(boot_pgdir, p1, 0x0, 0) == 0);
-
-    pte_t *ptep;
-    assert((ptep = get_pte(boot_pgdir, 0x0, 0)) != NULL);
-    assert(pte2page(*ptep) == p1);
-    assert(page_ref(p1) == 1);
-
-    ptep = &((pte_t *)KADDR(PDE_ADDR(boot_pgdir[0])))[1];
-    assert(get_pte(boot_pgdir, PGSIZE, 0) == ptep);
-
-    p2 = alloc_page();
-    assert(page_insert(boot_pgdir, p2, PGSIZE, PTE_U | PTE_W) == 0);
-    assert((ptep = get_pte(boot_pgdir, PGSIZE, 0)) != NULL);
-    assert(*ptep & PTE_U);
-    assert(*ptep & PTE_W);
-    assert(boot_pgdir[0] & PTE_U);
-    assert(page_ref(p2) == 1);
-
-    assert(page_insert(boot_pgdir, p1, PGSIZE, 0) == 0);
-    assert(page_ref(p1) == 2);
-    assert(page_ref(p2) == 0);
-    assert((ptep = get_pte(boot_pgdir, PGSIZE, 0)) != NULL);
-    assert(pte2page(*ptep) == p1);
-    assert((*ptep & PTE_U) == 0);
-
-    page_remove(boot_pgdir, 0x0);
-    assert(page_ref(p1) == 1);
-    assert(page_ref(p2) == 0);
-
-    page_remove(boot_pgdir, PGSIZE);
-    assert(page_ref(p1) == 0);
-    assert(page_ref(p2) == 0);
-
-    assert(page_ref(pde2page(boot_pgdir[0])) == 1);
-    free_page(pde2page(boot_pgdir[0]));
-    boot_pgdir[0] = 0;
-
-    cprintf("check_pgdir() succeeded!\n");
-}
-
-static void
-check_boot_pgdir(void) {
-    pte_t *ptep;
-    int i;
-    for (i = 0; i < npage; i += PGSIZE) {
-        assert((ptep = get_pte(boot_pgdir, (uintptr_t)KADDR(i), 0)) != NULL);
-        assert(PTE_ADDR(*ptep) == i);
-    }
-
-    assert(PDE_ADDR(boot_pgdir[PDX(VPT)]) == PADDR(boot_pgdir));
-
-    assert(boot_pgdir[0] == 0);
-
-    struct Page *p;
-    p = alloc_page();
-    assert(page_insert(boot_pgdir, p, 0x100, PTE_W) == 0);
-    assert(page_ref(p) == 1);
-    assert(page_insert(boot_pgdir, p, 0x100 + PGSIZE, PTE_W) == 0);
-    assert(page_ref(p) == 2);
-
-    const char *str = "ucore: Hello world!!";
-    strcpy((void *)0x100, str);
-    assert(strcmp((void *)0x100, (void *)(0x100 + PGSIZE)) == 0);
-
-    *(char *)(page2kva(p) + 0x100) = '\0';
-    assert(strlen((const char *)0x100) == 0);
-
-    free_page(p);
-    free_page(pde2page(boot_pgdir[0]));
-    boot_pgdir[0] = 0;
-
-    cprintf("check_boot_pgdir() succeeded!\n");
-}
-
-//perm2str - use string 'u,r,w,-' to present the permission
-static const char *
-perm2str(int perm) {
-    static char str[4];
-    str[0] = (perm & PTE_U) ? 'u' : '-';
-    str[1] = 'r';
-    str[2] = (perm & PTE_W) ? 'w' : '-';
-    str[3] = '\0';
-    return str;
-}
-
-//get_pgtable_items - In [left, right] range of PDT or PT, find a continuous linear addr space
-//                  - (left_store*X_SIZE~right_store*X_SIZE) for PDT or PT
-//                  - X_SIZE=PTSIZE=4M, if PDT; X_SIZE=PGSIZE=4K, if PT
-// paramemters:
-//  left:        no use ???
-//  right:       the high side of table's range
-//  start:       the low side of table's range
-//  table:       the beginning addr of table
-//  left_store:  the pointer of the high side of table's next range
-//  right_store: the pointer of the low side of table's next range
-// return value: 0 - not a invalid item range, perm - a valid item range with perm permission 
-static int
-get_pgtable_items(size_t left, size_t right, size_t start, uintptr_t *table, size_t *left_store, size_t *right_store) {
-    if (start >= right) {
-        return 0;
-    }
-    while (start < right && !(table[start] & PTE_P)) {
-        start ++;
-    }
-    if (start < right) {
-        if (left_store != NULL) {
-            *left_store = start;
-        }
-        int perm = (table[start ++] & PTE_USER);
-        while (start < right && (table[start] & PTE_USER) == perm) {
-            start ++;
-        }
-        if (right_store != NULL) {
-            *right_store = start;
-        }
-        return perm;
-    }
-    return 0;
-}
-
-//print_pgdir - print the PDT&PT
-void
-print_pgdir(void) {
-    cprintf("-------------------- BEGIN --------------------\n");
-    size_t left, right = 0, perm;
-    while ((perm = get_pgtable_items(0, NPDEENTRY, right, vpd, &left, &right)) != 0) {
-        cprintf("PDE(%03x) %08x-%08x %08x %s\n", right - left,
-                left * PTSIZE, right * PTSIZE, (right - left) * PTSIZE, perm2str(perm));
-        size_t l, r = left * NPTEENTRY;
-        while ((perm = get_pgtable_items(left * NPTEENTRY, right * NPTEENTRY, r, vpt, &l, &r)) != 0) {
-            cprintf("  |-- PTE(%05x) %08x-%08x %08x %s\n", r - l,
-                    l * PGSIZE, r * PGSIZE, (r - l) * PGSIZE, perm2str(perm));
-        }
-    }
-    cprintf("--------------------- END ---------------------\n");
 }
 
diff -urN lab2/kern/mm/pmm.h lab1/kern/mm/pmm.h
--- lab2/kern/mm/pmm.h	2019-02-26 21:54:43.932194340 +0800
+++ lab1/kern/mm/pmm.h	2019-02-28 18:26:57.000000000 +0800
@@ -1,143 +1,7 @@
 #ifndef __KERN_MM_PMM_H__
 #define __KERN_MM_PMM_H__
 
-#include <defs.h>
-#include <mmu.h>
-#include <memlayout.h>
-#include <atomic.h>
-#include <assert.h>
-
-// pmm_manager is a physical memory management class. A special pmm manager - XXX_pmm_manager
-// only needs to implement the methods in pmm_manager class, then XXX_pmm_manager can be used
-// by ucore to manage the total physical memory space.
-struct pmm_manager {
-    const char *name;                                 // XXX_pmm_manager's name
-    void (*init)(void);                               // initialize internal description&management data structure
-                                                      // (free block list, number of free block) of XXX_pmm_manager 
-    void (*init_memmap)(struct Page *base, size_t n); // setup description&management data structcure according to
-                                                      // the initial free physical memory space 
-    struct Page *(*alloc_pages)(size_t n);            // allocate >=n pages, depend on the allocation algorithm 
-    void (*free_pages)(struct Page *base, size_t n);  // free >=n pages with "base" addr of Page descriptor structures(memlayout.h)
-    size_t (*nr_free_pages)(void);                    // return the number of free pages 
-    void (*check)(void);                              // check the correctness of XXX_pmm_manager 
-};
-
-extern const struct pmm_manager *pmm_manager;
-extern pde_t *boot_pgdir;
-extern uintptr_t boot_cr3;
-
 void pmm_init(void);
 
-struct Page *alloc_pages(size_t n);
-void free_pages(struct Page *base, size_t n);
-size_t nr_free_pages(void);
-
-#define alloc_page() alloc_pages(1)
-#define free_page(page) free_pages(page, 1)
-
-pte_t *get_pte(pde_t *pgdir, uintptr_t la, bool create);
-struct Page *get_page(pde_t *pgdir, uintptr_t la, pte_t **ptep_store);
-void page_remove(pde_t *pgdir, uintptr_t la);
-int page_insert(pde_t *pgdir, struct Page *page, uintptr_t la, uint32_t perm);
-
-void load_esp0(uintptr_t esp0);
-void tlb_invalidate(pde_t *pgdir, uintptr_t la);
-
-void print_pgdir(void);
-
-/* *
- * PADDR - takes a kernel virtual address (an address that points above KERNBASE),
- * where the machine's maximum 256MB of physical memory is mapped and returns the
- * corresponding physical address.  It panics if you pass it a non-kernel virtual address.
- * */
-#define PADDR(kva) ({                                                   \
-            uintptr_t __m_kva = (uintptr_t)(kva);                       \
-            if (__m_kva < KERNBASE) {                                   \
-                panic("PADDR called with invalid kva %08lx", __m_kva);  \
-            }                                                           \
-            __m_kva - KERNBASE;                                         \
-        })
-
-/* *
- * KADDR - takes a physical address and returns the corresponding kernel virtual
- * address. It panics if you pass an invalid physical address.
- * */
-#define KADDR(pa) ({                                                    \
-            uintptr_t __m_pa = (pa);                                    \
-            size_t __m_ppn = PPN(__m_pa);                               \
-            if (__m_ppn >= npage) {                                     \
-                panic("KADDR called with invalid pa %08lx", __m_pa);    \
-            }                                                           \
-            (void *) (__m_pa + KERNBASE);                               \
-        })
-
-extern struct Page *pages;
-extern size_t npage;
-
-static inline ppn_t
-page2ppn(struct Page *page) {
-    return page - pages;
-}
-
-static inline uintptr_t
-page2pa(struct Page *page) {
-    return page2ppn(page) << PGSHIFT;
-}
-
-static inline struct Page *
-pa2page(uintptr_t pa) {
-    if (PPN(pa) >= npage) {
-        panic("pa2page called with invalid pa");
-    }
-    return &pages[PPN(pa)];
-}
-
-static inline void *
-page2kva(struct Page *page) {
-    return KADDR(page2pa(page));
-}
-
-static inline struct Page *
-kva2page(void *kva) {
-    return pa2page(PADDR(kva));
-}
-
-static inline struct Page *
-pte2page(pte_t pte) {
-    if (!(pte & PTE_P)) {
-        panic("pte2page called with invalid pte");
-    }
-    return pa2page(PTE_ADDR(pte));
-}
-
-static inline struct Page *
-pde2page(pde_t pde) {
-    return pa2page(PDE_ADDR(pde));
-}
-
-static inline int
-page_ref(struct Page *page) {
-    return page->ref;
-}
-
-static inline void
-set_page_ref(struct Page *page, int val) {
-    page->ref = val;
-}
-
-static inline int
-page_ref_inc(struct Page *page) {
-    page->ref += 1;
-    return page->ref;
-}
-
-static inline int
-page_ref_dec(struct Page *page) {
-    page->ref -= 1;
-    return page->ref;
-}
-
-extern char bootstack[], bootstacktop[];
-
 #endif /* !__KERN_MM_PMM_H__ */
 
diff -urN lab2/kern/sync/sync.h lab1/kern/sync/sync.h
--- lab2/kern/sync/sync.h	2019-02-26 21:54:43.932194340 +0800
+++ lab1/kern/sync/sync.h	1970-01-01 08:00:00.000000000 +0800
@@ -1,28 +0,0 @@
-#ifndef __KERN_SYNC_SYNC_H__
-#define __KERN_SYNC_SYNC_H__
-
-#include <x86.h>
-#include <intr.h>
-#include <mmu.h>
-
-static inline bool
-__intr_save(void) {
-    if (read_eflags() & FL_IF) {
-        intr_disable();
-        return 1;
-    }
-    return 0;
-}
-
-static inline void
-__intr_restore(bool flag) {
-    if (flag) {
-        intr_enable();
-    }
-}
-
-#define local_intr_save(x)      do { x = __intr_save(); } while (0)
-#define local_intr_restore(x)   __intr_restore(x);
-
-#endif /* !__KERN_SYNC_SYNC_H__ */
-
diff -urN lab2/kern/trap/trap.c lab1/kern/trap/trap.c
--- lab2/kern/trap/trap.c	2019-02-26 21:54:43.932194340 +0800
+++ lab1/kern/trap/trap.c	2019-03-09 17:56:31.303374797 +0800
@@ -10,6 +10,7 @@
 #include <kdebug.h>
 
 #define TICK_NUM 100
+int cur_tick = 0;
 
 static void print_ticks() {
     cprintf("%d ticks\n",TICK_NUM);
@@ -46,6 +47,27 @@
       *     You don't know the meaning of this instruction? just google it! and check the libs/x86.h to know more.
       *     Notice: the argument of lidt is idt_pd. try to find it!
       */
+
+	extern uintptr_t __vectors[];	
+	/* *
+	 * Set up a normal interrupt/trap gate descriptor
+	 *   - istrap: 1 for a trap (= exception) gate, 0 for an interrupt gate
+	 *   - sel: Code segment selector for interrupt/trap handler
+	 *   - off: Offset in code segment for interrupt/trap handler
+	 *   - dpl: Descriptor Privilege Level - the privilege level required
+	 *          for software to invoke this interrupt/trap gate explicitly
+	 *          using an int instruction.
+	 * */
+	//	SETGATE(gate, istrap, sel, off, dpl)
+	int i = 0;
+	for(i = 0;i < 256;i++ ){
+		int dpl = DPL_KERNEL;
+		if(i == T_SYSCALL || i == T_SWITCH_TOK){
+			dpl = DPL_USER;
+		}
+		SETGATE(idt[i],0,KERNEL_CS,__vectors[i],dpl);
+	}
+	asm ("lidt %0\n"::"m"(idt_pd));
 }
 
 static const char *
@@ -147,6 +169,10 @@
          * (2) Every TICK_NUM cycle, you can print some info using a funciton, such as print_ticks().
          * (3) Too Simple? Yes, I think so!
          */
+		cur_tick++;
+		if(cur_tick % TICK_NUM == 0){
+				print_ticks();
+		}
         break;
     case IRQ_OFFSET + IRQ_COM1:
         c = cons_getc();
diff -urN lab2/kern/trap/trap.h lab1/kern/trap/trap.h
--- lab2/kern/trap/trap.h	2019-02-26 21:54:43.932194340 +0800
+++ lab1/kern/trap/trap.h	2019-02-28 18:26:57.000000000 +0800
@@ -6,39 +6,39 @@
 /* Trap Numbers */
 
 /* Processor-defined: */
-#define T_DIVIDE                0   // divide error
-#define T_DEBUG                 1   // debug exception
-#define T_NMI                   2   // non-maskable interrupt
-#define T_BRKPT                 3   // breakpoint
-#define T_OFLOW                 4   // overflow
-#define T_BOUND                 5   // bounds check
-#define T_ILLOP                 6   // illegal opcode
-#define T_DEVICE                7   // device not available
-#define T_DBLFLT                8   // double fault
-// #define T_COPROC             9   // reserved (not used since 486)
-#define T_TSS                   10  // invalid task switch segment
-#define T_SEGNP                 11  // segment not present
-#define T_STACK                 12  // stack exception
-#define T_GPFLT                 13  // general protection fault
-#define T_PGFLT                 14  // page fault
-// #define T_RES                15  // reserved
-#define T_FPERR                 16  // floating point error
-#define T_ALIGN                 17  // aligment check
-#define T_MCHK                  18  // machine check
-#define T_SIMDERR               19  // SIMD floating point error
+#define T_DIVIDE                0    // divide error
+#define T_DEBUG                    1    // debug exception
+#define T_NMI                    2    // non-maskable interrupt
+#define T_BRKPT                    3    // breakpoint
+#define T_OFLOW                    4    // overflow
+#define T_BOUND                    5    // bounds check
+#define T_ILLOP                    6    // illegal opcode
+#define T_DEVICE                7    // device not available
+#define T_DBLFLT                8    // double fault
+// #define T_COPROC                9    // reserved (not used since 486)
+#define T_TSS                    10    // invalid task switch segment
+#define T_SEGNP                    11    // segment not present
+#define T_STACK                    12    // stack exception
+#define T_GPFLT                    13    // general protection fault
+#define T_PGFLT                    14    // page fault
+// #define T_RES                15    // reserved
+#define T_FPERR                    16    // floating point error
+#define T_ALIGN                    17    // aligment check
+#define T_MCHK                    18    // machine check
+#define T_SIMDERR                19    // SIMD floating point error
 
 #define T_SYSCALL               0x80 // SYSCALL, ONLY FOR THIS PROJ
 
 /* Hardware IRQ numbers. We receive these as (IRQ_OFFSET + IRQ_xx) */
-#define IRQ_OFFSET              32  // IRQ 0 corresponds to int IRQ_OFFSET
+#define IRQ_OFFSET                32    // IRQ 0 corresponds to int IRQ_OFFSET
 
-#define IRQ_TIMER               0
-#define IRQ_KBD                 1
+#define IRQ_TIMER                0
+#define IRQ_KBD                    1
 #define IRQ_COM1                4
 #define IRQ_IDE1                14
 #define IRQ_IDE2                15
-#define IRQ_ERROR               19
-#define IRQ_SPURIOUS            31
+#define IRQ_ERROR                19
+#define IRQ_SPURIOUS                31
 
 /* *
  * These are arbitrarily chosen, but with care not to overlap
@@ -52,7 +52,7 @@
     uint32_t reg_edi;
     uint32_t reg_esi;
     uint32_t reg_ebp;
-    uint32_t reg_oesp;          /* Useless */
+    uint32_t reg_oesp;            /* Useless */
     uint32_t reg_ebx;
     uint32_t reg_edx;
     uint32_t reg_ecx;
Binary files lab2/lab1_under.udb and lab1/lab1_under.udb differ
diff -urN lab2/libs/atomic.h lab1/libs/atomic.h
--- lab2/libs/atomic.h	2019-02-26 21:54:43.932194340 +0800
+++ lab1/libs/atomic.h	1970-01-01 08:00:00.000000000 +0800
@@ -1,57 +0,0 @@
-#ifndef __LIBS_ATOMIC_H__
-#define __LIBS_ATOMIC_H__
-
-/* Atomic operations that C can't guarantee us. Useful for resource counting etc.. */
-
-static inline void set_bit(int nr, volatile void *addr) __attribute__((always_inline));
-static inline void clear_bit(int nr, volatile void *addr) __attribute__((always_inline));
-static inline void change_bit(int nr, volatile void *addr) __attribute__((always_inline));
-static inline bool test_bit(int nr, volatile void *addr) __attribute__((always_inline));
-
-/* *
- * set_bit - Atomically set a bit in memory
- * @nr:     the bit to set
- * @addr:   the address to start counting from
- *
- * Note that @nr may be almost arbitrarily large; this function is not
- * restricted to acting on a single-word quantity.
- * */
-static inline void
-set_bit(int nr, volatile void *addr) {
-    asm volatile ("btsl %1, %0" :"=m" (*(volatile long *)addr) : "Ir" (nr));
-}
-
-/* *
- * clear_bit - Atomically clears a bit in memory
- * @nr:     the bit to clear
- * @addr:   the address to start counting from
- * */
-static inline void
-clear_bit(int nr, volatile void *addr) {
-    asm volatile ("btrl %1, %0" :"=m" (*(volatile long *)addr) : "Ir" (nr));
-}
-
-/* *
- * change_bit - Atomically toggle a bit in memory
- * @nr:     the bit to change
- * @addr:   the address to start counting from
- * */
-static inline void
-change_bit(int nr, volatile void *addr) {
-    asm volatile ("btcl %1, %0" :"=m" (*(volatile long *)addr) : "Ir" (nr));
-}
-
-/* *
- * test_bit - Determine whether a bit is set
- * @nr:     the bit to test
- * @addr:   the address to count from
- * */
-static inline bool
-test_bit(int nr, volatile void *addr) {
-    int oldbit;
-    asm volatile ("btl %2, %1; sbbl %0,%0" : "=r" (oldbit) : "m" (*(volatile long *)addr), "Ir" (nr));
-    return oldbit != 0;
-}
-
-#endif /* !__LIBS_ATOMIC_H__ */
-
diff -urN lab2/libs/elf.h lab1/libs/elf.h
--- lab2/libs/elf.h	2019-02-26 21:54:43.932194340 +0800
+++ lab1/libs/elf.h	2019-02-28 18:26:57.000000000 +0800
@@ -3,7 +3,7 @@
 
 #include <defs.h>
 
-#define ELF_MAGIC   0x464C457FU         // "\x7FELF" in little endian
+#define ELF_MAGIC    0x464C457FU            // "\x7FELF" in little endian
 
 /* file header */
 struct elfhdr {
diff -urN lab2/libs/error.h lab1/libs/error.h
--- lab2/libs/error.h	2019-02-26 21:54:43.932194340 +0800
+++ lab1/libs/error.h	2019-02-28 18:26:57.000000000 +0800
@@ -2,12 +2,12 @@
 #define __LIBS_ERROR_H__
 
 /* kernel error codes -- keep in sync with list in lib/printfmt.c */
-#define E_UNSPECIFIED       1   // Unspecified or unknown problem
-#define E_BAD_PROC          2   // Process doesn't exist or otherwise
-#define E_INVAL             3   // Invalid parameter
-#define E_NO_MEM            4   // Request failed due to memory shortage
-#define E_NO_FREE_PROC      5   // Attempt to create a new process beyond
-#define E_FAULT             6   // Memory fault
+#define E_UNSPECIFIED        1    // Unspecified or unknown problem
+#define E_BAD_PROC            2    // Process doesn't exist or otherwise
+#define E_INVAL                3    // Invalid parameter
+#define E_NO_MEM            4    // Request failed due to memory shortage
+#define E_NO_FREE_PROC        5    // Attempt to create a new process beyond
+#define E_FAULT                6    // Memory fault
 
 /* the maximum allowed */
 #define MAXERROR            6
diff -urN lab2/libs/list.h lab1/libs/list.h
--- lab2/libs/list.h	2019-02-26 21:54:43.932194340 +0800
+++ lab1/libs/list.h	1970-01-01 08:00:00.000000000 +0800
@@ -1,163 +0,0 @@
-#ifndef __LIBS_LIST_H__
-#define __LIBS_LIST_H__
-
-#ifndef __ASSEMBLER__
-
-#include <defs.h>
-
-/* *
- * Simple doubly linked list implementation.
- *
- * Some of the internal functions ("__xxx") are useful when manipulating
- * whole lists rather than single entries, as sometimes we already know
- * the next/prev entries and we can generate better code by using them
- * directly rather than using the generic single-entry routines.
- * */
-
-struct list_entry {
-    struct list_entry *prev, *next;
-};
-
-typedef struct list_entry list_entry_t;
-
-static inline void list_init(list_entry_t *elm) __attribute__((always_inline));
-static inline void list_add(list_entry_t *listelm, list_entry_t *elm) __attribute__((always_inline));
-static inline void list_add_before(list_entry_t *listelm, list_entry_t *elm) __attribute__((always_inline));
-static inline void list_add_after(list_entry_t *listelm, list_entry_t *elm) __attribute__((always_inline));
-static inline void list_del(list_entry_t *listelm) __attribute__((always_inline));
-static inline void list_del_init(list_entry_t *listelm) __attribute__((always_inline));
-static inline bool list_empty(list_entry_t *list) __attribute__((always_inline));
-static inline list_entry_t *list_next(list_entry_t *listelm) __attribute__((always_inline));
-static inline list_entry_t *list_prev(list_entry_t *listelm) __attribute__((always_inline));
-
-static inline void __list_add(list_entry_t *elm, list_entry_t *prev, list_entry_t *next) __attribute__((always_inline));
-static inline void __list_del(list_entry_t *prev, list_entry_t *next) __attribute__((always_inline));
-
-/* *
- * list_init - initialize a new entry
- * @elm:        new entry to be initialized
- * */
-static inline void
-list_init(list_entry_t *elm) {
-    elm->prev = elm->next = elm;
-}
-
-/* *
- * list_add - add a new entry
- * @listelm:    list head to add after
- * @elm:        new entry to be added
- *
- * Insert the new element @elm *after* the element @listelm which
- * is already in the list.
- * */
-static inline void
-list_add(list_entry_t *listelm, list_entry_t *elm) {
-    list_add_after(listelm, elm);
-}
-
-/* *
- * list_add_before - add a new entry
- * @listelm:    list head to add before
- * @elm:        new entry to be added
- *
- * Insert the new element @elm *before* the element @listelm which
- * is already in the list.
- * */
-static inline void
-list_add_before(list_entry_t *listelm, list_entry_t *elm) {
-    __list_add(elm, listelm->prev, listelm);
-}
-
-/* *
- * list_add_after - add a new entry
- * @listelm:    list head to add after
- * @elm:        new entry to be added
- *
- * Insert the new element @elm *after* the element @listelm which
- * is already in the list.
- * */
-static inline void
-list_add_after(list_entry_t *listelm, list_entry_t *elm) {
-    __list_add(elm, listelm, listelm->next);
-}
-
-/* *
- * list_del - deletes entry from list
- * @listelm:    the element to delete from the list
- *
- * Note: list_empty() on @listelm does not return true after this, the entry is
- * in an undefined state.
- * */
-static inline void
-list_del(list_entry_t *listelm) {
-    __list_del(listelm->prev, listelm->next);
-}
-
-/* *
- * list_del_init - deletes entry from list and reinitialize it.
- * @listelm:    the element to delete from the list.
- *
- * Note: list_empty() on @listelm returns true after this.
- * */
-static inline void
-list_del_init(list_entry_t *listelm) {
-    list_del(listelm);
-    list_init(listelm);
-}
-
-/* *
- * list_empty - tests whether a list is empty
- * @list:       the list to test.
- * */
-static inline bool
-list_empty(list_entry_t *list) {
-    return list->next == list;
-}
-
-/* *
- * list_next - get the next entry
- * @listelm:    the list head
- **/
-static inline list_entry_t *
-list_next(list_entry_t *listelm) {
-    return listelm->next;
-}
-
-/* *
- * list_prev - get the previous entry
- * @listelm:    the list head
- **/
-static inline list_entry_t *
-list_prev(list_entry_t *listelm) {
-    return listelm->prev;
-}
-
-/* *
- * Insert a new entry between two known consecutive entries.
- *
- * This is only for internal list manipulation where we know
- * the prev/next entries already!
- * */
-static inline void
-__list_add(list_entry_t *elm, list_entry_t *prev, list_entry_t *next) {
-    prev->next = next->prev = elm;
-    elm->next = next;
-    elm->prev = prev;
-}
-
-/* *
- * Delete a list entry by making the prev/next entries point to each other.
- *
- * This is only for internal list manipulation where we know
- * the prev/next entries already!
- * */
-static inline void
-__list_del(list_entry_t *prev, list_entry_t *next) {
-    prev->next = next;
-    next->prev = prev;
-}
-
-#endif /* !__ASSEMBLER__ */
-
-#endif /* !__LIBS_LIST_H__ */
-
diff -urN lab2/libs/printfmt.c lab1/libs/printfmt.c
--- lab2/libs/printfmt.c	2019-02-26 21:54:43.932194340 +0800
+++ lab1/libs/printfmt.c	2019-02-28 18:26:57.000000000 +0800
@@ -15,23 +15,23 @@
  * */
 
 static const char * const error_string[MAXERROR + 1] = {
-    [0]                     NULL,
-    [E_UNSPECIFIED]         "unspecified error",
+    [0]                        NULL,
+    [E_UNSPECIFIED]            "unspecified error",
     [E_BAD_PROC]            "bad process",
-    [E_INVAL]               "invalid parameter",
-    [E_NO_MEM]              "out of memory",
+    [E_INVAL]                "invalid parameter",
+    [E_NO_MEM]                "out of memory",
     [E_NO_FREE_PROC]        "out of processes",
-    [E_FAULT]               "segmentation fault",
+    [E_FAULT]                "segmentation fault",
 };
 
 /* *
  * printnum - print a number (base <= 16) in reverse order
- * @putch:      specified putch function, print a single character
- * @putdat:     used by @putch function
+ * @putch:        specified putch function, print a single character
+ * @putdat:        used by @putch function
  * @num:        the number will be printed
- * @base:       base for print, must be in [1, 16]
- * @width:      maximum number of digits, if the actual width is less than @width, use @padc instead
- * @padc:       character that padded on the left if the actual width is less than @width
+ * @base:        base for print, must be in [1, 16]
+ * @width:         maximum number of digits, if the actual width is less than @width, use @padc instead
+ * @padc:        character that padded on the left if the actual width is less than @width
  * */
 static void
 printnum(void (*putch)(int, void*), void *putdat,
@@ -53,8 +53,8 @@
 
 /* *
  * getuint - get an unsigned int of various possible sizes from a varargs list
- * @ap:         a varargs list pointer
- * @lflag:      determines the size of the vararg that @ap points to
+ * @ap:            a varargs list pointer
+ * @lflag:        determines the size of the vararg that @ap points to
  * */
 static unsigned long long
 getuint(va_list *ap, int lflag) {
@@ -71,8 +71,8 @@
 
 /* *
  * getint - same as getuint but signed, we can't use getuint because of sign extension
- * @ap:         a varargs list pointer
- * @lflag:      determines the size of the vararg that @ap points to
+ * @ap:            a varargs list pointer
+ * @lflag:        determines the size of the vararg that @ap points to
  * */
 static long long
 getint(va_list *ap, int lflag) {
@@ -89,8 +89,8 @@
 
 /* *
  * printfmt - format a string and print it by using putch
- * @putch:      specified putch function, print a single character
- * @putdat:     used by @putch function
+ * @putch:        specified putch function, print a single character
+ * @putdat:        used by @putch function
  * @fmt:        the format string to use
  * */
 void
@@ -105,10 +105,10 @@
 /* *
  * vprintfmt - format a string and print it by using putch, it's called with a va_list
  * instead of a variable number of arguments
- * @putch:      specified putch function, print a single character
- * @putdat:     used by @putch function
+ * @putch:        specified putch function, print a single character
+ * @putdat:        used by @putch function
  * @fmt:        the format string to use
- * @ap:         arguments for the format string
+ * @ap:            arguments for the format string
  *
  * Call this function if you are already dealing with a va_list.
  * Or you probably want printfmt() instead.
@@ -277,15 +277,15 @@
 
 /* sprintbuf is used to save enough information of a buffer */
 struct sprintbuf {
-    char *buf;          // address pointer points to the first unused memory
-    char *ebuf;         // points the end of the buffer
+    char *buf;            // address pointer points to the first unused memory
+    char *ebuf;            // points the end of the buffer
     int cnt;            // the number of characters that have been placed in this buffer
 };
 
 /* *
  * sprintputch - 'print' a single character in a buffer
- * @ch:         the character will be printed
- * @b:          the buffer to place the character @ch
+ * @ch:            the character will be printed
+ * @b:            the buffer to place the character @ch
  * */
 static void
 sprintputch(int ch, struct sprintbuf *b) {
@@ -298,7 +298,7 @@
 /* *
  * snprintf - format a string and place it in a buffer
  * @str:        the buffer to place the result into
- * @size:       the size of buffer, including the trailing null space
+ * @size:        the size of buffer, including the trailing null space
  * @fmt:        the format string to use
  * */
 int
@@ -315,9 +315,9 @@
  * vsnprintf - format a string and place it in a buffer, it's called with a va_list
  * instead of a variable number of arguments
  * @str:        the buffer to place the result into
- * @size:       the size of buffer, including the trailing null space
+ * @size:        the size of buffer, including the trailing null space
  * @fmt:        the format string to use
- * @ap:         arguments for the format string
+ * @ap:            arguments for the format string
  *
  * The return value is the number of characters which would be generated for the
  * given input, excluding the trailing '\0'.
diff -urN lab2/libs/string.c lab1/libs/string.c
--- lab2/libs/string.c	2019-02-26 21:54:43.932194340 +0800
+++ lab1/libs/string.c	2019-02-28 18:26:57.000000000 +0800
@@ -4,7 +4,7 @@
 /* *
  * strlen - calculate the length of the string @s, not including
  * the terminating '\0' character.
- * @s:      the input string
+ * @s:        the input string
  *
  * The strlen() function returns the length of string @s.
  * */
@@ -20,7 +20,7 @@
 /* *
  * strnlen - calculate the length of the string @s, not including
  * the terminating '\0' char acter, but at most @len.
- * @s:      the input string
+ * @s:        the input string
  * @len:    the max-length that function will scan
  *
  * Note that, this function looks only at the first @len characters
@@ -87,8 +87,8 @@
 
 /* *
  * strcmp - compares the string @s1 and @s2
- * @s1:     string to be compared
- * @s2:     string to be compared
+ * @s1:        string to be compared
+ * @s2:        string to be compared
  *
  * This function starts comparing the first character of each string. If
  * they are equal to each other, it continues with the following pairs until
@@ -114,9 +114,9 @@
 
 /* *
  * strncmp - compares up to @n characters of the string @s1 to those of the string @s2
- * @s1:     string to be compared
- * @s2:     string to be compared
- * @n:      maximum number of characters to compare
+ * @s1:        string to be compared
+ * @s2:        string to be compared
+ * @n:        maximum number of characters to compare
  *
  * This function starts comparing the first character of each string. If
  * they are equal to each other, it continues with the following pairs until
@@ -133,8 +133,8 @@
 
 /* *
  * strchr - locates first occurrence of character in string
- * @s:      the input string
- * @c:      character to be located
+ * @s:        the input string
+ * @c:        character to be located
  *
  * The strchr() function returns a pointer to the first occurrence of
  * character in @s. If the value is not found, the function returns 'NULL'.
@@ -152,8 +152,8 @@
 
 /* *
  * strfind - locates first occurrence of character in string
- * @s:      the input string
- * @c:      character to be located
+ * @s:        the input string
+ * @c:        character to be located
  *
  * The strfind() function is like strchr() except that if @c is
  * not found in @s, then it returns a pointer to the null byte at the
@@ -172,11 +172,11 @@
 
 /* *
  * strtol - converts string to long integer
- * @s:      the input string that contains the representation of an integer number
- * @endptr: reference to an object of type char *, whose value is set by the
- *          function to the next character in @s after the numerical value. This
- *          parameter can also be a null pointer, in which case it is not used.
- * @base:   x
+ * @s:        the input string that contains the representation of an integer number
+ * @endptr:    reference to an object of type char *, whose value is set by the
+ *             function to the next character in @s after the numerical value. This
+ *             parameter can also be a null pointer, in which case it is not used.
+ * @base:    x
  *
  * The function first discards as many whitespace characters as necessary until
  * the first non-whitespace character is found. Then, starting from this character,
@@ -261,9 +261,9 @@
 /* *
  * memset - sets the first @n bytes of the memory area pointed by @s
  * to the specified value @c.
- * @s:      pointer the the memory area to fill
- * @c:      value to set
- * @n:      number of bytes to be set to the value
+ * @s:        pointer the the memory area to fill
+ * @c:        value to set
+ * @n:        number of bytes to be set to the value
  *
  * The memset() function returns @s.
  * */
@@ -283,9 +283,9 @@
 /* *
  * memmove - copies the values of @n bytes from the location pointed by @src to
  * the memory area pointed by @dst. @src and @dst are allowed to overlap.
- * @dst     pointer to the destination array where the content is to be copied
- * @src     pointer to the source of data to by copied
- * @n:      number of bytes to copy
+ * @dst        pointer to the destination array where the content is to be copied
+ * @src        pointer to the source of data to by copied
+ * @n:        number of bytes to copy
  *
  * The memmove() function returns @dst.
  * */
@@ -313,9 +313,9 @@
 /* *
  * memcpy - copies the value of @n bytes from the location pointed by @src to
  * the memory area pointed by @dst.
- * @dst     pointer to the destination array where the content is to be copied
- * @src     pointer to the source of data to by copied
- * @n:      number of bytes to copy
+ * @dst        pointer to the destination array where the content is to be copied
+ * @src        pointer to the source of data to by copied
+ * @n:        number of bytes to copy
  *
  * The memcpy() returns @dst.
  *
@@ -340,9 +340,9 @@
 
 /* *
  * memcmp - compares two blocks of memory
- * @v1:     pointer to block of memory
- * @v2:     pointer to block of memory
- * @n:      number of bytes to compare
+ * @v1:        pointer to block of memory
+ * @v2:        pointer to block of memory
+ * @n:        number of bytes to compare
  *
  * The memcmp() functions returns an integral value indicating the
  * relationship between the content of the memory blocks:
diff -urN lab2/libs/x86.h lab1/libs/x86.h
--- lab2/libs/x86.h	2019-02-26 21:54:43.932194340 +0800
+++ lab1/libs/x86.h	2019-02-28 18:26:57.000000000 +0800
@@ -3,88 +3,63 @@
 
 #include <defs.h>
 
-#define do_div(n, base) ({                                          \
-            unsigned long __upper, __low, __high, __mod, __base;    \
-            __base = (base);                                        \
-            asm ("" : "=a" (__low), "=d" (__high) : "A" (n));       \
-            __upper = __high;                                       \
-            if (__high != 0) {                                      \
-                __upper = __high % __base;                          \
-                __high = __high / __base;                           \
-            }                                                       \
-            asm ("divl %2" : "=a" (__low), "=d" (__mod)             \
-                : "rm" (__base), "0" (__low), "1" (__upper));       \
-            asm ("" : "=A" (n) : "a" (__low), "d" (__high));        \
-            __mod;                                                  \
-        })
-
-#define barrier() __asm__ __volatile__ ("" ::: "memory")
+#define do_div(n, base) ({                                        \
+    unsigned long __upper, __low, __high, __mod, __base;        \
+    __base = (base);                                            \
+    asm("" : "=a" (__low), "=d" (__high) : "A" (n));            \
+    __upper = __high;                                            \
+    if (__high != 0) {                                            \
+        __upper = __high % __base;                                \
+        __high = __high / __base;                                \
+    }                                                            \
+    asm("divl %2" : "=a" (__low), "=d" (__mod)                    \
+        : "rm" (__base), "0" (__low), "1" (__upper));            \
+    asm("" : "=A" (n) : "a" (__low), "d" (__high));                \
+    __mod;                                                        \
+ })
 
 static inline uint8_t inb(uint16_t port) __attribute__((always_inline));
 static inline void insl(uint32_t port, void *addr, int cnt) __attribute__((always_inline));
 static inline void outb(uint16_t port, uint8_t data) __attribute__((always_inline));
 static inline void outw(uint16_t port, uint16_t data) __attribute__((always_inline));
-static inline void outsl(uint32_t port, const void *addr, int cnt) __attribute__((always_inline));
 static inline uint32_t read_ebp(void) __attribute__((always_inline));
-static inline void breakpoint(void) __attribute__((always_inline));
-static inline uint32_t read_dr(unsigned regnum) __attribute__((always_inline));
-static inline void write_dr(unsigned regnum, uint32_t value) __attribute__((always_inline));
 
 /* Pseudo-descriptors used for LGDT, LLDT(not used) and LIDT instructions. */
 struct pseudodesc {
     uint16_t pd_lim;        // Limit
-    uintptr_t pd_base;      // Base address
+    uint32_t pd_base;        // Base address
 } __attribute__ ((packed));
 
 static inline void lidt(struct pseudodesc *pd) __attribute__((always_inline));
 static inline void sti(void) __attribute__((always_inline));
 static inline void cli(void) __attribute__((always_inline));
 static inline void ltr(uint16_t sel) __attribute__((always_inline));
-static inline uint32_t read_eflags(void) __attribute__((always_inline));
-static inline void write_eflags(uint32_t eflags) __attribute__((always_inline));
-static inline void lcr0(uintptr_t cr0) __attribute__((always_inline));
-static inline void lcr3(uintptr_t cr3) __attribute__((always_inline));
-static inline uintptr_t rcr0(void) __attribute__((always_inline));
-static inline uintptr_t rcr1(void) __attribute__((always_inline));
-static inline uintptr_t rcr2(void) __attribute__((always_inline));
-static inline uintptr_t rcr3(void) __attribute__((always_inline));
-static inline void invlpg(void *addr) __attribute__((always_inline));
 
 static inline uint8_t
 inb(uint16_t port) {
     uint8_t data;
-    asm volatile ("inb %1, %0" : "=a" (data) : "d" (port) : "memory");
+    asm volatile ("inb %1, %0" : "=a" (data) : "d" (port));
     return data;
 }
 
 static inline void
 insl(uint32_t port, void *addr, int cnt) {
     asm volatile (
-        "cld;"
-        "repne; insl;"
-        : "=D" (addr), "=c" (cnt)
-        : "d" (port), "0" (addr), "1" (cnt)
-        : "memory", "cc");
+            "cld;"
+            "repne; insl;"
+            : "=D" (addr), "=c" (cnt)
+            : "d" (port), "0" (addr), "1" (cnt)
+            : "memory", "cc");
 }
 
 static inline void
 outb(uint16_t port, uint8_t data) {
-    asm volatile ("outb %0, %1" :: "a" (data), "d" (port) : "memory");
+    asm volatile ("outb %0, %1" :: "a" (data), "d" (port));
 }
 
 static inline void
 outw(uint16_t port, uint16_t data) {
-    asm volatile ("outw %0, %1" :: "a" (data), "d" (port) : "memory");
-}
-
-static inline void
-outsl(uint32_t port, const void *addr, int cnt) {
-    asm volatile (
-        "cld;"
-        "repne; outsl;"
-        : "=S" (addr), "=c" (cnt)
-        : "d" (port), "0" (addr), "1" (cnt)
-        : "memory", "cc");
+    asm volatile ("outw %0, %1" :: "a" (data), "d" (port));
 }
 
 static inline uint32_t
@@ -95,39 +70,8 @@
 }
 
 static inline void
-breakpoint(void) {
-    asm volatile ("int $3");
-}
-
-static inline uint32_t
-read_dr(unsigned regnum) {
-    uint32_t value = 0;
-    switch (regnum) {
-    case 0: asm volatile ("movl %%db0, %0" : "=r" (value)); break;
-    case 1: asm volatile ("movl %%db1, %0" : "=r" (value)); break;
-    case 2: asm volatile ("movl %%db2, %0" : "=r" (value)); break;
-    case 3: asm volatile ("movl %%db3, %0" : "=r" (value)); break;
-    case 6: asm volatile ("movl %%db6, %0" : "=r" (value)); break;
-    case 7: asm volatile ("movl %%db7, %0" : "=r" (value)); break;
-    }
-    return value;
-}
-
-static void
-write_dr(unsigned regnum, uint32_t value) {
-    switch (regnum) {
-    case 0: asm volatile ("movl %0, %%db0" :: "r" (value)); break;
-    case 1: asm volatile ("movl %0, %%db1" :: "r" (value)); break;
-    case 2: asm volatile ("movl %0, %%db2" :: "r" (value)); break;
-    case 3: asm volatile ("movl %0, %%db3" :: "r" (value)); break;
-    case 6: asm volatile ("movl %0, %%db6" :: "r" (value)); break;
-    case 7: asm volatile ("movl %0, %%db7" :: "r" (value)); break;
-    }
-}
-
-static inline void
 lidt(struct pseudodesc *pd) {
-    asm volatile ("lidt (%0)" :: "r" (pd) : "memory");
+    asm volatile ("lidt (%0)" :: "r" (pd));
 }
 
 static inline void
@@ -137,67 +81,12 @@
 
 static inline void
 cli(void) {
-    asm volatile ("cli" ::: "memory");
+    asm volatile ("cli");
 }
 
 static inline void
 ltr(uint16_t sel) {
-    asm volatile ("ltr %0" :: "r" (sel) : "memory");
-}
-
-static inline uint32_t
-read_eflags(void) {
-    uint32_t eflags;
-    asm volatile ("pushfl; popl %0" : "=r" (eflags));
-    return eflags;
-}
-
-static inline void
-write_eflags(uint32_t eflags) {
-    asm volatile ("pushl %0; popfl" :: "r" (eflags));
-}
-
-static inline void
-lcr0(uintptr_t cr0) {
-    asm volatile ("mov %0, %%cr0" :: "r" (cr0) : "memory");
-}
-
-static inline void
-lcr3(uintptr_t cr3) {
-    asm volatile ("mov %0, %%cr3" :: "r" (cr3) : "memory");
-}
-
-static inline uintptr_t
-rcr0(void) {
-    uintptr_t cr0;
-    asm volatile ("mov %%cr0, %0" : "=r" (cr0) :: "memory");
-    return cr0;
-}
-
-static inline uintptr_t
-rcr1(void) {
-    uintptr_t cr1;
-    asm volatile ("mov %%cr1, %0" : "=r" (cr1) :: "memory");
-    return cr1;
-}
-
-static inline uintptr_t
-rcr2(void) {
-    uintptr_t cr2;
-    asm volatile ("mov %%cr2, %0" : "=r" (cr2) :: "memory");
-    return cr2;
-}
-
-static inline uintptr_t
-rcr3(void) {
-    uintptr_t cr3;
-    asm volatile ("mov %%cr3, %0" : "=r" (cr3) :: "memory");
-    return cr3;
-}
-
-static inline void
-invlpg(void *addr) {
-    asm volatile ("invlpg (%0)" :: "r" (addr) : "memory");
+    asm volatile ("ltr %0" :: "r" (sel));
 }
 
 static inline int __strcmp(const char *s1, const char *s2) __attribute__((always_inline));
@@ -212,19 +101,19 @@
 __strcmp(const char *s1, const char *s2) {
     int d0, d1, ret;
     asm volatile (
-        "1: lodsb;"
-        "scasb;"
-        "jne 2f;"
-        "testb %%al, %%al;"
-        "jne 1b;"
-        "xorl %%eax, %%eax;"
-        "jmp 3f;"
-        "2: sbbl %%eax, %%eax;"
-        "orb $1, %%al;"
-        "3:"
-        : "=a" (ret), "=&S" (d0), "=&D" (d1)
-        : "1" (s1), "2" (s2)
-        : "memory");
+            "1: lodsb;"
+            "scasb;"
+            "jne 2f;"
+            "testb %%al, %%al;"
+            "jne 1b;"
+            "xorl %%eax, %%eax;"
+            "jmp 3f;"
+            "2: sbbl %%eax, %%eax;"
+            "orb $1, %%al;"
+            "3:"
+            : "=a" (ret), "=&S" (d0), "=&D" (d1)
+            : "1" (s1), "2" (s2)
+            : "memory");
     return ret;
 }
 
@@ -236,12 +125,12 @@
 __strcpy(char *dst, const char *src) {
     int d0, d1, d2;
     asm volatile (
-        "1: lodsb;"
-        "stosb;"
-        "testb %%al, %%al;"
-        "jne 1b;"
-        : "=&S" (d0), "=&D" (d1), "=&a" (d2)
-        : "0" (src), "1" (dst) : "memory");
+            "1: lodsb;"
+            "stosb;"
+            "testb %%al, %%al;"
+            "jne 1b;"
+            : "=&S" (d0), "=&D" (d1), "=&a" (d2)
+            : "0" (src), "1" (dst) : "memory");
     return dst;
 }
 #endif /* __HAVE_ARCH_STRCPY */
@@ -252,10 +141,10 @@
 __memset(void *s, char c, size_t n) {
     int d0, d1;
     asm volatile (
-        "rep; stosb;"
-        : "=&c" (d0), "=&D" (d1)
-        : "0" (n), "a" (c), "1" (s)
-        : "memory");
+            "rep; stosb;"
+            : "=&c" (d0), "=&D" (d1)
+            : "0" (n), "a" (c), "1" (s)
+            : "memory");
     return s;
 }
 #endif /* __HAVE_ARCH_MEMSET */
@@ -269,12 +158,12 @@
     }
     int d0, d1, d2;
     asm volatile (
-        "std;"
-        "rep; movsb;"
-        "cld;"
-        : "=&c" (d0), "=&S" (d1), "=&D" (d2)
-        : "0" (n), "1" (n - 1 + src), "2" (n - 1 + dst)
-        : "memory");
+            "std;"
+            "rep; movsb;"
+            "cld;"
+            : "=&c" (d0), "=&S" (d1), "=&D" (d2)
+            : "0" (n), "1" (n - 1 + src), "2" (n - 1 + dst)
+            : "memory");
     return dst;
 }
 #endif /* __HAVE_ARCH_MEMMOVE */
@@ -285,15 +174,15 @@
 __memcpy(void *dst, const void *src, size_t n) {
     int d0, d1, d2;
     asm volatile (
-        "rep; movsl;"
-        "movl %4, %%ecx;"
-        "andl $3, %%ecx;"
-        "jz 1f;"
-        "rep; movsb;"
-        "1:"
-        : "=&c" (d0), "=&D" (d1), "=&S" (d2)
-        : "0" (n / 4), "g" (n), "1" (dst), "2" (src)
-        : "memory");
+            "rep; movsl;"
+            "movl %4, %%ecx;"
+            "andl $3, %%ecx;"
+            "jz 1f;"
+            "rep; movsb;"
+            "1:"
+            : "=&c" (d0), "=&D" (d1), "=&S" (d2)
+            : "0" (n / 4), "g" (n), "1" (dst), "2" (src)
+            : "memory");
     return dst;
 }
 #endif /* __HAVE_ARCH_MEMCPY */
diff -urN lab2/Makefile lab1/Makefile
--- lab2/Makefile	2019-02-26 21:54:43.932194340 +0800
+++ lab1/Makefile	2019-02-28 18:26:57.000000000 +0800
@@ -1,4 +1,4 @@
-PROJ	:= 5
+PROJ	:= challenge
 EMPTY	:=
 SPACE	:= $(EMPTY) $(EMPTY)
 SLASH	:= /
@@ -48,17 +48,16 @@
 HOSTCC		:= gcc
 HOSTCFLAGS	:= -g -Wall -O2
 CC		:= $(GCCPREFIX)gcc
-CFLAGS	:= -fno-builtin -Wall -ggdb -m32 -gstabs -nostdinc $(DEFS)
+CFLAGS	:= -fno-builtin -fno-PIC -Wall -ggdb -m32 -gstabs -nostdinc $(DEFS)
 CFLAGS	+= $(shell $(CC) -fno-stack-protector -E -x c /dev/null >/dev/null 2>&1 && echo -fno-stack-protector)
 else
 HOSTCC		:= clang
 HOSTCFLAGS	:= -g -Wall -O2
 CC		:= clang
-CFLAGS	:= -fno-builtin -Wall -g -m32 -mno-sse -nostdinc $(DEFS)
+CFLAGS	:= -fno-builtin -fno-PIC -Wall -g -m32 -mno-sse -nostdinc $(DEFS)
 CFLAGS	+= $(shell $(CC) -fno-stack-protector -E -x c /dev/null >/dev/null 2>&1 && echo -fno-stack-protector)
 endif
 
-GDB		:= $(GCCPREFIX)gdb
 CTYPE	:= c S
 
 LD      := $(GCCPREFIX)ld
@@ -78,9 +77,6 @@
 TR		:= tr
 TOUCH	:= touch -c
 
-TAR		:= tar
-ZIP		:= gzip
-
 OBJDIR	:= obj
 BINDIR	:= bin
 
@@ -126,17 +122,14 @@
 KINCLUDE	+= kern/debug/ \
 			   kern/driver/ \
 			   kern/trap/ \
-			   kern/mm/ \
-			   kern/libs/ \
-			   kern/sync/
+			   kern/mm/
 
 KSRCDIR		+= kern/init \
 			   kern/libs \
 			   kern/debug \
 			   kern/driver \
 			   kern/trap \
-			   kern/mm \
-			   kern/sync
+			   kern/mm
 
 KCFLAGS		+= $(addprefix -I,$(KINCLUDE))
 
@@ -157,20 +150,6 @@
 
 $(call create_target,kernel)
 
-
-# create kernel_nopage target
-kernel_nopage = $(call totarget,kernel_nopage)
-
-$(kernel_nopage): tools/kernel_nopage.ld
-
-$(kernel_nopage): $(KOBJS)
-	@echo + ld $@
-	$(V)$(LD) $(LDFLAGS) -T tools/kernel_nopage.ld -o $@ $(KOBJS)
-	@$(OBJDUMP) -S $@ > $(call asmfile,kernel_nopage)
-	@$(OBJDUMP) -t $@ | $(SED) '1,/SYMBOL TABLE/d; s/ .* / /; /^$$/d' > $(call symfile,kernel_nopage)
-
-$(call create_target,kernel)
-
 # -------------------------------------------------------------------
 
 # create bootblock
@@ -179,9 +158,9 @@
 
 bootblock = $(call totarget,bootblock)
 
-$(bootblock): $(call toobj,boot/bootasm.S) $(call toobj,$(bootfiles)) | $(call totarget,sign)
+$(bootblock): $(call toobj,$(bootfiles)) | $(call totarget,sign)
 	@echo + ld $@
-	$(V)$(LD) $(LDFLAGS) -N -T tools/boot.ld $^ -o $(call toobj,bootblock)
+	$(V)$(LD) $(LDFLAGS) -N -e start -Ttext 0x7C00 $^ -o $(call toobj,bootblock)
 	@$(OBJDUMP) -S $(call objfile,bootblock) > $(call asmfile,bootblock)
 	@$(OBJCOPY) -S -O binary $(call objfile,bootblock) $(call outfile,bootblock)
 	@$(call totarget,sign) $(call outfile,bootblock) $(bootblock)
@@ -199,7 +178,7 @@
 # create ucore.img
 UCOREIMG	:= $(call totarget,ucore.img)
 
-$(UCOREIMG): $(kernel) $(bootblock) $(kernel_nopage)
+$(UCOREIMG): $(kernel) $(bootblock)
 	$(V)dd if=/dev/zero of=$@ count=10000
 	$(V)dd if=$(bootblock) of=$@ conv=notrunc
 	$(V)dd if=$(kernel) of=$@ seek=1 conv=notrunc
@@ -210,9 +189,8 @@
 
 $(call finish_all)
 
-IGNORE_ALLDEPS	= gdb \
-				  clean \
-				  distclean \
+IGNORE_ALLDEPS	= clean \
+				  dist-clean \
 				  grade \
 				  touch \
 				  print-.+ \
@@ -228,34 +206,31 @@
 
 .DEFAULT_GOAL := TARGETS
 
-QEMUOPTS = -hda $(UCOREIMG)
-
 .PHONY: qemu qemu-nox debug debug-nox
 qemu-mon: $(UCOREIMG)
-	$(V)$(QEMU)  -no-reboot -monitor stdio $(QEMUOPTS) -serial null
+	$(V)$(QEMU)  -no-reboot -monitor stdio -hda $< -serial null
 qemu: $(UCOREIMG)
-	$(V)$(QEMU)  -no-reboot -parallel stdio $(QEMUOPTS) -serial null
-
+	$(V)$(QEMU) -no-reboot -parallel stdio -hda $< -serial null
+log: $(UCOREIMG)
+	$(V)$(QEMU) -no-reboot -d int,cpu_reset  -D q.log -parallel stdio -hda $< -serial null
 qemu-nox: $(UCOREIMG)
-	$(V)$(QEMU)  -no-reboot -serial mon:stdio $(QEMUOPTS) -nographic
-
-TERMINAL := gnome-terminal
-
+	$(V)$(QEMU)   -no-reboot -serial mon:stdio -hda $< -nographic
+TERMINAL        :=gnome-terminal
 debug: $(UCOREIMG)
-	$(V)$(QEMU) -S -s -parallel stdio $(QEMUOPTS) -serial null &
+	$(V)$(QEMU) -S -s -parallel stdio -hda $< -serial null &
 	$(V)sleep 2
-	$(V)$(TERMINAL) -e "$(GDB) -q -x tools/gdbinit"
-
+	$(V)$(TERMINAL) -e "gdb -q -tui -x tools/gdbinit"
+	
 debug-nox: $(UCOREIMG)
-	$(V)$(QEMU) -S -s -serial mon:stdio $(QEMUOPTS) -nographic &
+	$(V)$(QEMU) -S -s -serial mon:stdio -hda $< -nographic &
 	$(V)sleep 2
-	$(V)$(TERMINAL) -e "$(GDB) -q -x tools/gdbinit"
+	$(V)$(TERMINAL) -e "gdb -q -x tools/gdbinit"
 
 .PHONY: grade touch
 
 GRADE_GDB_IN	:= .gdb.in
 GRADE_QEMU_OUT	:= .qemu.out
-HANDIN			:= lab2-handin.tar.gz
+HANDIN			:= proj$(PROJ)-handin.tar.gz
 
 TOUCH_FILES		:= kern/trap/trap.c
 
@@ -271,19 +246,21 @@
 print-%:
 	@echo $($(shell echo $(patsubst print-%,%,$@) | $(TR) [a-z] [A-Z]))
 
-.PHONY: clean distclean handin tags
+.PHONY: clean dist-clean handin packall tags
 clean:
 	$(V)$(RM) $(GRADE_GDB_IN) $(GRADE_QEMU_OUT) cscope* tags
-	$(V)$(RM) -r $(OBJDIR) $(BINDIR)
+	-$(RM) -r $(OBJDIR) $(BINDIR)
+
+dist-clean: clean
+	-$(RM) $(HANDIN)
+
+handin: packall
+	@echo Please visit http://learn.tsinghua.edu.cn and upload $(HANDIN). Thanks!
 
-distclean: clean
-	$(V)$(RM) $(HANDIN)
+packall: clean
+	@$(RM) -f $(HANDIN)
+	@tar -czf $(HANDIN) `find . -type f -o -type d | grep -v '^\.*$$' | grep -vF '$(HANDIN)'`
 
-handin: distclean
-	$(V)$(TAR) -cf - `find . -type f -o -type d | grep -v '^\.$$' | grep -v '/CVS/' \
-					| grep -v '/\.git/' | grep -v '/\.svn/' | grep -v "$(HANDIN)"` \
-					| $(ZIP) > $(HANDIN)
-					
 tags:
 	@echo TAGS ALL
 	$(V)rm -f cscope.files cscope.in.out cscope.out cscope.po.out tags
diff -urN lab2/obj/boot/bootasm.d lab1/obj/boot/bootasm.d
--- lab2/obj/boot/bootasm.d	1970-01-01 08:00:00.000000000 +0800
+++ lab1/obj/boot/bootasm.d	2019-03-09 17:45:38.641422736 +0800
@@ -0,0 +1 @@
+obj/boot/bootasm.o obj/boot/bootasm.d: boot/bootasm.S boot/asm.h
Binary files lab2/obj/boot/bootasm.o and lab1/obj/boot/bootasm.o differ
diff -urN lab2/obj/boot/bootmain.d lab1/obj/boot/bootmain.d
--- lab2/obj/boot/bootmain.d	1970-01-01 08:00:00.000000000 +0800
+++ lab1/obj/boot/bootmain.d	2019-03-09 17:45:38.637422724 +0800
@@ -0,0 +1,2 @@
+obj/boot/bootmain.o obj/boot/bootmain.d: boot/bootmain.c libs/defs.h \
+ libs/x86.h libs/elf.h
Binary files lab2/obj/boot/bootmain.o and lab1/obj/boot/bootmain.o differ
diff -urN lab2/obj/bootblock.asm lab1/obj/bootblock.asm
--- lab2/obj/bootblock.asm	1970-01-01 08:00:00.000000000 +0800
+++ lab1/obj/bootblock.asm	2019-03-09 17:45:39.185424379 +0800
@@ -0,0 +1,315 @@
+
+obj/bootblock.o:     file format elf32-i386
+
+
+Disassembly of section .text:
+
+00007c00 <start>:
+
+# start address should be 0:7c00, in real mode, the beginning address of the running bootloader
+.globl start
+start:
+.code16                                             # Assemble for 16-bit mode
+    cli                                             # Disable interrupts
+    7c00:	fa                   	cli    
+    cld                                             # String operations increment
+    7c01:	fc                   	cld    
+
+    # Set up the important data segment registers (DS, ES, SS).
+    xorw %ax, %ax                                   # Segment number zero
+    7c02:	31 c0                	xor    %eax,%eax
+    movw %ax, %ds                                   # -> Data Segment
+    7c04:	8e d8                	mov    %eax,%ds
+    movw %ax, %es                                   # -> Extra Segment
+    7c06:	8e c0                	mov    %eax,%es
+    movw %ax, %ss                                   # -> Stack Segment
+    7c08:	8e d0                	mov    %eax,%ss
+
+00007c0a <seta20.1>:
+    # Enable A20:
+    #  For backwards compatibility with the earliest PCs, physical
+    #  address line 20 is tied low, so that addresses higher than
+    #  1MB wrap around to zero by default. This code undoes this.
+seta20.1:
+    inb $0x64, %al                                  # Wait for not busy(8042 input buffer empty).
+    7c0a:	e4 64                	in     $0x64,%al
+    testb $0x2, %al
+    7c0c:	a8 02                	test   $0x2,%al
+    jnz seta20.1
+    7c0e:	75 fa                	jne    7c0a <seta20.1>
+
+    movb $0xd1, %al                                 # 0xd1 -> port 0x64
+    7c10:	b0 d1                	mov    $0xd1,%al
+    outb %al, $0x64                                 # 0xd1 means: write data to 8042's P2 port
+    7c12:	e6 64                	out    %al,$0x64
+
+00007c14 <seta20.2>:
+
+seta20.2:
+    inb $0x64, %al                                  # Wait for not busy(8042 input buffer empty).
+    7c14:	e4 64                	in     $0x64,%al
+    testb $0x2, %al
+    7c16:	a8 02                	test   $0x2,%al
+    jnz seta20.2
+    7c18:	75 fa                	jne    7c14 <seta20.2>
+
+    movb $0xdf, %al                                 # 0xdf -> port 0x60
+    7c1a:	b0 df                	mov    $0xdf,%al
+    outb %al, $0x60                                 # 0xdf = 11011111, means set P2's A20 bit(the 1 bit) to 1
+    7c1c:	e6 60                	out    %al,$0x60
+
+    # Switch from real to protected mode, using a bootstrap GDT
+    # and segment translation that makes virtual addresses
+    # identical to physical addresses, so that the
+    # effective memory map does not change during the switch.
+    lgdt gdtdesc
+    7c1e:	0f 01 16             	lgdtl  (%esi)
+    7c21:	6c                   	insb   (%dx),%es:(%edi)
+    7c22:	7c 0f                	jl     7c33 <protcseg+0x1>
+    movl %cr0, %eax
+    7c24:	20 c0                	and    %al,%al
+    orl $CR0_PE_ON, %eax
+    7c26:	66 83 c8 01          	or     $0x1,%ax
+    movl %eax, %cr0
+    7c2a:	0f 22 c0             	mov    %eax,%cr0
+
+    # Jump to next instruction, but in 32-bit code segment.
+    # Switches processor into 32-bit mode.
+    ljmp $PROT_MODE_CSEG, $protcseg
+    7c2d:	ea                   	.byte 0xea
+    7c2e:	32 7c 08 00          	xor    0x0(%eax,%ecx,1),%bh
+
+00007c32 <protcseg>:
+
+.code32                                             # Assemble for 32-bit mode
+protcseg:
+    # Set up the protected-mode data segment registers
+    movw $PROT_MODE_DSEG, %ax                       # Our data segment selector
+    7c32:	66 b8 10 00          	mov    $0x10,%ax
+    movw %ax, %ds                                   # -> DS: Data Segment
+    7c36:	8e d8                	mov    %eax,%ds
+    movw %ax, %es                                   # -> ES: Extra Segment
+    7c38:	8e c0                	mov    %eax,%es
+    movw %ax, %fs                                   # -> FS
+    7c3a:	8e e0                	mov    %eax,%fs
+    movw %ax, %gs                                   # -> GS
+    7c3c:	8e e8                	mov    %eax,%gs
+    movw %ax, %ss                                   # -> SS: Stack Segment
+    7c3e:	8e d0                	mov    %eax,%ss
+
+    # Set up the stack pointer and call into C. The stack region is from 0--start(0x7c00)
+    movl $0x0, %ebp
+    7c40:	bd 00 00 00 00       	mov    $0x0,%ebp
+    movl $start, %esp
+    7c45:	bc 00 7c 00 00       	mov    $0x7c00,%esp
+    call bootmain
+    7c4a:	e8 82 00 00 00       	call   7cd1 <bootmain>
+
+00007c4f <spin>:
+
+    # If bootmain returns (it shouldn't), loop.
+spin:
+    jmp spin
+    7c4f:	eb fe                	jmp    7c4f <spin>
+    7c51:	8d 76 00             	lea    0x0(%esi),%esi
+
+00007c54 <gdt>:
+	...
+    7c5c:	ff                   	(bad)  
+    7c5d:	ff 00                	incl   (%eax)
+    7c5f:	00 00                	add    %al,(%eax)
+    7c61:	9a cf 00 ff ff 00 00 	lcall  $0x0,$0xffff00cf
+    7c68:	00                   	.byte 0x0
+    7c69:	92                   	xchg   %eax,%edx
+    7c6a:	cf                   	iret   
+	...
+
+00007c6c <gdtdesc>:
+    7c6c:	17                   	pop    %ss
+    7c6d:	00 54 7c 00          	add    %dl,0x0(%esp,%edi,2)
+	...
+
+00007c72 <readsect>:
+        /* do nothing */;
+}
+
+/* readsect - read a single sector at @secno into @dst */
+static void
+readsect(void *dst, uint32_t secno) {
+    7c72:	55                   	push   %ebp
+    7c73:	89 d1                	mov    %edx,%ecx
+    7c75:	89 e5                	mov    %esp,%ebp
+static inline void ltr(uint16_t sel) __attribute__((always_inline));
+
+static inline uint8_t
+inb(uint16_t port) {
+    uint8_t data;
+    asm volatile ("inb %1, %0" : "=a" (data) : "d" (port));
+    7c77:	ba f7 01 00 00       	mov    $0x1f7,%edx
+    7c7c:	57                   	push   %edi
+    7c7d:	89 c7                	mov    %eax,%edi
+    7c7f:	ec                   	in     (%dx),%al
+    while ((inb(0x1F7) & 0xC0) != 0x40)
+    7c80:	83 e0 c0             	and    $0xffffffc0,%eax
+    7c83:	3c 40                	cmp    $0x40,%al
+    7c85:	75 f8                	jne    7c7f <readsect+0xd>
+            : "memory", "cc");
+}
+
+static inline void
+outb(uint16_t port, uint8_t data) {
+    asm volatile ("outb %0, %1" :: "a" (data), "d" (port));
+    7c87:	ba f2 01 00 00       	mov    $0x1f2,%edx
+    7c8c:	b0 01                	mov    $0x1,%al
+    7c8e:	ee                   	out    %al,(%dx)
+    7c8f:	0f b6 c1             	movzbl %cl,%eax
+    7c92:	b2 f3                	mov    $0xf3,%dl
+    7c94:	ee                   	out    %al,(%dx)
+    7c95:	0f b6 c5             	movzbl %ch,%eax
+    7c98:	b2 f4                	mov    $0xf4,%dl
+    7c9a:	ee                   	out    %al,(%dx)
+    waitdisk();
+
+    outb(0x1F2, 1);                         // count = 1
+    outb(0x1F3, secno & 0xFF);
+    outb(0x1F4, (secno >> 8) & 0xFF);
+    outb(0x1F5, (secno >> 16) & 0xFF);
+    7c9b:	89 c8                	mov    %ecx,%eax
+    7c9d:	b2 f5                	mov    $0xf5,%dl
+    7c9f:	c1 e8 10             	shr    $0x10,%eax
+    7ca2:	0f b6 c0             	movzbl %al,%eax
+    7ca5:	ee                   	out    %al,(%dx)
+    outb(0x1F6, ((secno >> 24) & 0xF) | 0xE0);
+    7ca6:	c1 e9 18             	shr    $0x18,%ecx
+    7ca9:	b2 f6                	mov    $0xf6,%dl
+    7cab:	88 c8                	mov    %cl,%al
+    7cad:	83 e0 0f             	and    $0xf,%eax
+    7cb0:	83 c8 e0             	or     $0xffffffe0,%eax
+    7cb3:	ee                   	out    %al,(%dx)
+    7cb4:	b0 20                	mov    $0x20,%al
+    7cb6:	b2 f7                	mov    $0xf7,%dl
+    7cb8:	ee                   	out    %al,(%dx)
+    asm volatile ("inb %1, %0" : "=a" (data) : "d" (port));
+    7cb9:	ec                   	in     (%dx),%al
+    while ((inb(0x1F7) & 0xC0) != 0x40)
+    7cba:	83 e0 c0             	and    $0xffffffc0,%eax
+    7cbd:	3c 40                	cmp    $0x40,%al
+    7cbf:	75 f8                	jne    7cb9 <readsect+0x47>
+    asm volatile (
+    7cc1:	b9 80 00 00 00       	mov    $0x80,%ecx
+    7cc6:	ba f0 01 00 00       	mov    $0x1f0,%edx
+    7ccb:	fc                   	cld    
+    7ccc:	f2 6d                	repnz insl (%dx),%es:(%edi)
+    // wait for disk to be ready
+    waitdisk();
+
+    // read a sector
+    insl(0x1F0, dst, SECTSIZE / 4);
+}
+    7cce:	5f                   	pop    %edi
+    7ccf:	5d                   	pop    %ebp
+    7cd0:	c3                   	ret    
+
+00007cd1 <bootmain>:
+    }
+}
+
+/* bootmain - the entry of bootloader */
+void
+bootmain(void) {
+    7cd1:	55                   	push   %ebp
+    7cd2:	89 e5                	mov    %esp,%ebp
+    7cd4:	57                   	push   %edi
+    7cd5:	56                   	push   %esi
+    7cd6:	53                   	push   %ebx
+    uint32_t secno = (offset / SECTSIZE) + 1;
+    7cd7:	bb 01 00 00 00       	mov    $0x1,%ebx
+bootmain(void) {
+    7cdc:	83 ec 1c             	sub    $0x1c,%esp
+    7cdf:	8d 43 7f             	lea    0x7f(%ebx),%eax
+        readsect((void *)va, secno);
+    7ce2:	89 da                	mov    %ebx,%edx
+    7ce4:	c1 e0 09             	shl    $0x9,%eax
+    for (; va < end_va; va += SECTSIZE, secno ++) {
+    7ce7:	43                   	inc    %ebx
+        readsect((void *)va, secno);
+    7ce8:	e8 85 ff ff ff       	call   7c72 <readsect>
+    for (; va < end_va; va += SECTSIZE, secno ++) {
+    7ced:	83 fb 09             	cmp    $0x9,%ebx
+    7cf0:	75 ed                	jne    7cdf <bootmain+0xe>
+    // read the 1st page off disk
+    readseg((uintptr_t)ELFHDR, SECTSIZE * 8, 0);
+
+    // is this a valid ELF?
+    if (ELFHDR->e_magic != ELF_MAGIC) {
+    7cf2:	81 3d 00 00 01 00 7f 	cmpl   $0x464c457f,0x10000
+    7cf9:	45 4c 46 
+    7cfc:	75 6a                	jne    7d68 <bootmain+0x97>
+    }
+
+    struct proghdr *ph, *eph;
+
+    // load each program segment (ignores ph flags)
+    ph = (struct proghdr *)((uintptr_t)ELFHDR + ELFHDR->e_phoff);
+    7cfe:	a1 1c 00 01 00       	mov    0x1001c,%eax
+    7d03:	8d 98 00 00 01 00    	lea    0x10000(%eax),%ebx
+    eph = ph + ELFHDR->e_phnum;
+    7d09:	0f b7 05 2c 00 01 00 	movzwl 0x1002c,%eax
+    7d10:	c1 e0 05             	shl    $0x5,%eax
+    7d13:	01 d8                	add    %ebx,%eax
+    7d15:	89 45 e4             	mov    %eax,-0x1c(%ebp)
+    for (; ph < eph; ph ++) {
+    7d18:	3b 5d e4             	cmp    -0x1c(%ebp),%ebx
+    7d1b:	73 3f                	jae    7d5c <bootmain+0x8b>
+        readseg(ph->p_va & 0xFFFFFF, ph->p_memsz, ph->p_offset);
+    7d1d:	8b 73 08             	mov    0x8(%ebx),%esi
+    uintptr_t end_va = va + count;
+    7d20:	8b 43 14             	mov    0x14(%ebx),%eax
+        readseg(ph->p_va & 0xFFFFFF, ph->p_memsz, ph->p_offset);
+    7d23:	8b 4b 04             	mov    0x4(%ebx),%ecx
+    7d26:	81 e6 ff ff ff 00    	and    $0xffffff,%esi
+    uintptr_t end_va = va + count;
+    7d2c:	01 f0                	add    %esi,%eax
+    7d2e:	89 45 e0             	mov    %eax,-0x20(%ebp)
+    va -= offset % SECTSIZE;
+    7d31:	89 c8                	mov    %ecx,%eax
+    7d33:	25 ff 01 00 00       	and    $0x1ff,%eax
+    uint32_t secno = (offset / SECTSIZE) + 1;
+    7d38:	c1 e9 09             	shr    $0x9,%ecx
+    va -= offset % SECTSIZE;
+    7d3b:	29 c6                	sub    %eax,%esi
+    uint32_t secno = (offset / SECTSIZE) + 1;
+    7d3d:	8d 79 01             	lea    0x1(%ecx),%edi
+    for (; va < end_va; va += SECTSIZE, secno ++) {
+    7d40:	3b 75 e0             	cmp    -0x20(%ebp),%esi
+    7d43:	73 12                	jae    7d57 <bootmain+0x86>
+        readsect((void *)va, secno);
+    7d45:	89 fa                	mov    %edi,%edx
+    7d47:	89 f0                	mov    %esi,%eax
+    7d49:	e8 24 ff ff ff       	call   7c72 <readsect>
+    for (; va < end_va; va += SECTSIZE, secno ++) {
+    7d4e:	81 c6 00 02 00 00    	add    $0x200,%esi
+    7d54:	47                   	inc    %edi
+    7d55:	eb e9                	jmp    7d40 <bootmain+0x6f>
+    for (; ph < eph; ph ++) {
+    7d57:	83 c3 20             	add    $0x20,%ebx
+    7d5a:	eb bc                	jmp    7d18 <bootmain+0x47>
+    }
+
+    // call the entry point from the ELF header
+    // note: does not return
+    ((void (*)(void))(ELFHDR->e_entry & 0xFFFFFF))();
+    7d5c:	a1 18 00 01 00       	mov    0x10018,%eax
+    7d61:	25 ff ff ff 00       	and    $0xffffff,%eax
+    7d66:	ff d0                	call   *%eax
+}
+
+static inline void
+outw(uint16_t port, uint16_t data) {
+    asm volatile ("outw %0, %1" :: "a" (data), "d" (port));
+    7d68:	ba 00 8a ff ff       	mov    $0xffff8a00,%edx
+    7d6d:	89 d0                	mov    %edx,%eax
+    7d6f:	66 ef                	out    %ax,(%dx)
+    7d71:	b8 00 8e ff ff       	mov    $0xffff8e00,%eax
+    7d76:	66 ef                	out    %ax,(%dx)
+    7d78:	eb fe                	jmp    7d78 <bootmain+0xa7>
Binary files lab2/obj/bootblock.o and lab1/obj/bootblock.o differ
Binary files lab2/obj/bootblock.out and lab1/obj/bootblock.out differ
diff -urN lab2/obj/kern/debug/kdebug.d lab1/obj/kern/debug/kdebug.d
--- lab2/obj/kern/debug/kdebug.d	1970-01-01 08:00:00.000000000 +0800
+++ lab1/obj/kern/debug/kdebug.d	2019-03-09 17:45:38.697422905 +0800
@@ -0,0 +1,3 @@
+obj/kern/debug/kdebug.o obj/kern/debug/kdebug.d: kern/debug/kdebug.c \
+ libs/defs.h libs/x86.h kern/debug/stab.h libs/stdio.h libs/stdarg.h \
+ libs/string.h kern/debug/kdebug.h
Binary files lab2/obj/kern/debug/kdebug.o and lab1/obj/kern/debug/kdebug.o differ
diff -urN lab2/obj/kern/debug/kmonitor.d lab1/obj/kern/debug/kmonitor.d
--- lab2/obj/kern/debug/kmonitor.d	1970-01-01 08:00:00.000000000 +0800
+++ lab1/obj/kern/debug/kmonitor.d	2019-03-09 17:45:38.693422893 +0800
@@ -0,0 +1,3 @@
+obj/kern/debug/kmonitor.o obj/kern/debug/kmonitor.d: \
+ kern/debug/kmonitor.c libs/stdio.h libs/defs.h libs/stdarg.h \
+ libs/string.h kern/trap/trap.h kern/debug/kmonitor.h kern/debug/kdebug.h
Binary files lab2/obj/kern/debug/kmonitor.o and lab1/obj/kern/debug/kmonitor.o differ
diff -urN lab2/obj/kern/debug/panic.d lab1/obj/kern/debug/panic.d
--- lab2/obj/kern/debug/panic.d	1970-01-01 08:00:00.000000000 +0800
+++ lab1/obj/kern/debug/panic.d	2019-03-09 17:45:38.705422929 +0800
@@ -0,0 +1,3 @@
+obj/kern/debug/panic.o obj/kern/debug/panic.d: kern/debug/panic.c \
+ libs/defs.h libs/stdio.h libs/stdarg.h kern/driver/intr.h \
+ kern/debug/kmonitor.h kern/trap/trap.h
Binary files lab2/obj/kern/debug/panic.o and lab1/obj/kern/debug/panic.o differ
diff -urN lab2/obj/kern/driver/clock.d lab1/obj/kern/driver/clock.d
--- lab2/obj/kern/driver/clock.d	1970-01-01 08:00:00.000000000 +0800
+++ lab1/obj/kern/driver/clock.d	2019-03-09 17:45:38.689422880 +0800
@@ -0,0 +1,3 @@
+obj/kern/driver/clock.o obj/kern/driver/clock.d: kern/driver/clock.c \
+ libs/x86.h libs/defs.h kern/trap/trap.h libs/stdio.h libs/stdarg.h \
+ kern/driver/picirq.h
Binary files lab2/obj/kern/driver/clock.o and lab1/obj/kern/driver/clock.o differ
diff -urN lab2/obj/kern/driver/console.d lab1/obj/kern/driver/console.d
--- lab2/obj/kern/driver/console.d	1970-01-01 08:00:00.000000000 +0800
+++ lab1/obj/kern/driver/console.d	2019-03-09 17:45:38.685422869 +0800
@@ -0,0 +1,3 @@
+obj/kern/driver/console.o obj/kern/driver/console.d: \
+ kern/driver/console.c libs/defs.h libs/x86.h libs/stdio.h libs/stdarg.h \
+ libs/string.h kern/driver/kbdreg.h kern/driver/picirq.h kern/trap/trap.h
Binary files lab2/obj/kern/driver/console.o and lab1/obj/kern/driver/console.o differ
diff -urN lab2/obj/kern/driver/intr.d lab1/obj/kern/driver/intr.d
--- lab2/obj/kern/driver/intr.d	1970-01-01 08:00:00.000000000 +0800
+++ lab1/obj/kern/driver/intr.d	2019-03-09 17:45:38.673422833 +0800
@@ -0,0 +1,2 @@
+obj/kern/driver/intr.o obj/kern/driver/intr.d: kern/driver/intr.c \
+ libs/x86.h libs/defs.h kern/driver/intr.h
Binary files lab2/obj/kern/driver/intr.o and lab1/obj/kern/driver/intr.o differ
diff -urN lab2/obj/kern/driver/picirq.d lab1/obj/kern/driver/picirq.d
--- lab2/obj/kern/driver/picirq.d	1970-01-01 08:00:00.000000000 +0800
+++ lab1/obj/kern/driver/picirq.d	2019-03-09 17:45:38.677422844 +0800
@@ -0,0 +1,2 @@
+obj/kern/driver/picirq.o obj/kern/driver/picirq.d: kern/driver/picirq.c \
+ libs/defs.h libs/x86.h kern/driver/picirq.h
Binary files lab2/obj/kern/driver/picirq.o and lab1/obj/kern/driver/picirq.o differ
diff -urN lab2/obj/kern/init/init.d lab1/obj/kern/init/init.d
--- lab2/obj/kern/init/init.d	1970-01-01 08:00:00.000000000 +0800
+++ lab1/obj/kern/init/init.d	2019-03-09 17:45:38.721422978 +0800
@@ -0,0 +1,5 @@
+obj/kern/init/init.o obj/kern/init/init.d: kern/init/init.c libs/defs.h \
+ libs/stdio.h libs/stdarg.h libs/string.h kern/driver/console.h \
+ kern/debug/kdebug.h kern/driver/picirq.h kern/trap/trap.h \
+ kern/driver/clock.h kern/driver/intr.h kern/mm/pmm.h \
+ kern/debug/kmonitor.h
Binary files lab2/obj/kern/init/init.o and lab1/obj/kern/init/init.o differ
diff -urN lab2/obj/kern/libs/readline.d lab1/obj/kern/libs/readline.d
--- lab2/obj/kern/libs/readline.d	1970-01-01 08:00:00.000000000 +0800
+++ lab1/obj/kern/libs/readline.d	2019-03-09 17:45:38.709422941 +0800
@@ -0,0 +1,2 @@
+obj/kern/libs/readline.o obj/kern/libs/readline.d: kern/libs/readline.c \
+ libs/stdio.h libs/defs.h libs/stdarg.h
Binary files lab2/obj/kern/libs/readline.o and lab1/obj/kern/libs/readline.o differ
diff -urN lab2/obj/kern/libs/stdio.d lab1/obj/kern/libs/stdio.d
--- lab2/obj/kern/libs/stdio.d	1970-01-01 08:00:00.000000000 +0800
+++ lab1/obj/kern/libs/stdio.d	2019-03-09 17:45:38.717422965 +0800
@@ -0,0 +1,2 @@
+obj/kern/libs/stdio.o obj/kern/libs/stdio.d: kern/libs/stdio.c \
+ libs/defs.h libs/stdio.h libs/stdarg.h kern/driver/console.h
Binary files lab2/obj/kern/libs/stdio.o and lab1/obj/kern/libs/stdio.o differ
diff -urN lab2/obj/kern/mm/pmm.d lab1/obj/kern/mm/pmm.d
--- lab2/obj/kern/mm/pmm.d	1970-01-01 08:00:00.000000000 +0800
+++ lab1/obj/kern/mm/pmm.d	2019-03-09 17:45:38.645422748 +0800
@@ -0,0 +1,2 @@
+obj/kern/mm/pmm.o obj/kern/mm/pmm.d: kern/mm/pmm.c libs/defs.h libs/x86.h \
+ kern/mm/mmu.h kern/mm/memlayout.h kern/mm/pmm.h
Binary files lab2/obj/kern/mm/pmm.o and lab1/obj/kern/mm/pmm.o differ
diff -urN lab2/obj/kern/trap/trap.d lab1/obj/kern/trap/trap.d
--- lab2/obj/kern/trap/trap.d	1970-01-01 08:00:00.000000000 +0800
+++ lab1/obj/kern/trap/trap.d	2019-03-09 17:54:32.383021188 +0800
@@ -0,0 +1,4 @@
+obj/kern/trap/trap.o obj/kern/trap/trap.d: kern/trap/trap.c libs/defs.h \
+ kern/mm/mmu.h kern/mm/memlayout.h kern/driver/clock.h kern/trap/trap.h \
+ libs/x86.h libs/stdio.h libs/stdarg.h kern/debug/assert.h \
+ kern/driver/console.h kern/debug/kdebug.h
diff -urN lab2/obj/kern/trap/trapentry.d lab1/obj/kern/trap/trapentry.d
--- lab2/obj/kern/trap/trapentry.d	1970-01-01 08:00:00.000000000 +0800
+++ lab1/obj/kern/trap/trapentry.d	2019-03-09 17:45:38.653422772 +0800
@@ -0,0 +1,2 @@
+obj/kern/trap/trapentry.o obj/kern/trap/trapentry.d: \
+ kern/trap/trapentry.S kern/mm/memlayout.h
Binary files lab2/obj/kern/trap/trapentry.o and lab1/obj/kern/trap/trapentry.o differ
Binary files lab2/obj/kern/trap/trap.o and lab1/obj/kern/trap/trap.o differ
diff -urN lab2/obj/kern/trap/vectors.d lab1/obj/kern/trap/vectors.d
--- lab2/obj/kern/trap/vectors.d	1970-01-01 08:00:00.000000000 +0800
+++ lab1/obj/kern/trap/vectors.d	2019-03-09 17:45:38.657422784 +0800
@@ -0,0 +1 @@
+obj/kern/trap/vectors.o obj/kern/trap/vectors.d: kern/trap/vectors.S
Binary files lab2/obj/kern/trap/vectors.o and lab1/obj/kern/trap/vectors.o differ
diff -urN lab2/obj/kernel.asm lab1/obj/kernel.asm
--- lab2/obj/kernel.asm	1970-01-01 08:00:00.000000000 +0800
+++ lab1/obj/kernel.asm	2019-03-09 17:54:32.447021379 +0800
@@ -0,0 +1,7802 @@
+
+bin/kernel:     file format elf32-i386
+
+
+Disassembly of section .text:
+
+00100000 <kern_init>:
+int kern_init(void) __attribute__((noreturn));
+void grade_backtrace(void);
+static void lab1_switch_test(void);
+
+int
+kern_init(void) {
+  100000:	55                   	push   %ebp
+  100001:	89 e5                	mov    %esp,%ebp
+  100003:	83 ec 28             	sub    $0x28,%esp
+    extern char edata[], end[];
+    memset(edata, 0, end - edata);
+  100006:	ba 40 fd 10 00       	mov    $0x10fd40,%edx
+  10000b:	b8 16 ea 10 00       	mov    $0x10ea16,%eax
+  100010:	29 c2                	sub    %eax,%edx
+  100012:	89 d0                	mov    %edx,%eax
+  100014:	89 44 24 08          	mov    %eax,0x8(%esp)
+  100018:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
+  10001f:	00 
+  100020:	c7 04 24 16 ea 10 00 	movl   $0x10ea16,(%esp)
+  100027:	e8 25 2c 00 00       	call   102c51 <memset>
+
+    cons_init();                // init the console
+  10002c:	e8 5d 15 00 00       	call   10158e <cons_init>
+
+    const char *message = "(THU.CST) os is loading ...";
+  100031:	c7 45 f4 60 34 10 00 	movl   $0x103460,-0xc(%ebp)
+    cprintf("%s\n\n", message);
+  100038:	8b 45 f4             	mov    -0xc(%ebp),%eax
+  10003b:	89 44 24 04          	mov    %eax,0x4(%esp)
+  10003f:	c7 04 24 7c 34 10 00 	movl   $0x10347c,(%esp)
+  100046:	e8 11 02 00 00       	call   10025c <cprintf>
+
+    print_kerninfo();
+  10004b:	e8 c3 08 00 00       	call   100913 <print_kerninfo>
+
+    grade_backtrace();
+  100050:	e8 86 00 00 00       	call   1000db <grade_backtrace>
+
+    pmm_init();                 // init physical memory management
+  100055:	e8 be 28 00 00       	call   102918 <pmm_init>
+
+    pic_init();                 // init interrupt controller
+  10005a:	e8 66 16 00 00       	call   1016c5 <pic_init>
+    idt_init();                 // init interrupt descriptor table
+  10005f:	e8 c4 17 00 00       	call   101828 <idt_init>
+
+    clock_init();               // init clock interrupt
+  100064:	e8 18 0d 00 00       	call   100d81 <clock_init>
+    intr_enable();              // enable irq interrupt
+  100069:	e8 92 17 00 00       	call   101800 <intr_enable>
+    //LAB1: CAHLLENGE 1 If you try to do it, uncomment lab1_switch_test()
+    // user/kernel mode switch test
+    //lab1_switch_test();
+
+    /* do nothing */
+    while (1);
+  10006e:	eb fe                	jmp    10006e <kern_init+0x6e>
+
+00100070 <grade_backtrace2>:
+}
+
+void __attribute__((noinline))
+grade_backtrace2(int arg0, int arg1, int arg2, int arg3) {
+  100070:	55                   	push   %ebp
+  100071:	89 e5                	mov    %esp,%ebp
+  100073:	83 ec 18             	sub    $0x18,%esp
+    mon_backtrace(0, NULL, NULL);
+  100076:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
+  10007d:	00 
+  10007e:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
+  100085:	00 
+  100086:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
+  10008d:	e8 dd 0c 00 00       	call   100d6f <mon_backtrace>
+}
+  100092:	c9                   	leave  
+  100093:	c3                   	ret    
+
+00100094 <grade_backtrace1>:
+
+void __attribute__((noinline))
+grade_backtrace1(int arg0, int arg1) {
+  100094:	55                   	push   %ebp
+  100095:	89 e5                	mov    %esp,%ebp
+  100097:	53                   	push   %ebx
+  100098:	83 ec 14             	sub    $0x14,%esp
+    grade_backtrace2(arg0, (int)&arg0, arg1, (int)&arg1);
+  10009b:	8d 5d 0c             	lea    0xc(%ebp),%ebx
+  10009e:	8b 4d 0c             	mov    0xc(%ebp),%ecx
+  1000a1:	8d 55 08             	lea    0x8(%ebp),%edx
+  1000a4:	8b 45 08             	mov    0x8(%ebp),%eax
+  1000a7:	89 5c 24 0c          	mov    %ebx,0xc(%esp)
+  1000ab:	89 4c 24 08          	mov    %ecx,0x8(%esp)
+  1000af:	89 54 24 04          	mov    %edx,0x4(%esp)
+  1000b3:	89 04 24             	mov    %eax,(%esp)
+  1000b6:	e8 b5 ff ff ff       	call   100070 <grade_backtrace2>
+}
+  1000bb:	83 c4 14             	add    $0x14,%esp
+  1000be:	5b                   	pop    %ebx
+  1000bf:	5d                   	pop    %ebp
+  1000c0:	c3                   	ret    
+
+001000c1 <grade_backtrace0>:
+
+void __attribute__((noinline))
+grade_backtrace0(int arg0, int arg1, int arg2) {
+  1000c1:	55                   	push   %ebp
+  1000c2:	89 e5                	mov    %esp,%ebp
+  1000c4:	83 ec 18             	sub    $0x18,%esp
+    grade_backtrace1(arg0, arg2);
+  1000c7:	8b 45 10             	mov    0x10(%ebp),%eax
+  1000ca:	89 44 24 04          	mov    %eax,0x4(%esp)
+  1000ce:	8b 45 08             	mov    0x8(%ebp),%eax
+  1000d1:	89 04 24             	mov    %eax,(%esp)
+  1000d4:	e8 bb ff ff ff       	call   100094 <grade_backtrace1>
+}
+  1000d9:	c9                   	leave  
+  1000da:	c3                   	ret    
+
+001000db <grade_backtrace>:
+
+void
+grade_backtrace(void) {
+  1000db:	55                   	push   %ebp
+  1000dc:	89 e5                	mov    %esp,%ebp
+  1000de:	83 ec 18             	sub    $0x18,%esp
+    grade_backtrace0(0, (int)kern_init, 0xffff0000);
+  1000e1:	b8 00 00 10 00       	mov    $0x100000,%eax
+  1000e6:	c7 44 24 08 00 00 ff 	movl   $0xffff0000,0x8(%esp)
+  1000ed:	ff 
+  1000ee:	89 44 24 04          	mov    %eax,0x4(%esp)
+  1000f2:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
+  1000f9:	e8 c3 ff ff ff       	call   1000c1 <grade_backtrace0>
+}
+  1000fe:	c9                   	leave  
+  1000ff:	c3                   	ret    
+
+00100100 <lab1_print_cur_status>:
+
+static void
+lab1_print_cur_status(void) {
+  100100:	55                   	push   %ebp
+  100101:	89 e5                	mov    %esp,%ebp
+  100103:	83 ec 28             	sub    $0x28,%esp
+    static int round = 0;
+    uint16_t reg1, reg2, reg3, reg4;
+    asm volatile (
+  100106:	8c 4d f6             	mov    %cs,-0xa(%ebp)
+  100109:	8c 5d f4             	mov    %ds,-0xc(%ebp)
+  10010c:	8c 45 f2             	mov    %es,-0xe(%ebp)
+  10010f:	8c 55 f0             	mov    %ss,-0x10(%ebp)
+            "mov %%cs, %0;"
+            "mov %%ds, %1;"
+            "mov %%es, %2;"
+            "mov %%ss, %3;"
+            : "=m"(reg1), "=m"(reg2), "=m"(reg3), "=m"(reg4));
+    cprintf("%d: @ring %d\n", round, reg1 & 3);
+  100112:	0f b7 45 f6          	movzwl -0xa(%ebp),%eax
+  100116:	0f b7 c0             	movzwl %ax,%eax
+  100119:	83 e0 03             	and    $0x3,%eax
+  10011c:	89 c2                	mov    %eax,%edx
+  10011e:	a1 20 ea 10 00       	mov    0x10ea20,%eax
+  100123:	89 54 24 08          	mov    %edx,0x8(%esp)
+  100127:	89 44 24 04          	mov    %eax,0x4(%esp)
+  10012b:	c7 04 24 81 34 10 00 	movl   $0x103481,(%esp)
+  100132:	e8 25 01 00 00       	call   10025c <cprintf>
+    cprintf("%d:  cs = %x\n", round, reg1);
+  100137:	0f b7 45 f6          	movzwl -0xa(%ebp),%eax
+  10013b:	0f b7 d0             	movzwl %ax,%edx
+  10013e:	a1 20 ea 10 00       	mov    0x10ea20,%eax
+  100143:	89 54 24 08          	mov    %edx,0x8(%esp)
+  100147:	89 44 24 04          	mov    %eax,0x4(%esp)
+  10014b:	c7 04 24 8f 34 10 00 	movl   $0x10348f,(%esp)
+  100152:	e8 05 01 00 00       	call   10025c <cprintf>
+    cprintf("%d:  ds = %x\n", round, reg2);
+  100157:	0f b7 45 f4          	movzwl -0xc(%ebp),%eax
+  10015b:	0f b7 d0             	movzwl %ax,%edx
+  10015e:	a1 20 ea 10 00       	mov    0x10ea20,%eax
+  100163:	89 54 24 08          	mov    %edx,0x8(%esp)
+  100167:	89 44 24 04          	mov    %eax,0x4(%esp)
+  10016b:	c7 04 24 9d 34 10 00 	movl   $0x10349d,(%esp)
+  100172:	e8 e5 00 00 00       	call   10025c <cprintf>
+    cprintf("%d:  es = %x\n", round, reg3);
+  100177:	0f b7 45 f2          	movzwl -0xe(%ebp),%eax
+  10017b:	0f b7 d0             	movzwl %ax,%edx
+  10017e:	a1 20 ea 10 00       	mov    0x10ea20,%eax
+  100183:	89 54 24 08          	mov    %edx,0x8(%esp)
+  100187:	89 44 24 04          	mov    %eax,0x4(%esp)
+  10018b:	c7 04 24 ab 34 10 00 	movl   $0x1034ab,(%esp)
+  100192:	e8 c5 00 00 00       	call   10025c <cprintf>
+    cprintf("%d:  ss = %x\n", round, reg4);
+  100197:	0f b7 45 f0          	movzwl -0x10(%ebp),%eax
+  10019b:	0f b7 d0             	movzwl %ax,%edx
+  10019e:	a1 20 ea 10 00       	mov    0x10ea20,%eax
+  1001a3:	89 54 24 08          	mov    %edx,0x8(%esp)
+  1001a7:	89 44 24 04          	mov    %eax,0x4(%esp)
+  1001ab:	c7 04 24 b9 34 10 00 	movl   $0x1034b9,(%esp)
+  1001b2:	e8 a5 00 00 00       	call   10025c <cprintf>
+    round ++;
+  1001b7:	a1 20 ea 10 00       	mov    0x10ea20,%eax
+  1001bc:	83 c0 01             	add    $0x1,%eax
+  1001bf:	a3 20 ea 10 00       	mov    %eax,0x10ea20
+}
+  1001c4:	c9                   	leave  
+  1001c5:	c3                   	ret    
+
+001001c6 <lab1_switch_to_user>:
+
+static void
+lab1_switch_to_user(void) {
+  1001c6:	55                   	push   %ebp
+  1001c7:	89 e5                	mov    %esp,%ebp
+    //LAB1 CHALLENGE 1 : TODO
+}
+  1001c9:	5d                   	pop    %ebp
+  1001ca:	c3                   	ret    
+
+001001cb <lab1_switch_to_kernel>:
+
+static void
+lab1_switch_to_kernel(void) {
+  1001cb:	55                   	push   %ebp
+  1001cc:	89 e5                	mov    %esp,%ebp
+    //LAB1 CHALLENGE 1 :  TODO
+}
+  1001ce:	5d                   	pop    %ebp
+  1001cf:	c3                   	ret    
+
+001001d0 <lab1_switch_test>:
+
+static void
+lab1_switch_test(void) {
+  1001d0:	55                   	push   %ebp
+  1001d1:	89 e5                	mov    %esp,%ebp
+  1001d3:	83 ec 18             	sub    $0x18,%esp
+    lab1_print_cur_status();
+  1001d6:	e8 25 ff ff ff       	call   100100 <lab1_print_cur_status>
+    cprintf("+++ switch to  user  mode +++\n");
+  1001db:	c7 04 24 c8 34 10 00 	movl   $0x1034c8,(%esp)
+  1001e2:	e8 75 00 00 00       	call   10025c <cprintf>
+    lab1_switch_to_user();
+  1001e7:	e8 da ff ff ff       	call   1001c6 <lab1_switch_to_user>
+    lab1_print_cur_status();
+  1001ec:	e8 0f ff ff ff       	call   100100 <lab1_print_cur_status>
+    cprintf("+++ switch to kernel mode +++\n");
+  1001f1:	c7 04 24 e8 34 10 00 	movl   $0x1034e8,(%esp)
+  1001f8:	e8 5f 00 00 00       	call   10025c <cprintf>
+    lab1_switch_to_kernel();
+  1001fd:	e8 c9 ff ff ff       	call   1001cb <lab1_switch_to_kernel>
+    lab1_print_cur_status();
+  100202:	e8 f9 fe ff ff       	call   100100 <lab1_print_cur_status>
+}
+  100207:	c9                   	leave  
+  100208:	c3                   	ret    
+
+00100209 <cputch>:
+/* *
+ * cputch - writes a single character @c to stdout, and it will
+ * increace the value of counter pointed by @cnt.
+ * */
+static void
+cputch(int c, int *cnt) {
+  100209:	55                   	push   %ebp
+  10020a:	89 e5                	mov    %esp,%ebp
+  10020c:	83 ec 18             	sub    $0x18,%esp
+    cons_putc(c);
+  10020f:	8b 45 08             	mov    0x8(%ebp),%eax
+  100212:	89 04 24             	mov    %eax,(%esp)
+  100215:	e8 a0 13 00 00       	call   1015ba <cons_putc>
+    (*cnt) ++;
+  10021a:	8b 45 0c             	mov    0xc(%ebp),%eax
+  10021d:	8b 00                	mov    (%eax),%eax
+  10021f:	8d 50 01             	lea    0x1(%eax),%edx
+  100222:	8b 45 0c             	mov    0xc(%ebp),%eax
+  100225:	89 10                	mov    %edx,(%eax)
+}
+  100227:	c9                   	leave  
+  100228:	c3                   	ret    
+
+00100229 <vcprintf>:
+ *
+ * Call this function if you are already dealing with a va_list.
+ * Or you probably want cprintf() instead.
+ * */
+int
+vcprintf(const char *fmt, va_list ap) {
+  100229:	55                   	push   %ebp
+  10022a:	89 e5                	mov    %esp,%ebp
+  10022c:	83 ec 28             	sub    $0x28,%esp
+    int cnt = 0;
+  10022f:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
+    vprintfmt((void*)cputch, &cnt, fmt, ap);
+  100236:	8b 45 0c             	mov    0xc(%ebp),%eax
+  100239:	89 44 24 0c          	mov    %eax,0xc(%esp)
+  10023d:	8b 45 08             	mov    0x8(%ebp),%eax
+  100240:	89 44 24 08          	mov    %eax,0x8(%esp)
+  100244:	8d 45 f4             	lea    -0xc(%ebp),%eax
+  100247:	89 44 24 04          	mov    %eax,0x4(%esp)
+  10024b:	c7 04 24 09 02 10 00 	movl   $0x100209,(%esp)
+  100252:	e8 4c 2d 00 00       	call   102fa3 <vprintfmt>
+    return cnt;
+  100257:	8b 45 f4             	mov    -0xc(%ebp),%eax
+}
+  10025a:	c9                   	leave  
+  10025b:	c3                   	ret    
+
+0010025c <cprintf>:
+ *
+ * The return value is the number of characters which would be
+ * written to stdout.
+ * */
+int
+cprintf(const char *fmt, ...) {
+  10025c:	55                   	push   %ebp
+  10025d:	89 e5                	mov    %esp,%ebp
+  10025f:	83 ec 28             	sub    $0x28,%esp
+    va_list ap;
+    int cnt;
+    va_start(ap, fmt);
+  100262:	8d 45 0c             	lea    0xc(%ebp),%eax
+  100265:	89 45 f0             	mov    %eax,-0x10(%ebp)
+    cnt = vcprintf(fmt, ap);
+  100268:	8b 45 f0             	mov    -0x10(%ebp),%eax
+  10026b:	89 44 24 04          	mov    %eax,0x4(%esp)
+  10026f:	8b 45 08             	mov    0x8(%ebp),%eax
+  100272:	89 04 24             	mov    %eax,(%esp)
+  100275:	e8 af ff ff ff       	call   100229 <vcprintf>
+  10027a:	89 45 f4             	mov    %eax,-0xc(%ebp)
+    va_end(ap);
+    return cnt;
+  10027d:	8b 45 f4             	mov    -0xc(%ebp),%eax
+}
+  100280:	c9                   	leave  
+  100281:	c3                   	ret    
+
+00100282 <cputchar>:
+
+/* cputchar - writes a single character to stdout */
+void
+cputchar(int c) {
+  100282:	55                   	push   %ebp
+  100283:	89 e5                	mov    %esp,%ebp
+  100285:	83 ec 18             	sub    $0x18,%esp
+    cons_putc(c);
+  100288:	8b 45 08             	mov    0x8(%ebp),%eax
+  10028b:	89 04 24             	mov    %eax,(%esp)
+  10028e:	e8 27 13 00 00       	call   1015ba <cons_putc>
+}
+  100293:	c9                   	leave  
+  100294:	c3                   	ret    
+
+00100295 <cputs>:
+/* *
+ * cputs- writes the string pointed by @str to stdout and
+ * appends a newline character.
+ * */
+int
+cputs(const char *str) {
+  100295:	55                   	push   %ebp
+  100296:	89 e5                	mov    %esp,%ebp
+  100298:	83 ec 28             	sub    $0x28,%esp
+    int cnt = 0;
+  10029b:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
+    char c;
+    while ((c = *str ++) != '\0') {
+  1002a2:	eb 13                	jmp    1002b7 <cputs+0x22>
+        cputch(c, &cnt);
+  1002a4:	0f be 45 f7          	movsbl -0x9(%ebp),%eax
+  1002a8:	8d 55 f0             	lea    -0x10(%ebp),%edx
+  1002ab:	89 54 24 04          	mov    %edx,0x4(%esp)
+  1002af:	89 04 24             	mov    %eax,(%esp)
+  1002b2:	e8 52 ff ff ff       	call   100209 <cputch>
+    while ((c = *str ++) != '\0') {
+  1002b7:	8b 45 08             	mov    0x8(%ebp),%eax
+  1002ba:	8d 50 01             	lea    0x1(%eax),%edx
+  1002bd:	89 55 08             	mov    %edx,0x8(%ebp)
+  1002c0:	0f b6 00             	movzbl (%eax),%eax
+  1002c3:	88 45 f7             	mov    %al,-0x9(%ebp)
+  1002c6:	80 7d f7 00          	cmpb   $0x0,-0x9(%ebp)
+  1002ca:	75 d8                	jne    1002a4 <cputs+0xf>
+    }
+    cputch('\n', &cnt);
+  1002cc:	8d 45 f0             	lea    -0x10(%ebp),%eax
+  1002cf:	89 44 24 04          	mov    %eax,0x4(%esp)
+  1002d3:	c7 04 24 0a 00 00 00 	movl   $0xa,(%esp)
+  1002da:	e8 2a ff ff ff       	call   100209 <cputch>
+    return cnt;
+  1002df:	8b 45 f0             	mov    -0x10(%ebp),%eax
+}
+  1002e2:	c9                   	leave  
+  1002e3:	c3                   	ret    
+
+001002e4 <getchar>:
+
+/* getchar - reads a single non-zero character from stdin */
+int
+getchar(void) {
+  1002e4:	55                   	push   %ebp
+  1002e5:	89 e5                	mov    %esp,%ebp
+  1002e7:	83 ec 18             	sub    $0x18,%esp
+    int c;
+    while ((c = cons_getc()) == 0)
+  1002ea:	e8 f4 12 00 00       	call   1015e3 <cons_getc>
+  1002ef:	89 45 f4             	mov    %eax,-0xc(%ebp)
+  1002f2:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
+  1002f6:	74 f2                	je     1002ea <getchar+0x6>
+        /* do nothing */;
+    return c;
+  1002f8:	8b 45 f4             	mov    -0xc(%ebp),%eax
+}
+  1002fb:	c9                   	leave  
+  1002fc:	c3                   	ret    
+
+001002fd <readline>:
+ * The readline() function returns the text of the line read. If some errors
+ * are happened, NULL is returned. The return value is a global variable,
+ * thus it should be copied before it is used.
+ * */
+char *
+readline(const char *prompt) {
+  1002fd:	55                   	push   %ebp
+  1002fe:	89 e5                	mov    %esp,%ebp
+  100300:	83 ec 28             	sub    $0x28,%esp
+    if (prompt != NULL) {
+  100303:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
+  100307:	74 13                	je     10031c <readline+0x1f>
+        cprintf("%s", prompt);
+  100309:	8b 45 08             	mov    0x8(%ebp),%eax
+  10030c:	89 44 24 04          	mov    %eax,0x4(%esp)
+  100310:	c7 04 24 07 35 10 00 	movl   $0x103507,(%esp)
+  100317:	e8 40 ff ff ff       	call   10025c <cprintf>
+    }
+    int i = 0, c;
+  10031c:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
+    while (1) {
+        c = getchar();
+  100323:	e8 bc ff ff ff       	call   1002e4 <getchar>
+  100328:	89 45 f0             	mov    %eax,-0x10(%ebp)
+        if (c < 0) {
+  10032b:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
+  10032f:	79 07                	jns    100338 <readline+0x3b>
+            return NULL;
+  100331:	b8 00 00 00 00       	mov    $0x0,%eax
+  100336:	eb 79                	jmp    1003b1 <readline+0xb4>
+        }
+        else if (c >= ' ' && i < BUFSIZE - 1) {
+  100338:	83 7d f0 1f          	cmpl   $0x1f,-0x10(%ebp)
+  10033c:	7e 28                	jle    100366 <readline+0x69>
+  10033e:	81 7d f4 fe 03 00 00 	cmpl   $0x3fe,-0xc(%ebp)
+  100345:	7f 1f                	jg     100366 <readline+0x69>
+            cputchar(c);
+  100347:	8b 45 f0             	mov    -0x10(%ebp),%eax
+  10034a:	89 04 24             	mov    %eax,(%esp)
+  10034d:	e8 30 ff ff ff       	call   100282 <cputchar>
+            buf[i ++] = c;
+  100352:	8b 45 f4             	mov    -0xc(%ebp),%eax
+  100355:	8d 50 01             	lea    0x1(%eax),%edx
+  100358:	89 55 f4             	mov    %edx,-0xc(%ebp)
+  10035b:	8b 55 f0             	mov    -0x10(%ebp),%edx
+  10035e:	88 90 40 ea 10 00    	mov    %dl,0x10ea40(%eax)
+  100364:	eb 46                	jmp    1003ac <readline+0xaf>
+        }
+        else if (c == '\b' && i > 0) {
+  100366:	83 7d f0 08          	cmpl   $0x8,-0x10(%ebp)
+  10036a:	75 17                	jne    100383 <readline+0x86>
+  10036c:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
+  100370:	7e 11                	jle    100383 <readline+0x86>
+            cputchar(c);
+  100372:	8b 45 f0             	mov    -0x10(%ebp),%eax
+  100375:	89 04 24             	mov    %eax,(%esp)
+  100378:	e8 05 ff ff ff       	call   100282 <cputchar>
+            i --;
+  10037d:	83 6d f4 01          	subl   $0x1,-0xc(%ebp)
+  100381:	eb 29                	jmp    1003ac <readline+0xaf>
+        }
+        else if (c == '\n' || c == '\r') {
+  100383:	83 7d f0 0a          	cmpl   $0xa,-0x10(%ebp)
+  100387:	74 06                	je     10038f <readline+0x92>
+  100389:	83 7d f0 0d          	cmpl   $0xd,-0x10(%ebp)
+  10038d:	75 1d                	jne    1003ac <readline+0xaf>
+            cputchar(c);
+  10038f:	8b 45 f0             	mov    -0x10(%ebp),%eax
+  100392:	89 04 24             	mov    %eax,(%esp)
+  100395:	e8 e8 fe ff ff       	call   100282 <cputchar>
+            buf[i] = '\0';
+  10039a:	8b 45 f4             	mov    -0xc(%ebp),%eax
+  10039d:	05 40 ea 10 00       	add    $0x10ea40,%eax
+  1003a2:	c6 00 00             	movb   $0x0,(%eax)
+            return buf;
+  1003a5:	b8 40 ea 10 00       	mov    $0x10ea40,%eax
+  1003aa:	eb 05                	jmp    1003b1 <readline+0xb4>
+        }
+    }
+  1003ac:	e9 72 ff ff ff       	jmp    100323 <readline+0x26>
+}
+  1003b1:	c9                   	leave  
+  1003b2:	c3                   	ret    
+
+001003b3 <__panic>:
+/* *
+ * __panic - __panic is called on unresolvable fatal errors. it prints
+ * "panic: 'message'", and then enters the kernel monitor.
+ * */
+void
+__panic(const char *file, int line, const char *fmt, ...) {
+  1003b3:	55                   	push   %ebp
+  1003b4:	89 e5                	mov    %esp,%ebp
+  1003b6:	83 ec 28             	sub    $0x28,%esp
+    if (is_panic) {
+  1003b9:	a1 40 ee 10 00       	mov    0x10ee40,%eax
+  1003be:	85 c0                	test   %eax,%eax
+  1003c0:	74 02                	je     1003c4 <__panic+0x11>
+        goto panic_dead;
+  1003c2:	eb 59                	jmp    10041d <__panic+0x6a>
+    }
+    is_panic = 1;
+  1003c4:	c7 05 40 ee 10 00 01 	movl   $0x1,0x10ee40
+  1003cb:	00 00 00 
+
+    // print the 'message'
+    va_list ap;
+    va_start(ap, fmt);
+  1003ce:	8d 45 14             	lea    0x14(%ebp),%eax
+  1003d1:	89 45 f4             	mov    %eax,-0xc(%ebp)
+    cprintf("kernel panic at %s:%d:\n    ", file, line);
+  1003d4:	8b 45 0c             	mov    0xc(%ebp),%eax
+  1003d7:	89 44 24 08          	mov    %eax,0x8(%esp)
+  1003db:	8b 45 08             	mov    0x8(%ebp),%eax
+  1003de:	89 44 24 04          	mov    %eax,0x4(%esp)
+  1003e2:	c7 04 24 0a 35 10 00 	movl   $0x10350a,(%esp)
+  1003e9:	e8 6e fe ff ff       	call   10025c <cprintf>
+    vcprintf(fmt, ap);
+  1003ee:	8b 45 f4             	mov    -0xc(%ebp),%eax
+  1003f1:	89 44 24 04          	mov    %eax,0x4(%esp)
+  1003f5:	8b 45 10             	mov    0x10(%ebp),%eax
+  1003f8:	89 04 24             	mov    %eax,(%esp)
+  1003fb:	e8 29 fe ff ff       	call   100229 <vcprintf>
+    cprintf("\n");
+  100400:	c7 04 24 26 35 10 00 	movl   $0x103526,(%esp)
+  100407:	e8 50 fe ff ff       	call   10025c <cprintf>
+    
+    cprintf("stack trackback:\n");
+  10040c:	c7 04 24 28 35 10 00 	movl   $0x103528,(%esp)
+  100413:	e8 44 fe ff ff       	call   10025c <cprintf>
+    print_stackframe();
+  100418:	e8 40 06 00 00       	call   100a5d <print_stackframe>
+    
+    va_end(ap);
+
+panic_dead:
+    intr_disable();
+  10041d:	e8 e4 13 00 00       	call   101806 <intr_disable>
+    while (1) {
+        kmonitor(NULL);
+  100422:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
+  100429:	e8 72 08 00 00       	call   100ca0 <kmonitor>
+    }
+  10042e:	eb f2                	jmp    100422 <__panic+0x6f>
+
+00100430 <__warn>:
+}
+
+/* __warn - like panic, but don't */
+void
+__warn(const char *file, int line, const char *fmt, ...) {
+  100430:	55                   	push   %ebp
+  100431:	89 e5                	mov    %esp,%ebp
+  100433:	83 ec 28             	sub    $0x28,%esp
+    va_list ap;
+    va_start(ap, fmt);
+  100436:	8d 45 14             	lea    0x14(%ebp),%eax
+  100439:	89 45 f4             	mov    %eax,-0xc(%ebp)
+    cprintf("kernel warning at %s:%d:\n    ", file, line);
+  10043c:	8b 45 0c             	mov    0xc(%ebp),%eax
+  10043f:	89 44 24 08          	mov    %eax,0x8(%esp)
+  100443:	8b 45 08             	mov    0x8(%ebp),%eax
+  100446:	89 44 24 04          	mov    %eax,0x4(%esp)
+  10044a:	c7 04 24 3a 35 10 00 	movl   $0x10353a,(%esp)
+  100451:	e8 06 fe ff ff       	call   10025c <cprintf>
+    vcprintf(fmt, ap);
+  100456:	8b 45 f4             	mov    -0xc(%ebp),%eax
+  100459:	89 44 24 04          	mov    %eax,0x4(%esp)
+  10045d:	8b 45 10             	mov    0x10(%ebp),%eax
+  100460:	89 04 24             	mov    %eax,(%esp)
+  100463:	e8 c1 fd ff ff       	call   100229 <vcprintf>
+    cprintf("\n");
+  100468:	c7 04 24 26 35 10 00 	movl   $0x103526,(%esp)
+  10046f:	e8 e8 fd ff ff       	call   10025c <cprintf>
+    va_end(ap);
+}
+  100474:	c9                   	leave  
+  100475:	c3                   	ret    
+
+00100476 <is_kernel_panic>:
+
+bool
+is_kernel_panic(void) {
+  100476:	55                   	push   %ebp
+  100477:	89 e5                	mov    %esp,%ebp
+    return is_panic;
+  100479:	a1 40 ee 10 00       	mov    0x10ee40,%eax
+}
+  10047e:	5d                   	pop    %ebp
+  10047f:	c3                   	ret    
+
+00100480 <stab_binsearch>:
+ *      stab_binsearch(stabs, &left, &right, N_SO, 0xf0100184);
+ * will exit setting left = 118, right = 554.
+ * */
+static void
+stab_binsearch(const struct stab *stabs, int *region_left, int *region_right,
+           int type, uintptr_t addr) {
+  100480:	55                   	push   %ebp
+  100481:	89 e5                	mov    %esp,%ebp
+  100483:	83 ec 20             	sub    $0x20,%esp
+    int l = *region_left, r = *region_right, any_matches = 0;
+  100486:	8b 45 0c             	mov    0xc(%ebp),%eax
+  100489:	8b 00                	mov    (%eax),%eax
+  10048b:	89 45 fc             	mov    %eax,-0x4(%ebp)
+  10048e:	8b 45 10             	mov    0x10(%ebp),%eax
+  100491:	8b 00                	mov    (%eax),%eax
+  100493:	89 45 f8             	mov    %eax,-0x8(%ebp)
+  100496:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
+
+    while (l <= r) {
+  10049d:	e9 d2 00 00 00       	jmp    100574 <stab_binsearch+0xf4>
+        int true_m = (l + r) / 2, m = true_m;
+  1004a2:	8b 45 f8             	mov    -0x8(%ebp),%eax
+  1004a5:	8b 55 fc             	mov    -0x4(%ebp),%edx
+  1004a8:	01 d0                	add    %edx,%eax
+  1004aa:	89 c2                	mov    %eax,%edx
+  1004ac:	c1 ea 1f             	shr    $0x1f,%edx
+  1004af:	01 d0                	add    %edx,%eax
+  1004b1:	d1 f8                	sar    %eax
+  1004b3:	89 45 ec             	mov    %eax,-0x14(%ebp)
+  1004b6:	8b 45 ec             	mov    -0x14(%ebp),%eax
+  1004b9:	89 45 f0             	mov    %eax,-0x10(%ebp)
+
+        // search for earliest stab with right type
+        while (m >= l && stabs[m].n_type != type) {
+  1004bc:	eb 04                	jmp    1004c2 <stab_binsearch+0x42>
+            m --;
+  1004be:	83 6d f0 01          	subl   $0x1,-0x10(%ebp)
+        while (m >= l && stabs[m].n_type != type) {
+  1004c2:	8b 45 f0             	mov    -0x10(%ebp),%eax
+  1004c5:	3b 45 fc             	cmp    -0x4(%ebp),%eax
+  1004c8:	7c 1f                	jl     1004e9 <stab_binsearch+0x69>
+  1004ca:	8b 55 f0             	mov    -0x10(%ebp),%edx
+  1004cd:	89 d0                	mov    %edx,%eax
+  1004cf:	01 c0                	add    %eax,%eax
+  1004d1:	01 d0                	add    %edx,%eax
+  1004d3:	c1 e0 02             	shl    $0x2,%eax
+  1004d6:	89 c2                	mov    %eax,%edx
+  1004d8:	8b 45 08             	mov    0x8(%ebp),%eax
+  1004db:	01 d0                	add    %edx,%eax
+  1004dd:	0f b6 40 04          	movzbl 0x4(%eax),%eax
+  1004e1:	0f b6 c0             	movzbl %al,%eax
+  1004e4:	3b 45 14             	cmp    0x14(%ebp),%eax
+  1004e7:	75 d5                	jne    1004be <stab_binsearch+0x3e>
+        }
+        if (m < l) {    // no match in [l, m]
+  1004e9:	8b 45 f0             	mov    -0x10(%ebp),%eax
+  1004ec:	3b 45 fc             	cmp    -0x4(%ebp),%eax
+  1004ef:	7d 0b                	jge    1004fc <stab_binsearch+0x7c>
+            l = true_m + 1;
+  1004f1:	8b 45 ec             	mov    -0x14(%ebp),%eax
+  1004f4:	83 c0 01             	add    $0x1,%eax
+  1004f7:	89 45 fc             	mov    %eax,-0x4(%ebp)
+            continue;
+  1004fa:	eb 78                	jmp    100574 <stab_binsearch+0xf4>
+        }
+
+        // actual binary search
+        any_matches = 1;
+  1004fc:	c7 45 f4 01 00 00 00 	movl   $0x1,-0xc(%ebp)
+        if (stabs[m].n_value < addr) {
+  100503:	8b 55 f0             	mov    -0x10(%ebp),%edx
+  100506:	89 d0                	mov    %edx,%eax
+  100508:	01 c0                	add    %eax,%eax
+  10050a:	01 d0                	add    %edx,%eax
+  10050c:	c1 e0 02             	shl    $0x2,%eax
+  10050f:	89 c2                	mov    %eax,%edx
+  100511:	8b 45 08             	mov    0x8(%ebp),%eax
+  100514:	01 d0                	add    %edx,%eax
+  100516:	8b 40 08             	mov    0x8(%eax),%eax
+  100519:	3b 45 18             	cmp    0x18(%ebp),%eax
+  10051c:	73 13                	jae    100531 <stab_binsearch+0xb1>
+            *region_left = m;
+  10051e:	8b 45 0c             	mov    0xc(%ebp),%eax
+  100521:	8b 55 f0             	mov    -0x10(%ebp),%edx
+  100524:	89 10                	mov    %edx,(%eax)
+            l = true_m + 1;
+  100526:	8b 45 ec             	mov    -0x14(%ebp),%eax
+  100529:	83 c0 01             	add    $0x1,%eax
+  10052c:	89 45 fc             	mov    %eax,-0x4(%ebp)
+  10052f:	eb 43                	jmp    100574 <stab_binsearch+0xf4>
+        } else if (stabs[m].n_value > addr) {
+  100531:	8b 55 f0             	mov    -0x10(%ebp),%edx
+  100534:	89 d0                	mov    %edx,%eax
+  100536:	01 c0                	add    %eax,%eax
+  100538:	01 d0                	add    %edx,%eax
+  10053a:	c1 e0 02             	shl    $0x2,%eax
+  10053d:	89 c2                	mov    %eax,%edx
+  10053f:	8b 45 08             	mov    0x8(%ebp),%eax
+  100542:	01 d0                	add    %edx,%eax
+  100544:	8b 40 08             	mov    0x8(%eax),%eax
+  100547:	3b 45 18             	cmp    0x18(%ebp),%eax
+  10054a:	76 16                	jbe    100562 <stab_binsearch+0xe2>
+            *region_right = m - 1;
+  10054c:	8b 45 f0             	mov    -0x10(%ebp),%eax
+  10054f:	8d 50 ff             	lea    -0x1(%eax),%edx
+  100552:	8b 45 10             	mov    0x10(%ebp),%eax
+  100555:	89 10                	mov    %edx,(%eax)
+            r = m - 1;
+  100557:	8b 45 f0             	mov    -0x10(%ebp),%eax
+  10055a:	83 e8 01             	sub    $0x1,%eax
+  10055d:	89 45 f8             	mov    %eax,-0x8(%ebp)
+  100560:	eb 12                	jmp    100574 <stab_binsearch+0xf4>
+        } else {
+            // exact match for 'addr', but continue loop to find
+            // *region_right
+            *region_left = m;
+  100562:	8b 45 0c             	mov    0xc(%ebp),%eax
+  100565:	8b 55 f0             	mov    -0x10(%ebp),%edx
+  100568:	89 10                	mov    %edx,(%eax)
+            l = m;
+  10056a:	8b 45 f0             	mov    -0x10(%ebp),%eax
+  10056d:	89 45 fc             	mov    %eax,-0x4(%ebp)
+            addr ++;
+  100570:	83 45 18 01          	addl   $0x1,0x18(%ebp)
+    while (l <= r) {
+  100574:	8b 45 fc             	mov    -0x4(%ebp),%eax
+  100577:	3b 45 f8             	cmp    -0x8(%ebp),%eax
+  10057a:	0f 8e 22 ff ff ff    	jle    1004a2 <stab_binsearch+0x22>
+        }
+    }
+
+    if (!any_matches) {
+  100580:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
+  100584:	75 0f                	jne    100595 <stab_binsearch+0x115>
+        *region_right = *region_left - 1;
+  100586:	8b 45 0c             	mov    0xc(%ebp),%eax
+  100589:	8b 00                	mov    (%eax),%eax
+  10058b:	8d 50 ff             	lea    -0x1(%eax),%edx
+  10058e:	8b 45 10             	mov    0x10(%ebp),%eax
+  100591:	89 10                	mov    %edx,(%eax)
+  100593:	eb 3f                	jmp    1005d4 <stab_binsearch+0x154>
+    }
+    else {
+        // find rightmost region containing 'addr'
+        l = *region_right;
+  100595:	8b 45 10             	mov    0x10(%ebp),%eax
+  100598:	8b 00                	mov    (%eax),%eax
+  10059a:	89 45 fc             	mov    %eax,-0x4(%ebp)
+        for (; l > *region_left && stabs[l].n_type != type; l --)
+  10059d:	eb 04                	jmp    1005a3 <stab_binsearch+0x123>
+  10059f:	83 6d fc 01          	subl   $0x1,-0x4(%ebp)
+  1005a3:	8b 45 0c             	mov    0xc(%ebp),%eax
+  1005a6:	8b 00                	mov    (%eax),%eax
+  1005a8:	3b 45 fc             	cmp    -0x4(%ebp),%eax
+  1005ab:	7d 1f                	jge    1005cc <stab_binsearch+0x14c>
+  1005ad:	8b 55 fc             	mov    -0x4(%ebp),%edx
+  1005b0:	89 d0                	mov    %edx,%eax
+  1005b2:	01 c0                	add    %eax,%eax
+  1005b4:	01 d0                	add    %edx,%eax
+  1005b6:	c1 e0 02             	shl    $0x2,%eax
+  1005b9:	89 c2                	mov    %eax,%edx
+  1005bb:	8b 45 08             	mov    0x8(%ebp),%eax
+  1005be:	01 d0                	add    %edx,%eax
+  1005c0:	0f b6 40 04          	movzbl 0x4(%eax),%eax
+  1005c4:	0f b6 c0             	movzbl %al,%eax
+  1005c7:	3b 45 14             	cmp    0x14(%ebp),%eax
+  1005ca:	75 d3                	jne    10059f <stab_binsearch+0x11f>
+            /* do nothing */;
+        *region_left = l;
+  1005cc:	8b 45 0c             	mov    0xc(%ebp),%eax
+  1005cf:	8b 55 fc             	mov    -0x4(%ebp),%edx
+  1005d2:	89 10                	mov    %edx,(%eax)
+    }
+}
+  1005d4:	c9                   	leave  
+  1005d5:	c3                   	ret    
+
+001005d6 <debuginfo_eip>:
+ * the specified instruction address, @addr.  Returns 0 if information
+ * was found, and negative if not.  But even if it returns negative it
+ * has stored some information into '*info'.
+ * */
+int
+debuginfo_eip(uintptr_t addr, struct eipdebuginfo *info) {
+  1005d6:	55                   	push   %ebp
+  1005d7:	89 e5                	mov    %esp,%ebp
+  1005d9:	83 ec 58             	sub    $0x58,%esp
+    const struct stab *stabs, *stab_end;
+    const char *stabstr, *stabstr_end;
+
+    info->eip_file = "<unknown>";
+  1005dc:	8b 45 0c             	mov    0xc(%ebp),%eax
+  1005df:	c7 00 58 35 10 00    	movl   $0x103558,(%eax)
+    info->eip_line = 0;
+  1005e5:	8b 45 0c             	mov    0xc(%ebp),%eax
+  1005e8:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
+    info->eip_fn_name = "<unknown>";
+  1005ef:	8b 45 0c             	mov    0xc(%ebp),%eax
+  1005f2:	c7 40 08 58 35 10 00 	movl   $0x103558,0x8(%eax)
+    info->eip_fn_namelen = 9;
+  1005f9:	8b 45 0c             	mov    0xc(%ebp),%eax
+  1005fc:	c7 40 0c 09 00 00 00 	movl   $0x9,0xc(%eax)
+    info->eip_fn_addr = addr;
+  100603:	8b 45 0c             	mov    0xc(%ebp),%eax
+  100606:	8b 55 08             	mov    0x8(%ebp),%edx
+  100609:	89 50 10             	mov    %edx,0x10(%eax)
+    info->eip_fn_narg = 0;
+  10060c:	8b 45 0c             	mov    0xc(%ebp),%eax
+  10060f:	c7 40 14 00 00 00 00 	movl   $0x0,0x14(%eax)
+
+    stabs = __STAB_BEGIN__;
+  100616:	c7 45 f4 8c 3d 10 00 	movl   $0x103d8c,-0xc(%ebp)
+    stab_end = __STAB_END__;
+  10061d:	c7 45 f0 08 b5 10 00 	movl   $0x10b508,-0x10(%ebp)
+    stabstr = __STABSTR_BEGIN__;
+  100624:	c7 45 ec 09 b5 10 00 	movl   $0x10b509,-0x14(%ebp)
+    stabstr_end = __STABSTR_END__;
+  10062b:	c7 45 e8 0e d5 10 00 	movl   $0x10d50e,-0x18(%ebp)
+
+    // String table validity checks
+    if (stabstr_end <= stabstr || stabstr_end[-1] != 0) {
+  100632:	8b 45 e8             	mov    -0x18(%ebp),%eax
+  100635:	3b 45 ec             	cmp    -0x14(%ebp),%eax
+  100638:	76 0d                	jbe    100647 <debuginfo_eip+0x71>
+  10063a:	8b 45 e8             	mov    -0x18(%ebp),%eax
+  10063d:	83 e8 01             	sub    $0x1,%eax
+  100640:	0f b6 00             	movzbl (%eax),%eax
+  100643:	84 c0                	test   %al,%al
+  100645:	74 0a                	je     100651 <debuginfo_eip+0x7b>
+        return -1;
+  100647:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
+  10064c:	e9 c0 02 00 00       	jmp    100911 <debuginfo_eip+0x33b>
+    // 'eip'.  First, we find the basic source file containing 'eip'.
+    // Then, we look in that source file for the function.  Then we look
+    // for the line number.
+
+    // Search the entire set of stabs for the source file (type N_SO).
+    int lfile = 0, rfile = (stab_end - stabs) - 1;
+  100651:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
+  100658:	8b 55 f0             	mov    -0x10(%ebp),%edx
+  10065b:	8b 45 f4             	mov    -0xc(%ebp),%eax
+  10065e:	29 c2                	sub    %eax,%edx
+  100660:	89 d0                	mov    %edx,%eax
+  100662:	c1 f8 02             	sar    $0x2,%eax
+  100665:	69 c0 ab aa aa aa    	imul   $0xaaaaaaab,%eax,%eax
+  10066b:	83 e8 01             	sub    $0x1,%eax
+  10066e:	89 45 e0             	mov    %eax,-0x20(%ebp)
+    stab_binsearch(stabs, &lfile, &rfile, N_SO, addr);
+  100671:	8b 45 08             	mov    0x8(%ebp),%eax
+  100674:	89 44 24 10          	mov    %eax,0x10(%esp)
+  100678:	c7 44 24 0c 64 00 00 	movl   $0x64,0xc(%esp)
+  10067f:	00 
+  100680:	8d 45 e0             	lea    -0x20(%ebp),%eax
+  100683:	89 44 24 08          	mov    %eax,0x8(%esp)
+  100687:	8d 45 e4             	lea    -0x1c(%ebp),%eax
+  10068a:	89 44 24 04          	mov    %eax,0x4(%esp)
+  10068e:	8b 45 f4             	mov    -0xc(%ebp),%eax
+  100691:	89 04 24             	mov    %eax,(%esp)
+  100694:	e8 e7 fd ff ff       	call   100480 <stab_binsearch>
+    if (lfile == 0)
+  100699:	8b 45 e4             	mov    -0x1c(%ebp),%eax
+  10069c:	85 c0                	test   %eax,%eax
+  10069e:	75 0a                	jne    1006aa <debuginfo_eip+0xd4>
+        return -1;
+  1006a0:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
+  1006a5:	e9 67 02 00 00       	jmp    100911 <debuginfo_eip+0x33b>
+
+    // Search within that file's stabs for the function definition
+    // (N_FUN).
+    int lfun = lfile, rfun = rfile;
+  1006aa:	8b 45 e4             	mov    -0x1c(%ebp),%eax
+  1006ad:	89 45 dc             	mov    %eax,-0x24(%ebp)
+  1006b0:	8b 45 e0             	mov    -0x20(%ebp),%eax
+  1006b3:	89 45 d8             	mov    %eax,-0x28(%ebp)
+    int lline, rline;
+    stab_binsearch(stabs, &lfun, &rfun, N_FUN, addr);
+  1006b6:	8b 45 08             	mov    0x8(%ebp),%eax
+  1006b9:	89 44 24 10          	mov    %eax,0x10(%esp)
+  1006bd:	c7 44 24 0c 24 00 00 	movl   $0x24,0xc(%esp)
+  1006c4:	00 
+  1006c5:	8d 45 d8             	lea    -0x28(%ebp),%eax
+  1006c8:	89 44 24 08          	mov    %eax,0x8(%esp)
+  1006cc:	8d 45 dc             	lea    -0x24(%ebp),%eax
+  1006cf:	89 44 24 04          	mov    %eax,0x4(%esp)
+  1006d3:	8b 45 f4             	mov    -0xc(%ebp),%eax
+  1006d6:	89 04 24             	mov    %eax,(%esp)
+  1006d9:	e8 a2 fd ff ff       	call   100480 <stab_binsearch>
+
+    if (lfun <= rfun) {
+  1006de:	8b 55 dc             	mov    -0x24(%ebp),%edx
+  1006e1:	8b 45 d8             	mov    -0x28(%ebp),%eax
+  1006e4:	39 c2                	cmp    %eax,%edx
+  1006e6:	7f 7c                	jg     100764 <debuginfo_eip+0x18e>
+        // stabs[lfun] points to the function name
+        // in the string table, but check bounds just in case.
+        if (stabs[lfun].n_strx < stabstr_end - stabstr) {
+  1006e8:	8b 45 dc             	mov    -0x24(%ebp),%eax
+  1006eb:	89 c2                	mov    %eax,%edx
+  1006ed:	89 d0                	mov    %edx,%eax
+  1006ef:	01 c0                	add    %eax,%eax
+  1006f1:	01 d0                	add    %edx,%eax
+  1006f3:	c1 e0 02             	shl    $0x2,%eax
+  1006f6:	89 c2                	mov    %eax,%edx
+  1006f8:	8b 45 f4             	mov    -0xc(%ebp),%eax
+  1006fb:	01 d0                	add    %edx,%eax
+  1006fd:	8b 10                	mov    (%eax),%edx
+  1006ff:	8b 4d e8             	mov    -0x18(%ebp),%ecx
+  100702:	8b 45 ec             	mov    -0x14(%ebp),%eax
+  100705:	29 c1                	sub    %eax,%ecx
+  100707:	89 c8                	mov    %ecx,%eax
+  100709:	39 c2                	cmp    %eax,%edx
+  10070b:	73 22                	jae    10072f <debuginfo_eip+0x159>
+            info->eip_fn_name = stabstr + stabs[lfun].n_strx;
+  10070d:	8b 45 dc             	mov    -0x24(%ebp),%eax
+  100710:	89 c2                	mov    %eax,%edx
+  100712:	89 d0                	mov    %edx,%eax
+  100714:	01 c0                	add    %eax,%eax
+  100716:	01 d0                	add    %edx,%eax
+  100718:	c1 e0 02             	shl    $0x2,%eax
+  10071b:	89 c2                	mov    %eax,%edx
+  10071d:	8b 45 f4             	mov    -0xc(%ebp),%eax
+  100720:	01 d0                	add    %edx,%eax
+  100722:	8b 10                	mov    (%eax),%edx
+  100724:	8b 45 ec             	mov    -0x14(%ebp),%eax
+  100727:	01 c2                	add    %eax,%edx
+  100729:	8b 45 0c             	mov    0xc(%ebp),%eax
+  10072c:	89 50 08             	mov    %edx,0x8(%eax)
+        }
+        info->eip_fn_addr = stabs[lfun].n_value;
+  10072f:	8b 45 dc             	mov    -0x24(%ebp),%eax
+  100732:	89 c2                	mov    %eax,%edx
+  100734:	89 d0                	mov    %edx,%eax
+  100736:	01 c0                	add    %eax,%eax
+  100738:	01 d0                	add    %edx,%eax
+  10073a:	c1 e0 02             	shl    $0x2,%eax
+  10073d:	89 c2                	mov    %eax,%edx
+  10073f:	8b 45 f4             	mov    -0xc(%ebp),%eax
+  100742:	01 d0                	add    %edx,%eax
+  100744:	8b 50 08             	mov    0x8(%eax),%edx
+  100747:	8b 45 0c             	mov    0xc(%ebp),%eax
+  10074a:	89 50 10             	mov    %edx,0x10(%eax)
+        addr -= info->eip_fn_addr;
+  10074d:	8b 45 0c             	mov    0xc(%ebp),%eax
+  100750:	8b 40 10             	mov    0x10(%eax),%eax
+  100753:	29 45 08             	sub    %eax,0x8(%ebp)
+        // Search within the function definition for the line number.
+        lline = lfun;
+  100756:	8b 45 dc             	mov    -0x24(%ebp),%eax
+  100759:	89 45 d4             	mov    %eax,-0x2c(%ebp)
+        rline = rfun;
+  10075c:	8b 45 d8             	mov    -0x28(%ebp),%eax
+  10075f:	89 45 d0             	mov    %eax,-0x30(%ebp)
+  100762:	eb 15                	jmp    100779 <debuginfo_eip+0x1a3>
+    } else {
+        // Couldn't find function stab!  Maybe we're in an assembly
+        // file.  Search the whole file for the line number.
+        info->eip_fn_addr = addr;
+  100764:	8b 45 0c             	mov    0xc(%ebp),%eax
+  100767:	8b 55 08             	mov    0x8(%ebp),%edx
+  10076a:	89 50 10             	mov    %edx,0x10(%eax)
+        lline = lfile;
+  10076d:	8b 45 e4             	mov    -0x1c(%ebp),%eax
+  100770:	89 45 d4             	mov    %eax,-0x2c(%ebp)
+        rline = rfile;
+  100773:	8b 45 e0             	mov    -0x20(%ebp),%eax
+  100776:	89 45 d0             	mov    %eax,-0x30(%ebp)
+    }
+    info->eip_fn_namelen = strfind(info->eip_fn_name, ':') - info->eip_fn_name;
+  100779:	8b 45 0c             	mov    0xc(%ebp),%eax
+  10077c:	8b 40 08             	mov    0x8(%eax),%eax
+  10077f:	c7 44 24 04 3a 00 00 	movl   $0x3a,0x4(%esp)
+  100786:	00 
+  100787:	89 04 24             	mov    %eax,(%esp)
+  10078a:	e8 36 23 00 00       	call   102ac5 <strfind>
+  10078f:	89 c2                	mov    %eax,%edx
+  100791:	8b 45 0c             	mov    0xc(%ebp),%eax
+  100794:	8b 40 08             	mov    0x8(%eax),%eax
+  100797:	29 c2                	sub    %eax,%edx
+  100799:	8b 45 0c             	mov    0xc(%ebp),%eax
+  10079c:	89 50 0c             	mov    %edx,0xc(%eax)
+
+    // Search within [lline, rline] for the line number stab.
+    // If found, set info->eip_line to the right line number.
+    // If not found, return -1.
+    stab_binsearch(stabs, &lline, &rline, N_SLINE, addr);
+  10079f:	8b 45 08             	mov    0x8(%ebp),%eax
+  1007a2:	89 44 24 10          	mov    %eax,0x10(%esp)
+  1007a6:	c7 44 24 0c 44 00 00 	movl   $0x44,0xc(%esp)
+  1007ad:	00 
+  1007ae:	8d 45 d0             	lea    -0x30(%ebp),%eax
+  1007b1:	89 44 24 08          	mov    %eax,0x8(%esp)
+  1007b5:	8d 45 d4             	lea    -0x2c(%ebp),%eax
+  1007b8:	89 44 24 04          	mov    %eax,0x4(%esp)
+  1007bc:	8b 45 f4             	mov    -0xc(%ebp),%eax
+  1007bf:	89 04 24             	mov    %eax,(%esp)
+  1007c2:	e8 b9 fc ff ff       	call   100480 <stab_binsearch>
+    if (lline <= rline) {
+  1007c7:	8b 55 d4             	mov    -0x2c(%ebp),%edx
+  1007ca:	8b 45 d0             	mov    -0x30(%ebp),%eax
+  1007cd:	39 c2                	cmp    %eax,%edx
+  1007cf:	7f 24                	jg     1007f5 <debuginfo_eip+0x21f>
+        info->eip_line = stabs[rline].n_desc;
+  1007d1:	8b 45 d0             	mov    -0x30(%ebp),%eax
+  1007d4:	89 c2                	mov    %eax,%edx
+  1007d6:	89 d0                	mov    %edx,%eax
+  1007d8:	01 c0                	add    %eax,%eax
+  1007da:	01 d0                	add    %edx,%eax
+  1007dc:	c1 e0 02             	shl    $0x2,%eax
+  1007df:	89 c2                	mov    %eax,%edx
+  1007e1:	8b 45 f4             	mov    -0xc(%ebp),%eax
+  1007e4:	01 d0                	add    %edx,%eax
+  1007e6:	0f b7 40 06          	movzwl 0x6(%eax),%eax
+  1007ea:	0f b7 d0             	movzwl %ax,%edx
+  1007ed:	8b 45 0c             	mov    0xc(%ebp),%eax
+  1007f0:	89 50 04             	mov    %edx,0x4(%eax)
+
+    // Search backwards from the line number for the relevant filename stab.
+    // We can't just use the "lfile" stab because inlined functions
+    // can interpolate code from a different file!
+    // Such included source files use the N_SOL stab type.
+    while (lline >= lfile
+  1007f3:	eb 13                	jmp    100808 <debuginfo_eip+0x232>
+        return -1;
+  1007f5:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
+  1007fa:	e9 12 01 00 00       	jmp    100911 <debuginfo_eip+0x33b>
+           && stabs[lline].n_type != N_SOL
+           && (stabs[lline].n_type != N_SO || !stabs[lline].n_value)) {
+        lline --;
+  1007ff:	8b 45 d4             	mov    -0x2c(%ebp),%eax
+  100802:	83 e8 01             	sub    $0x1,%eax
+  100805:	89 45 d4             	mov    %eax,-0x2c(%ebp)
+    while (lline >= lfile
+  100808:	8b 55 d4             	mov    -0x2c(%ebp),%edx
+  10080b:	8b 45 e4             	mov    -0x1c(%ebp),%eax
+  10080e:	39 c2                	cmp    %eax,%edx
+  100810:	7c 56                	jl     100868 <debuginfo_eip+0x292>
+           && stabs[lline].n_type != N_SOL
+  100812:	8b 45 d4             	mov    -0x2c(%ebp),%eax
+  100815:	89 c2                	mov    %eax,%edx
+  100817:	89 d0                	mov    %edx,%eax
+  100819:	01 c0                	add    %eax,%eax
+  10081b:	01 d0                	add    %edx,%eax
+  10081d:	c1 e0 02             	shl    $0x2,%eax
+  100820:	89 c2                	mov    %eax,%edx
+  100822:	8b 45 f4             	mov    -0xc(%ebp),%eax
+  100825:	01 d0                	add    %edx,%eax
+  100827:	0f b6 40 04          	movzbl 0x4(%eax),%eax
+  10082b:	3c 84                	cmp    $0x84,%al
+  10082d:	74 39                	je     100868 <debuginfo_eip+0x292>
+           && (stabs[lline].n_type != N_SO || !stabs[lline].n_value)) {
+  10082f:	8b 45 d4             	mov    -0x2c(%ebp),%eax
+  100832:	89 c2                	mov    %eax,%edx
+  100834:	89 d0                	mov    %edx,%eax
+  100836:	01 c0                	add    %eax,%eax
+  100838:	01 d0                	add    %edx,%eax
+  10083a:	c1 e0 02             	shl    $0x2,%eax
+  10083d:	89 c2                	mov    %eax,%edx
+  10083f:	8b 45 f4             	mov    -0xc(%ebp),%eax
+  100842:	01 d0                	add    %edx,%eax
+  100844:	0f b6 40 04          	movzbl 0x4(%eax),%eax
+  100848:	3c 64                	cmp    $0x64,%al
+  10084a:	75 b3                	jne    1007ff <debuginfo_eip+0x229>
+  10084c:	8b 45 d4             	mov    -0x2c(%ebp),%eax
+  10084f:	89 c2                	mov    %eax,%edx
+  100851:	89 d0                	mov    %edx,%eax
+  100853:	01 c0                	add    %eax,%eax
+  100855:	01 d0                	add    %edx,%eax
+  100857:	c1 e0 02             	shl    $0x2,%eax
+  10085a:	89 c2                	mov    %eax,%edx
+  10085c:	8b 45 f4             	mov    -0xc(%ebp),%eax
+  10085f:	01 d0                	add    %edx,%eax
+  100861:	8b 40 08             	mov    0x8(%eax),%eax
+  100864:	85 c0                	test   %eax,%eax
+  100866:	74 97                	je     1007ff <debuginfo_eip+0x229>
+    }
+    if (lline >= lfile && stabs[lline].n_strx < stabstr_end - stabstr) {
+  100868:	8b 55 d4             	mov    -0x2c(%ebp),%edx
+  10086b:	8b 45 e4             	mov    -0x1c(%ebp),%eax
+  10086e:	39 c2                	cmp    %eax,%edx
+  100870:	7c 46                	jl     1008b8 <debuginfo_eip+0x2e2>
+  100872:	8b 45 d4             	mov    -0x2c(%ebp),%eax
+  100875:	89 c2                	mov    %eax,%edx
+  100877:	89 d0                	mov    %edx,%eax
+  100879:	01 c0                	add    %eax,%eax
+  10087b:	01 d0                	add    %edx,%eax
+  10087d:	c1 e0 02             	shl    $0x2,%eax
+  100880:	89 c2                	mov    %eax,%edx
+  100882:	8b 45 f4             	mov    -0xc(%ebp),%eax
+  100885:	01 d0                	add    %edx,%eax
+  100887:	8b 10                	mov    (%eax),%edx
+  100889:	8b 4d e8             	mov    -0x18(%ebp),%ecx
+  10088c:	8b 45 ec             	mov    -0x14(%ebp),%eax
+  10088f:	29 c1                	sub    %eax,%ecx
+  100891:	89 c8                	mov    %ecx,%eax
+  100893:	39 c2                	cmp    %eax,%edx
+  100895:	73 21                	jae    1008b8 <debuginfo_eip+0x2e2>
+        info->eip_file = stabstr + stabs[lline].n_strx;
+  100897:	8b 45 d4             	mov    -0x2c(%ebp),%eax
+  10089a:	89 c2                	mov    %eax,%edx
+  10089c:	89 d0                	mov    %edx,%eax
+  10089e:	01 c0                	add    %eax,%eax
+  1008a0:	01 d0                	add    %edx,%eax
+  1008a2:	c1 e0 02             	shl    $0x2,%eax
+  1008a5:	89 c2                	mov    %eax,%edx
+  1008a7:	8b 45 f4             	mov    -0xc(%ebp),%eax
+  1008aa:	01 d0                	add    %edx,%eax
+  1008ac:	8b 10                	mov    (%eax),%edx
+  1008ae:	8b 45 ec             	mov    -0x14(%ebp),%eax
+  1008b1:	01 c2                	add    %eax,%edx
+  1008b3:	8b 45 0c             	mov    0xc(%ebp),%eax
+  1008b6:	89 10                	mov    %edx,(%eax)
+    }
+
+    // Set eip_fn_narg to the number of arguments taken by the function,
+    // or 0 if there was no containing function.
+    if (lfun < rfun) {
+  1008b8:	8b 55 dc             	mov    -0x24(%ebp),%edx
+  1008bb:	8b 45 d8             	mov    -0x28(%ebp),%eax
+  1008be:	39 c2                	cmp    %eax,%edx
+  1008c0:	7d 4a                	jge    10090c <debuginfo_eip+0x336>
+        for (lline = lfun + 1;
+  1008c2:	8b 45 dc             	mov    -0x24(%ebp),%eax
+  1008c5:	83 c0 01             	add    $0x1,%eax
+  1008c8:	89 45 d4             	mov    %eax,-0x2c(%ebp)
+  1008cb:	eb 18                	jmp    1008e5 <debuginfo_eip+0x30f>
+             lline < rfun && stabs[lline].n_type == N_PSYM;
+             lline ++) {
+            info->eip_fn_narg ++;
+  1008cd:	8b 45 0c             	mov    0xc(%ebp),%eax
+  1008d0:	8b 40 14             	mov    0x14(%eax),%eax
+  1008d3:	8d 50 01             	lea    0x1(%eax),%edx
+  1008d6:	8b 45 0c             	mov    0xc(%ebp),%eax
+  1008d9:	89 50 14             	mov    %edx,0x14(%eax)
+             lline ++) {
+  1008dc:	8b 45 d4             	mov    -0x2c(%ebp),%eax
+  1008df:	83 c0 01             	add    $0x1,%eax
+  1008e2:	89 45 d4             	mov    %eax,-0x2c(%ebp)
+             lline < rfun && stabs[lline].n_type == N_PSYM;
+  1008e5:	8b 55 d4             	mov    -0x2c(%ebp),%edx
+  1008e8:	8b 45 d8             	mov    -0x28(%ebp),%eax
+        for (lline = lfun + 1;
+  1008eb:	39 c2                	cmp    %eax,%edx
+  1008ed:	7d 1d                	jge    10090c <debuginfo_eip+0x336>
+             lline < rfun && stabs[lline].n_type == N_PSYM;
+  1008ef:	8b 45 d4             	mov    -0x2c(%ebp),%eax
+  1008f2:	89 c2                	mov    %eax,%edx
+  1008f4:	89 d0                	mov    %edx,%eax
+  1008f6:	01 c0                	add    %eax,%eax
+  1008f8:	01 d0                	add    %edx,%eax
+  1008fa:	c1 e0 02             	shl    $0x2,%eax
+  1008fd:	89 c2                	mov    %eax,%edx
+  1008ff:	8b 45 f4             	mov    -0xc(%ebp),%eax
+  100902:	01 d0                	add    %edx,%eax
+  100904:	0f b6 40 04          	movzbl 0x4(%eax),%eax
+  100908:	3c a0                	cmp    $0xa0,%al
+  10090a:	74 c1                	je     1008cd <debuginfo_eip+0x2f7>
+        }
+    }
+    return 0;
+  10090c:	b8 00 00 00 00       	mov    $0x0,%eax
+}
+  100911:	c9                   	leave  
+  100912:	c3                   	ret    
+
+00100913 <print_kerninfo>:
+ * print_kerninfo - print the information about kernel, including the location
+ * of kernel entry, the start addresses of data and text segements, the start
+ * address of free memory and how many memory that kernel has used.
+ * */
+void
+print_kerninfo(void) {
+  100913:	55                   	push   %ebp
+  100914:	89 e5                	mov    %esp,%ebp
+  100916:	83 ec 18             	sub    $0x18,%esp
+    extern char etext[], edata[], end[], kern_init[];
+    cprintf("Special kernel symbols:\n");
+  100919:	c7 04 24 62 35 10 00 	movl   $0x103562,(%esp)
+  100920:	e8 37 f9 ff ff       	call   10025c <cprintf>
+    cprintf("  entry  0x%08x (phys)\n", kern_init);
+  100925:	c7 44 24 04 00 00 10 	movl   $0x100000,0x4(%esp)
+  10092c:	00 
+  10092d:	c7 04 24 7b 35 10 00 	movl   $0x10357b,(%esp)
+  100934:	e8 23 f9 ff ff       	call   10025c <cprintf>
+    cprintf("  etext  0x%08x (phys)\n", etext);
+  100939:	c7 44 24 04 5b 34 10 	movl   $0x10345b,0x4(%esp)
+  100940:	00 
+  100941:	c7 04 24 93 35 10 00 	movl   $0x103593,(%esp)
+  100948:	e8 0f f9 ff ff       	call   10025c <cprintf>
+    cprintf("  edata  0x%08x (phys)\n", edata);
+  10094d:	c7 44 24 04 16 ea 10 	movl   $0x10ea16,0x4(%esp)
+  100954:	00 
+  100955:	c7 04 24 ab 35 10 00 	movl   $0x1035ab,(%esp)
+  10095c:	e8 fb f8 ff ff       	call   10025c <cprintf>
+    cprintf("  end    0x%08x (phys)\n", end);
+  100961:	c7 44 24 04 40 fd 10 	movl   $0x10fd40,0x4(%esp)
+  100968:	00 
+  100969:	c7 04 24 c3 35 10 00 	movl   $0x1035c3,(%esp)
+  100970:	e8 e7 f8 ff ff       	call   10025c <cprintf>
+    cprintf("Kernel executable memory footprint: %dKB\n", (end - kern_init + 1023)/1024);
+  100975:	b8 40 fd 10 00       	mov    $0x10fd40,%eax
+  10097a:	8d 90 ff 03 00 00    	lea    0x3ff(%eax),%edx
+  100980:	b8 00 00 10 00       	mov    $0x100000,%eax
+  100985:	29 c2                	sub    %eax,%edx
+  100987:	89 d0                	mov    %edx,%eax
+  100989:	8d 90 ff 03 00 00    	lea    0x3ff(%eax),%edx
+  10098f:	85 c0                	test   %eax,%eax
+  100991:	0f 48 c2             	cmovs  %edx,%eax
+  100994:	c1 f8 0a             	sar    $0xa,%eax
+  100997:	89 44 24 04          	mov    %eax,0x4(%esp)
+  10099b:	c7 04 24 dc 35 10 00 	movl   $0x1035dc,(%esp)
+  1009a2:	e8 b5 f8 ff ff       	call   10025c <cprintf>
+}
+  1009a7:	c9                   	leave  
+  1009a8:	c3                   	ret    
+
+001009a9 <print_debuginfo>:
+/* *
+ * print_debuginfo - read and print the stat information for the address @eip,
+ * and info.eip_fn_addr should be the first address of the related function.
+ * */
+void
+print_debuginfo(uintptr_t eip) {
+  1009a9:	55                   	push   %ebp
+  1009aa:	89 e5                	mov    %esp,%ebp
+  1009ac:	81 ec 48 01 00 00    	sub    $0x148,%esp
+    struct eipdebuginfo info;
+    if (debuginfo_eip(eip, &info) != 0) {
+  1009b2:	8d 45 dc             	lea    -0x24(%ebp),%eax
+  1009b5:	89 44 24 04          	mov    %eax,0x4(%esp)
+  1009b9:	8b 45 08             	mov    0x8(%ebp),%eax
+  1009bc:	89 04 24             	mov    %eax,(%esp)
+  1009bf:	e8 12 fc ff ff       	call   1005d6 <debuginfo_eip>
+  1009c4:	85 c0                	test   %eax,%eax
+  1009c6:	74 15                	je     1009dd <print_debuginfo+0x34>
+        cprintf("    <unknow>: -- 0x%08x --\n", eip);
+  1009c8:	8b 45 08             	mov    0x8(%ebp),%eax
+  1009cb:	89 44 24 04          	mov    %eax,0x4(%esp)
+  1009cf:	c7 04 24 06 36 10 00 	movl   $0x103606,(%esp)
+  1009d6:	e8 81 f8 ff ff       	call   10025c <cprintf>
+  1009db:	eb 6d                	jmp    100a4a <print_debuginfo+0xa1>
+    }
+    else {
+        char fnname[256];
+        int j;
+        for (j = 0; j < info.eip_fn_namelen; j ++) {
+  1009dd:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
+  1009e4:	eb 1c                	jmp    100a02 <print_debuginfo+0x59>
+            fnname[j] = info.eip_fn_name[j];
+  1009e6:	8b 55 e4             	mov    -0x1c(%ebp),%edx
+  1009e9:	8b 45 f4             	mov    -0xc(%ebp),%eax
+  1009ec:	01 d0                	add    %edx,%eax
+  1009ee:	0f b6 00             	movzbl (%eax),%eax
+  1009f1:	8d 8d dc fe ff ff    	lea    -0x124(%ebp),%ecx
+  1009f7:	8b 55 f4             	mov    -0xc(%ebp),%edx
+  1009fa:	01 ca                	add    %ecx,%edx
+  1009fc:	88 02                	mov    %al,(%edx)
+        for (j = 0; j < info.eip_fn_namelen; j ++) {
+  1009fe:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
+  100a02:	8b 45 e8             	mov    -0x18(%ebp),%eax
+  100a05:	3b 45 f4             	cmp    -0xc(%ebp),%eax
+  100a08:	7f dc                	jg     1009e6 <print_debuginfo+0x3d>
+        }
+        fnname[j] = '\0';
+  100a0a:	8d 95 dc fe ff ff    	lea    -0x124(%ebp),%edx
+  100a10:	8b 45 f4             	mov    -0xc(%ebp),%eax
+  100a13:	01 d0                	add    %edx,%eax
+  100a15:	c6 00 00             	movb   $0x0,(%eax)
+        cprintf("    %s:%d: %s+%d\n", info.eip_file, info.eip_line,
+                fnname, eip - info.eip_fn_addr);
+  100a18:	8b 45 ec             	mov    -0x14(%ebp),%eax
+        cprintf("    %s:%d: %s+%d\n", info.eip_file, info.eip_line,
+  100a1b:	8b 55 08             	mov    0x8(%ebp),%edx
+  100a1e:	89 d1                	mov    %edx,%ecx
+  100a20:	29 c1                	sub    %eax,%ecx
+  100a22:	8b 55 e0             	mov    -0x20(%ebp),%edx
+  100a25:	8b 45 dc             	mov    -0x24(%ebp),%eax
+  100a28:	89 4c 24 10          	mov    %ecx,0x10(%esp)
+  100a2c:	8d 8d dc fe ff ff    	lea    -0x124(%ebp),%ecx
+  100a32:	89 4c 24 0c          	mov    %ecx,0xc(%esp)
+  100a36:	89 54 24 08          	mov    %edx,0x8(%esp)
+  100a3a:	89 44 24 04          	mov    %eax,0x4(%esp)
+  100a3e:	c7 04 24 22 36 10 00 	movl   $0x103622,(%esp)
+  100a45:	e8 12 f8 ff ff       	call   10025c <cprintf>
+    }
+}
+  100a4a:	c9                   	leave  
+  100a4b:	c3                   	ret    
+
+00100a4c <read_eip>:
+
+static __noinline uint32_t
+read_eip(void) {
+  100a4c:	55                   	push   %ebp
+  100a4d:	89 e5                	mov    %esp,%ebp
+  100a4f:	83 ec 10             	sub    $0x10,%esp
+    uint32_t eip;
+    asm volatile("movl 4(%%ebp), %0" : "=r" (eip));
+  100a52:	8b 45 04             	mov    0x4(%ebp),%eax
+  100a55:	89 45 fc             	mov    %eax,-0x4(%ebp)
+    return eip;
+  100a58:	8b 45 fc             	mov    -0x4(%ebp),%eax
+}
+  100a5b:	c9                   	leave  
+  100a5c:	c3                   	ret    
+
+00100a5d <print_stackframe>:
+ *
+ * Note that, the length of ebp-chain is limited. In boot/bootasm.S, before jumping
+ * to the kernel entry, the value of ebp has been set to zero, that's the boundary.
+ * */
+void
+print_stackframe(void) {
+  100a5d:	55                   	push   %ebp
+  100a5e:	89 e5                	mov    %esp,%ebp
+  100a60:	53                   	push   %ebx
+  100a61:	83 ec 44             	sub    $0x44,%esp
+}
+
+static inline uint32_t
+read_ebp(void) {
+    uint32_t ebp;
+    asm volatile ("movl %%ebp, %0" : "=r" (ebp));
+  100a64:	89 e8                	mov    %ebp,%eax
+  100a66:	89 45 e4             	mov    %eax,-0x1c(%ebp)
+    return ebp;
+  100a69:	8b 45 e4             	mov    -0x1c(%ebp),%eax
+      *    (3.4) call print_debuginfo(eip-1) to print the C calling function name and line number, etc.
+      *    (3.5) popup a calling stackframe
+      *           NOTICE: the calling funciton's return addr eip  = ss:[ebp+4]
+      *                   the calling funciton's ebp = ss:[ebp]
+      */
+	uint32_t ebp = read_ebp();
+  100a6c:	89 45 f4             	mov    %eax,-0xc(%ebp)
+	uint32_t eip = read_eip();
+  100a6f:	e8 d8 ff ff ff       	call   100a4c <read_eip>
+  100a74:	89 45 f0             	mov    %eax,-0x10(%ebp)
+	int i;
+	for(i = 0;i < STACKFRAME_DEPTH;i++){
+  100a77:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
+  100a7e:	e9 a1 00 00 00       	jmp    100b24 <print_stackframe+0xc7>
+		cprintf("ebp:0x%08x eip:0x%08x ",ebp,eip);
+  100a83:	8b 45 f0             	mov    -0x10(%ebp),%eax
+  100a86:	89 44 24 08          	mov    %eax,0x8(%esp)
+  100a8a:	8b 45 f4             	mov    -0xc(%ebp),%eax
+  100a8d:	89 44 24 04          	mov    %eax,0x4(%esp)
+  100a91:	c7 04 24 34 36 10 00 	movl   $0x103634,(%esp)
+  100a98:	e8 bf f7 ff ff       	call   10025c <cprintf>
+		cprintf("args:");
+  100a9d:	c7 04 24 4b 36 10 00 	movl   $0x10364b,(%esp)
+  100aa4:	e8 b3 f7 ff ff       	call   10025c <cprintf>
+		uint32_t *args = (uint32_t *)ebp + 2;
+  100aa9:	8b 45 f4             	mov    -0xc(%ebp),%eax
+  100aac:	83 c0 08             	add    $0x8,%eax
+  100aaf:	89 45 e8             	mov    %eax,-0x18(%ebp)
+		cprintf("0x%08x 0x%08x 0x%08x 0x%08x",args[0],args[1],args[2],args[3]);
+  100ab2:	8b 45 e8             	mov    -0x18(%ebp),%eax
+  100ab5:	83 c0 0c             	add    $0xc,%eax
+  100ab8:	8b 18                	mov    (%eax),%ebx
+  100aba:	8b 45 e8             	mov    -0x18(%ebp),%eax
+  100abd:	83 c0 08             	add    $0x8,%eax
+  100ac0:	8b 08                	mov    (%eax),%ecx
+  100ac2:	8b 45 e8             	mov    -0x18(%ebp),%eax
+  100ac5:	83 c0 04             	add    $0x4,%eax
+  100ac8:	8b 10                	mov    (%eax),%edx
+  100aca:	8b 45 e8             	mov    -0x18(%ebp),%eax
+  100acd:	8b 00                	mov    (%eax),%eax
+  100acf:	89 5c 24 10          	mov    %ebx,0x10(%esp)
+  100ad3:	89 4c 24 0c          	mov    %ecx,0xc(%esp)
+  100ad7:	89 54 24 08          	mov    %edx,0x8(%esp)
+  100adb:	89 44 24 04          	mov    %eax,0x4(%esp)
+  100adf:	c7 04 24 51 36 10 00 	movl   $0x103651,(%esp)
+  100ae6:	e8 71 f7 ff ff       	call   10025c <cprintf>
+		cprintf("\n");
+  100aeb:	c7 04 24 6d 36 10 00 	movl   $0x10366d,(%esp)
+  100af2:	e8 65 f7 ff ff       	call   10025c <cprintf>
+		print_debuginfo(eip - 1);
+  100af7:	8b 45 f0             	mov    -0x10(%ebp),%eax
+  100afa:	83 e8 01             	sub    $0x1,%eax
+  100afd:	89 04 24             	mov    %eax,(%esp)
+  100b00:	e8 a4 fe ff ff       	call   1009a9 <print_debuginfo>
+		eip =  ((uint32_t *) ebp)[1];
+  100b05:	8b 45 f4             	mov    -0xc(%ebp),%eax
+  100b08:	83 c0 04             	add    $0x4,%eax
+  100b0b:	8b 00                	mov    (%eax),%eax
+  100b0d:	89 45 f0             	mov    %eax,-0x10(%ebp)
+		ebp = ((uint32_t *) ebp)[0];
+  100b10:	8b 45 f4             	mov    -0xc(%ebp),%eax
+  100b13:	8b 00                	mov    (%eax),%eax
+  100b15:	89 45 f4             	mov    %eax,-0xc(%ebp)
+		if(ebp == 0) break;
+  100b18:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
+  100b1c:	75 02                	jne    100b20 <print_stackframe+0xc3>
+  100b1e:	eb 0e                	jmp    100b2e <print_stackframe+0xd1>
+	for(i = 0;i < STACKFRAME_DEPTH;i++){
+  100b20:	83 45 ec 01          	addl   $0x1,-0x14(%ebp)
+  100b24:	83 7d ec 13          	cmpl   $0x13,-0x14(%ebp)
+  100b28:	0f 8e 55 ff ff ff    	jle    100a83 <print_stackframe+0x26>
+	}
+}
+  100b2e:	83 c4 44             	add    $0x44,%esp
+  100b31:	5b                   	pop    %ebx
+  100b32:	5d                   	pop    %ebp
+  100b33:	c3                   	ret    
+
+00100b34 <parse>:
+#define MAXARGS         16
+#define WHITESPACE      " \t\n\r"
+
+/* parse - parse the command buffer into whitespace-separated arguments */
+static int
+parse(char *buf, char **argv) {
+  100b34:	55                   	push   %ebp
+  100b35:	89 e5                	mov    %esp,%ebp
+  100b37:	83 ec 28             	sub    $0x28,%esp
+    int argc = 0;
+  100b3a:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
+    while (1) {
+        // find global whitespace
+        while (*buf != '\0' && strchr(WHITESPACE, *buf) != NULL) {
+  100b41:	eb 0c                	jmp    100b4f <parse+0x1b>
+            *buf ++ = '\0';
+  100b43:	8b 45 08             	mov    0x8(%ebp),%eax
+  100b46:	8d 50 01             	lea    0x1(%eax),%edx
+  100b49:	89 55 08             	mov    %edx,0x8(%ebp)
+  100b4c:	c6 00 00             	movb   $0x0,(%eax)
+        while (*buf != '\0' && strchr(WHITESPACE, *buf) != NULL) {
+  100b4f:	8b 45 08             	mov    0x8(%ebp),%eax
+  100b52:	0f b6 00             	movzbl (%eax),%eax
+  100b55:	84 c0                	test   %al,%al
+  100b57:	74 1d                	je     100b76 <parse+0x42>
+  100b59:	8b 45 08             	mov    0x8(%ebp),%eax
+  100b5c:	0f b6 00             	movzbl (%eax),%eax
+  100b5f:	0f be c0             	movsbl %al,%eax
+  100b62:	89 44 24 04          	mov    %eax,0x4(%esp)
+  100b66:	c7 04 24 f0 36 10 00 	movl   $0x1036f0,(%esp)
+  100b6d:	e8 20 1f 00 00       	call   102a92 <strchr>
+  100b72:	85 c0                	test   %eax,%eax
+  100b74:	75 cd                	jne    100b43 <parse+0xf>
+        }
+        if (*buf == '\0') {
+  100b76:	8b 45 08             	mov    0x8(%ebp),%eax
+  100b79:	0f b6 00             	movzbl (%eax),%eax
+  100b7c:	84 c0                	test   %al,%al
+  100b7e:	75 02                	jne    100b82 <parse+0x4e>
+            break;
+  100b80:	eb 67                	jmp    100be9 <parse+0xb5>
+        }
+
+        // save and scan past next arg
+        if (argc == MAXARGS - 1) {
+  100b82:	83 7d f4 0f          	cmpl   $0xf,-0xc(%ebp)
+  100b86:	75 14                	jne    100b9c <parse+0x68>
+            cprintf("Too many arguments (max %d).\n", MAXARGS);
+  100b88:	c7 44 24 04 10 00 00 	movl   $0x10,0x4(%esp)
+  100b8f:	00 
+  100b90:	c7 04 24 f5 36 10 00 	movl   $0x1036f5,(%esp)
+  100b97:	e8 c0 f6 ff ff       	call   10025c <cprintf>
+        }
+        argv[argc ++] = buf;
+  100b9c:	8b 45 f4             	mov    -0xc(%ebp),%eax
+  100b9f:	8d 50 01             	lea    0x1(%eax),%edx
+  100ba2:	89 55 f4             	mov    %edx,-0xc(%ebp)
+  100ba5:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
+  100bac:	8b 45 0c             	mov    0xc(%ebp),%eax
+  100baf:	01 c2                	add    %eax,%edx
+  100bb1:	8b 45 08             	mov    0x8(%ebp),%eax
+  100bb4:	89 02                	mov    %eax,(%edx)
+        while (*buf != '\0' && strchr(WHITESPACE, *buf) == NULL) {
+  100bb6:	eb 04                	jmp    100bbc <parse+0x88>
+            buf ++;
+  100bb8:	83 45 08 01          	addl   $0x1,0x8(%ebp)
+        while (*buf != '\0' && strchr(WHITESPACE, *buf) == NULL) {
+  100bbc:	8b 45 08             	mov    0x8(%ebp),%eax
+  100bbf:	0f b6 00             	movzbl (%eax),%eax
+  100bc2:	84 c0                	test   %al,%al
+  100bc4:	74 1d                	je     100be3 <parse+0xaf>
+  100bc6:	8b 45 08             	mov    0x8(%ebp),%eax
+  100bc9:	0f b6 00             	movzbl (%eax),%eax
+  100bcc:	0f be c0             	movsbl %al,%eax
+  100bcf:	89 44 24 04          	mov    %eax,0x4(%esp)
+  100bd3:	c7 04 24 f0 36 10 00 	movl   $0x1036f0,(%esp)
+  100bda:	e8 b3 1e 00 00       	call   102a92 <strchr>
+  100bdf:	85 c0                	test   %eax,%eax
+  100be1:	74 d5                	je     100bb8 <parse+0x84>
+        }
+    }
+  100be3:	90                   	nop
+        while (*buf != '\0' && strchr(WHITESPACE, *buf) != NULL) {
+  100be4:	e9 66 ff ff ff       	jmp    100b4f <parse+0x1b>
+    return argc;
+  100be9:	8b 45 f4             	mov    -0xc(%ebp),%eax
+}
+  100bec:	c9                   	leave  
+  100bed:	c3                   	ret    
+
+00100bee <runcmd>:
+/* *
+ * runcmd - parse the input string, split it into separated arguments
+ * and then lookup and invoke some related commands/
+ * */
+static int
+runcmd(char *buf, struct trapframe *tf) {
+  100bee:	55                   	push   %ebp
+  100bef:	89 e5                	mov    %esp,%ebp
+  100bf1:	83 ec 68             	sub    $0x68,%esp
+    char *argv[MAXARGS];
+    int argc = parse(buf, argv);
+  100bf4:	8d 45 b0             	lea    -0x50(%ebp),%eax
+  100bf7:	89 44 24 04          	mov    %eax,0x4(%esp)
+  100bfb:	8b 45 08             	mov    0x8(%ebp),%eax
+  100bfe:	89 04 24             	mov    %eax,(%esp)
+  100c01:	e8 2e ff ff ff       	call   100b34 <parse>
+  100c06:	89 45 f0             	mov    %eax,-0x10(%ebp)
+    if (argc == 0) {
+  100c09:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
+  100c0d:	75 0a                	jne    100c19 <runcmd+0x2b>
+        return 0;
+  100c0f:	b8 00 00 00 00       	mov    $0x0,%eax
+  100c14:	e9 85 00 00 00       	jmp    100c9e <runcmd+0xb0>
+    }
+    int i;
+    for (i = 0; i < NCOMMANDS; i ++) {
+  100c19:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
+  100c20:	eb 5c                	jmp    100c7e <runcmd+0x90>
+        if (strcmp(commands[i].name, argv[0]) == 0) {
+  100c22:	8b 4d b0             	mov    -0x50(%ebp),%ecx
+  100c25:	8b 55 f4             	mov    -0xc(%ebp),%edx
+  100c28:	89 d0                	mov    %edx,%eax
+  100c2a:	01 c0                	add    %eax,%eax
+  100c2c:	01 d0                	add    %edx,%eax
+  100c2e:	c1 e0 02             	shl    $0x2,%eax
+  100c31:	05 00 e0 10 00       	add    $0x10e000,%eax
+  100c36:	8b 00                	mov    (%eax),%eax
+  100c38:	89 4c 24 04          	mov    %ecx,0x4(%esp)
+  100c3c:	89 04 24             	mov    %eax,(%esp)
+  100c3f:	e8 af 1d 00 00       	call   1029f3 <strcmp>
+  100c44:	85 c0                	test   %eax,%eax
+  100c46:	75 32                	jne    100c7a <runcmd+0x8c>
+            return commands[i].func(argc - 1, argv + 1, tf);
+  100c48:	8b 55 f4             	mov    -0xc(%ebp),%edx
+  100c4b:	89 d0                	mov    %edx,%eax
+  100c4d:	01 c0                	add    %eax,%eax
+  100c4f:	01 d0                	add    %edx,%eax
+  100c51:	c1 e0 02             	shl    $0x2,%eax
+  100c54:	05 00 e0 10 00       	add    $0x10e000,%eax
+  100c59:	8b 40 08             	mov    0x8(%eax),%eax
+  100c5c:	8b 55 f0             	mov    -0x10(%ebp),%edx
+  100c5f:	8d 4a ff             	lea    -0x1(%edx),%ecx
+  100c62:	8b 55 0c             	mov    0xc(%ebp),%edx
+  100c65:	89 54 24 08          	mov    %edx,0x8(%esp)
+  100c69:	8d 55 b0             	lea    -0x50(%ebp),%edx
+  100c6c:	83 c2 04             	add    $0x4,%edx
+  100c6f:	89 54 24 04          	mov    %edx,0x4(%esp)
+  100c73:	89 0c 24             	mov    %ecx,(%esp)
+  100c76:	ff d0                	call   *%eax
+  100c78:	eb 24                	jmp    100c9e <runcmd+0xb0>
+    for (i = 0; i < NCOMMANDS; i ++) {
+  100c7a:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
+  100c7e:	8b 45 f4             	mov    -0xc(%ebp),%eax
+  100c81:	83 f8 02             	cmp    $0x2,%eax
+  100c84:	76 9c                	jbe    100c22 <runcmd+0x34>
+        }
+    }
+    cprintf("Unknown command '%s'\n", argv[0]);
+  100c86:	8b 45 b0             	mov    -0x50(%ebp),%eax
+  100c89:	89 44 24 04          	mov    %eax,0x4(%esp)
+  100c8d:	c7 04 24 13 37 10 00 	movl   $0x103713,(%esp)
+  100c94:	e8 c3 f5 ff ff       	call   10025c <cprintf>
+    return 0;
+  100c99:	b8 00 00 00 00       	mov    $0x0,%eax
+}
+  100c9e:	c9                   	leave  
+  100c9f:	c3                   	ret    
+
+00100ca0 <kmonitor>:
+
+/***** Implementations of basic kernel monitor commands *****/
+
+void
+kmonitor(struct trapframe *tf) {
+  100ca0:	55                   	push   %ebp
+  100ca1:	89 e5                	mov    %esp,%ebp
+  100ca3:	83 ec 28             	sub    $0x28,%esp
+    cprintf("Welcome to the kernel debug monitor!!\n");
+  100ca6:	c7 04 24 2c 37 10 00 	movl   $0x10372c,(%esp)
+  100cad:	e8 aa f5 ff ff       	call   10025c <cprintf>
+    cprintf("Type 'help' for a list of commands.\n");
+  100cb2:	c7 04 24 54 37 10 00 	movl   $0x103754,(%esp)
+  100cb9:	e8 9e f5 ff ff       	call   10025c <cprintf>
+
+    if (tf != NULL) {
+  100cbe:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
+  100cc2:	74 0b                	je     100ccf <kmonitor+0x2f>
+        print_trapframe(tf);
+  100cc4:	8b 45 08             	mov    0x8(%ebp),%eax
+  100cc7:	89 04 24             	mov    %eax,(%esp)
+  100cca:	e8 c1 0c 00 00       	call   101990 <print_trapframe>
+    }
+
+    char *buf;
+    while (1) {
+        if ((buf = readline("K> ")) != NULL) {
+  100ccf:	c7 04 24 79 37 10 00 	movl   $0x103779,(%esp)
+  100cd6:	e8 22 f6 ff ff       	call   1002fd <readline>
+  100cdb:	89 45 f4             	mov    %eax,-0xc(%ebp)
+  100cde:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
+  100ce2:	74 18                	je     100cfc <kmonitor+0x5c>
+            if (runcmd(buf, tf) < 0) {
+  100ce4:	8b 45 08             	mov    0x8(%ebp),%eax
+  100ce7:	89 44 24 04          	mov    %eax,0x4(%esp)
+  100ceb:	8b 45 f4             	mov    -0xc(%ebp),%eax
+  100cee:	89 04 24             	mov    %eax,(%esp)
+  100cf1:	e8 f8 fe ff ff       	call   100bee <runcmd>
+  100cf6:	85 c0                	test   %eax,%eax
+  100cf8:	79 02                	jns    100cfc <kmonitor+0x5c>
+                break;
+  100cfa:	eb 02                	jmp    100cfe <kmonitor+0x5e>
+            }
+        }
+    }
+  100cfc:	eb d1                	jmp    100ccf <kmonitor+0x2f>
+}
+  100cfe:	c9                   	leave  
+  100cff:	c3                   	ret    
+
+00100d00 <mon_help>:
+
+/* mon_help - print the information about mon_* functions */
+int
+mon_help(int argc, char **argv, struct trapframe *tf) {
+  100d00:	55                   	push   %ebp
+  100d01:	89 e5                	mov    %esp,%ebp
+  100d03:	83 ec 28             	sub    $0x28,%esp
+    int i;
+    for (i = 0; i < NCOMMANDS; i ++) {
+  100d06:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
+  100d0d:	eb 3f                	jmp    100d4e <mon_help+0x4e>
+        cprintf("%s - %s\n", commands[i].name, commands[i].desc);
+  100d0f:	8b 55 f4             	mov    -0xc(%ebp),%edx
+  100d12:	89 d0                	mov    %edx,%eax
+  100d14:	01 c0                	add    %eax,%eax
+  100d16:	01 d0                	add    %edx,%eax
+  100d18:	c1 e0 02             	shl    $0x2,%eax
+  100d1b:	05 00 e0 10 00       	add    $0x10e000,%eax
+  100d20:	8b 48 04             	mov    0x4(%eax),%ecx
+  100d23:	8b 55 f4             	mov    -0xc(%ebp),%edx
+  100d26:	89 d0                	mov    %edx,%eax
+  100d28:	01 c0                	add    %eax,%eax
+  100d2a:	01 d0                	add    %edx,%eax
+  100d2c:	c1 e0 02             	shl    $0x2,%eax
+  100d2f:	05 00 e0 10 00       	add    $0x10e000,%eax
+  100d34:	8b 00                	mov    (%eax),%eax
+  100d36:	89 4c 24 08          	mov    %ecx,0x8(%esp)
+  100d3a:	89 44 24 04          	mov    %eax,0x4(%esp)
+  100d3e:	c7 04 24 7d 37 10 00 	movl   $0x10377d,(%esp)
+  100d45:	e8 12 f5 ff ff       	call   10025c <cprintf>
+    for (i = 0; i < NCOMMANDS; i ++) {
+  100d4a:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
+  100d4e:	8b 45 f4             	mov    -0xc(%ebp),%eax
+  100d51:	83 f8 02             	cmp    $0x2,%eax
+  100d54:	76 b9                	jbe    100d0f <mon_help+0xf>
+    }
+    return 0;
+  100d56:	b8 00 00 00 00       	mov    $0x0,%eax
+}
+  100d5b:	c9                   	leave  
+  100d5c:	c3                   	ret    
+
+00100d5d <mon_kerninfo>:
+/* *
+ * mon_kerninfo - call print_kerninfo in kern/debug/kdebug.c to
+ * print the memory occupancy in kernel.
+ * */
+int
+mon_kerninfo(int argc, char **argv, struct trapframe *tf) {
+  100d5d:	55                   	push   %ebp
+  100d5e:	89 e5                	mov    %esp,%ebp
+  100d60:	83 ec 08             	sub    $0x8,%esp
+    print_kerninfo();
+  100d63:	e8 ab fb ff ff       	call   100913 <print_kerninfo>
+    return 0;
+  100d68:	b8 00 00 00 00       	mov    $0x0,%eax
+}
+  100d6d:	c9                   	leave  
+  100d6e:	c3                   	ret    
+
+00100d6f <mon_backtrace>:
+/* *
+ * mon_backtrace - call print_stackframe in kern/debug/kdebug.c to
+ * print a backtrace of the stack.
+ * */
+int
+mon_backtrace(int argc, char **argv, struct trapframe *tf) {
+  100d6f:	55                   	push   %ebp
+  100d70:	89 e5                	mov    %esp,%ebp
+  100d72:	83 ec 08             	sub    $0x8,%esp
+    print_stackframe();
+  100d75:	e8 e3 fc ff ff       	call   100a5d <print_stackframe>
+    return 0;
+  100d7a:	b8 00 00 00 00       	mov    $0x0,%eax
+}
+  100d7f:	c9                   	leave  
+  100d80:	c3                   	ret    
+
+00100d81 <clock_init>:
+/* *
+ * clock_init - initialize 8253 clock to interrupt 100 times per second,
+ * and then enable IRQ_TIMER.
+ * */
+void
+clock_init(void) {
+  100d81:	55                   	push   %ebp
+  100d82:	89 e5                	mov    %esp,%ebp
+  100d84:	83 ec 28             	sub    $0x28,%esp
+  100d87:	66 c7 45 f6 43 00    	movw   $0x43,-0xa(%ebp)
+  100d8d:	c6 45 f5 34          	movb   $0x34,-0xb(%ebp)
+    asm volatile ("outb %0, %1" :: "a" (data), "d" (port));
+  100d91:	0f b6 45 f5          	movzbl -0xb(%ebp),%eax
+  100d95:	0f b7 55 f6          	movzwl -0xa(%ebp),%edx
+  100d99:	ee                   	out    %al,(%dx)
+  100d9a:	66 c7 45 f2 40 00    	movw   $0x40,-0xe(%ebp)
+  100da0:	c6 45 f1 9c          	movb   $0x9c,-0xf(%ebp)
+  100da4:	0f b6 45 f1          	movzbl -0xf(%ebp),%eax
+  100da8:	0f b7 55 f2          	movzwl -0xe(%ebp),%edx
+  100dac:	ee                   	out    %al,(%dx)
+  100dad:	66 c7 45 ee 40 00    	movw   $0x40,-0x12(%ebp)
+  100db3:	c6 45 ed 2e          	movb   $0x2e,-0x13(%ebp)
+  100db7:	0f b6 45 ed          	movzbl -0x13(%ebp),%eax
+  100dbb:	0f b7 55 ee          	movzwl -0x12(%ebp),%edx
+  100dbf:	ee                   	out    %al,(%dx)
+    outb(TIMER_MODE, TIMER_SEL0 | TIMER_RATEGEN | TIMER_16BIT);
+    outb(IO_TIMER1, TIMER_DIV(100) % 256);
+    outb(IO_TIMER1, TIMER_DIV(100) / 256);
+
+    // initialize time counter 'ticks' to zero
+    ticks = 0;
+  100dc0:	c7 05 28 f9 10 00 00 	movl   $0x0,0x10f928
+  100dc7:	00 00 00 
+
+    cprintf("++ setup timer interrupts\n");
+  100dca:	c7 04 24 86 37 10 00 	movl   $0x103786,(%esp)
+  100dd1:	e8 86 f4 ff ff       	call   10025c <cprintf>
+    pic_enable(IRQ_TIMER);
+  100dd6:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
+  100ddd:	e8 b5 08 00 00       	call   101697 <pic_enable>
+}
+  100de2:	c9                   	leave  
+  100de3:	c3                   	ret    
+
+00100de4 <delay>:
+#include <picirq.h>
+#include <trap.h>
+
+/* stupid I/O delay routine necessitated by historical PC design flaws */
+static void
+delay(void) {
+  100de4:	55                   	push   %ebp
+  100de5:	89 e5                	mov    %esp,%ebp
+  100de7:	83 ec 10             	sub    $0x10,%esp
+  100dea:	66 c7 45 fe 84 00    	movw   $0x84,-0x2(%ebp)
+    asm volatile ("inb %1, %0" : "=a" (data) : "d" (port));
+  100df0:	0f b7 45 fe          	movzwl -0x2(%ebp),%eax
+  100df4:	89 c2                	mov    %eax,%edx
+  100df6:	ec                   	in     (%dx),%al
+  100df7:	88 45 fd             	mov    %al,-0x3(%ebp)
+  100dfa:	66 c7 45 fa 84 00    	movw   $0x84,-0x6(%ebp)
+  100e00:	0f b7 45 fa          	movzwl -0x6(%ebp),%eax
+  100e04:	89 c2                	mov    %eax,%edx
+  100e06:	ec                   	in     (%dx),%al
+  100e07:	88 45 f9             	mov    %al,-0x7(%ebp)
+  100e0a:	66 c7 45 f6 84 00    	movw   $0x84,-0xa(%ebp)
+  100e10:	0f b7 45 f6          	movzwl -0xa(%ebp),%eax
+  100e14:	89 c2                	mov    %eax,%edx
+  100e16:	ec                   	in     (%dx),%al
+  100e17:	88 45 f5             	mov    %al,-0xb(%ebp)
+  100e1a:	66 c7 45 f2 84 00    	movw   $0x84,-0xe(%ebp)
+  100e20:	0f b7 45 f2          	movzwl -0xe(%ebp),%eax
+  100e24:	89 c2                	mov    %eax,%edx
+  100e26:	ec                   	in     (%dx),%al
+  100e27:	88 45 f1             	mov    %al,-0xf(%ebp)
+    inb(0x84);
+    inb(0x84);
+    inb(0x84);
+    inb(0x84);
+}
+  100e2a:	c9                   	leave  
+  100e2b:	c3                   	ret    
+
+00100e2c <cga_init>:
+//    -- 数据寄存器 映射 到 端口 0x3D5或0x3B5 
+//    -- 索引寄存器 0x3D4或0x3B4,决定在数据寄存器中的数据表示什么。
+
+/* TEXT-mode CGA/VGA display output */
+static void
+cga_init(void) {
+  100e2c:	55                   	push   %ebp
+  100e2d:	89 e5                	mov    %esp,%ebp
+  100e2f:	83 ec 20             	sub    $0x20,%esp
+    volatile uint16_t *cp = (uint16_t *)CGA_BUF;   //CGA_BUF: 0xB8000 (彩色显示的显存物理基址)
+  100e32:	c7 45 fc 00 80 0b 00 	movl   $0xb8000,-0x4(%ebp)
+    uint16_t was = *cp;                                            //保存当前显存0xB8000处的值
+  100e39:	8b 45 fc             	mov    -0x4(%ebp),%eax
+  100e3c:	0f b7 00             	movzwl (%eax),%eax
+  100e3f:	66 89 45 fa          	mov    %ax,-0x6(%ebp)
+    *cp = (uint16_t) 0xA55A;                                   // 给这个地址随便写个值，看看能否再读出同样的值
+  100e43:	8b 45 fc             	mov    -0x4(%ebp),%eax
+  100e46:	66 c7 00 5a a5       	movw   $0xa55a,(%eax)
+    if (*cp != 0xA55A) {                                            // 如果读不出来，说明没有这块显存，即是单显配置
+  100e4b:	8b 45 fc             	mov    -0x4(%ebp),%eax
+  100e4e:	0f b7 00             	movzwl (%eax),%eax
+  100e51:	66 3d 5a a5          	cmp    $0xa55a,%ax
+  100e55:	74 12                	je     100e69 <cga_init+0x3d>
+        cp = (uint16_t*)MONO_BUF;                         //设置为单显的显存基址 MONO_BUF： 0xB0000
+  100e57:	c7 45 fc 00 00 0b 00 	movl   $0xb0000,-0x4(%ebp)
+        addr_6845 = MONO_BASE;                           //设置为单显控制的IO地址，MONO_BASE: 0x3B4
+  100e5e:	66 c7 05 66 ee 10 00 	movw   $0x3b4,0x10ee66
+  100e65:	b4 03 
+  100e67:	eb 13                	jmp    100e7c <cga_init+0x50>
+    } else {                                                                // 如果读出来了，有这块显存，即是彩显配置
+        *cp = was;                                                      //还原原来显存位置的值
+  100e69:	8b 45 fc             	mov    -0x4(%ebp),%eax
+  100e6c:	0f b7 55 fa          	movzwl -0x6(%ebp),%edx
+  100e70:	66 89 10             	mov    %dx,(%eax)
+        addr_6845 = CGA_BASE;                               // 设置为彩显控制的IO地址，CGA_BASE: 0x3D4 
+  100e73:	66 c7 05 66 ee 10 00 	movw   $0x3d4,0x10ee66
+  100e7a:	d4 03 
+    // Extract cursor location
+    // 6845索引寄存器的index 0x0E（及十进制的14）== 光标位置(高位)
+    // 6845索引寄存器的index 0x0F（及十进制的15）== 光标位置(低位)
+    // 6845 reg 15 : Cursor Address (Low Byte)
+    uint32_t pos;
+    outb(addr_6845, 14);                                        
+  100e7c:	0f b7 05 66 ee 10 00 	movzwl 0x10ee66,%eax
+  100e83:	0f b7 c0             	movzwl %ax,%eax
+  100e86:	66 89 45 f2          	mov    %ax,-0xe(%ebp)
+  100e8a:	c6 45 f1 0e          	movb   $0xe,-0xf(%ebp)
+    asm volatile ("outb %0, %1" :: "a" (data), "d" (port));
+  100e8e:	0f b6 45 f1          	movzbl -0xf(%ebp),%eax
+  100e92:	0f b7 55 f2          	movzwl -0xe(%ebp),%edx
+  100e96:	ee                   	out    %al,(%dx)
+    pos = inb(addr_6845 + 1) << 8;                       //读出了光标位置(高位)
+  100e97:	0f b7 05 66 ee 10 00 	movzwl 0x10ee66,%eax
+  100e9e:	83 c0 01             	add    $0x1,%eax
+  100ea1:	0f b7 c0             	movzwl %ax,%eax
+  100ea4:	66 89 45 ee          	mov    %ax,-0x12(%ebp)
+    asm volatile ("inb %1, %0" : "=a" (data) : "d" (port));
+  100ea8:	0f b7 45 ee          	movzwl -0x12(%ebp),%eax
+  100eac:	89 c2                	mov    %eax,%edx
+  100eae:	ec                   	in     (%dx),%al
+  100eaf:	88 45 ed             	mov    %al,-0x13(%ebp)
+    return data;
+  100eb2:	0f b6 45 ed          	movzbl -0x13(%ebp),%eax
+  100eb6:	0f b6 c0             	movzbl %al,%eax
+  100eb9:	c1 e0 08             	shl    $0x8,%eax
+  100ebc:	89 45 f4             	mov    %eax,-0xc(%ebp)
+    outb(addr_6845, 15);
+  100ebf:	0f b7 05 66 ee 10 00 	movzwl 0x10ee66,%eax
+  100ec6:	0f b7 c0             	movzwl %ax,%eax
+  100ec9:	66 89 45 ea          	mov    %ax,-0x16(%ebp)
+  100ecd:	c6 45 e9 0f          	movb   $0xf,-0x17(%ebp)
+    asm volatile ("outb %0, %1" :: "a" (data), "d" (port));
+  100ed1:	0f b6 45 e9          	movzbl -0x17(%ebp),%eax
+  100ed5:	0f b7 55 ea          	movzwl -0x16(%ebp),%edx
+  100ed9:	ee                   	out    %al,(%dx)
+    pos |= inb(addr_6845 + 1);                             //读出了光标位置(低位)
+  100eda:	0f b7 05 66 ee 10 00 	movzwl 0x10ee66,%eax
+  100ee1:	83 c0 01             	add    $0x1,%eax
+  100ee4:	0f b7 c0             	movzwl %ax,%eax
+  100ee7:	66 89 45 e6          	mov    %ax,-0x1a(%ebp)
+    asm volatile ("inb %1, %0" : "=a" (data) : "d" (port));
+  100eeb:	0f b7 45 e6          	movzwl -0x1a(%ebp),%eax
+  100eef:	89 c2                	mov    %eax,%edx
+  100ef1:	ec                   	in     (%dx),%al
+  100ef2:	88 45 e5             	mov    %al,-0x1b(%ebp)
+    return data;
+  100ef5:	0f b6 45 e5          	movzbl -0x1b(%ebp),%eax
+  100ef9:	0f b6 c0             	movzbl %al,%eax
+  100efc:	09 45 f4             	or     %eax,-0xc(%ebp)
+
+    crt_buf = (uint16_t*) cp;                                  //crt_buf是CGA显存起始地址
+  100eff:	8b 45 fc             	mov    -0x4(%ebp),%eax
+  100f02:	a3 60 ee 10 00       	mov    %eax,0x10ee60
+    crt_pos = pos;                                                  //crt_pos是CGA当前光标位置
+  100f07:	8b 45 f4             	mov    -0xc(%ebp),%eax
+  100f0a:	66 a3 64 ee 10 00    	mov    %ax,0x10ee64
+}
+  100f10:	c9                   	leave  
+  100f11:	c3                   	ret    
+
+00100f12 <serial_init>:
+
+static bool serial_exists = 0;
+
+static void
+serial_init(void) {
+  100f12:	55                   	push   %ebp
+  100f13:	89 e5                	mov    %esp,%ebp
+  100f15:	83 ec 48             	sub    $0x48,%esp
+  100f18:	66 c7 45 f6 fa 03    	movw   $0x3fa,-0xa(%ebp)
+  100f1e:	c6 45 f5 00          	movb   $0x0,-0xb(%ebp)
+    asm volatile ("outb %0, %1" :: "a" (data), "d" (port));
+  100f22:	0f b6 45 f5          	movzbl -0xb(%ebp),%eax
+  100f26:	0f b7 55 f6          	movzwl -0xa(%ebp),%edx
+  100f2a:	ee                   	out    %al,(%dx)
+  100f2b:	66 c7 45 f2 fb 03    	movw   $0x3fb,-0xe(%ebp)
+  100f31:	c6 45 f1 80          	movb   $0x80,-0xf(%ebp)
+  100f35:	0f b6 45 f1          	movzbl -0xf(%ebp),%eax
+  100f39:	0f b7 55 f2          	movzwl -0xe(%ebp),%edx
+  100f3d:	ee                   	out    %al,(%dx)
+  100f3e:	66 c7 45 ee f8 03    	movw   $0x3f8,-0x12(%ebp)
+  100f44:	c6 45 ed 0c          	movb   $0xc,-0x13(%ebp)
+  100f48:	0f b6 45 ed          	movzbl -0x13(%ebp),%eax
+  100f4c:	0f b7 55 ee          	movzwl -0x12(%ebp),%edx
+  100f50:	ee                   	out    %al,(%dx)
+  100f51:	66 c7 45 ea f9 03    	movw   $0x3f9,-0x16(%ebp)
+  100f57:	c6 45 e9 00          	movb   $0x0,-0x17(%ebp)
+  100f5b:	0f b6 45 e9          	movzbl -0x17(%ebp),%eax
+  100f5f:	0f b7 55 ea          	movzwl -0x16(%ebp),%edx
+  100f63:	ee                   	out    %al,(%dx)
+  100f64:	66 c7 45 e6 fb 03    	movw   $0x3fb,-0x1a(%ebp)
+  100f6a:	c6 45 e5 03          	movb   $0x3,-0x1b(%ebp)
+  100f6e:	0f b6 45 e5          	movzbl -0x1b(%ebp),%eax
+  100f72:	0f b7 55 e6          	movzwl -0x1a(%ebp),%edx
+  100f76:	ee                   	out    %al,(%dx)
+  100f77:	66 c7 45 e2 fc 03    	movw   $0x3fc,-0x1e(%ebp)
+  100f7d:	c6 45 e1 00          	movb   $0x0,-0x1f(%ebp)
+  100f81:	0f b6 45 e1          	movzbl -0x1f(%ebp),%eax
+  100f85:	0f b7 55 e2          	movzwl -0x1e(%ebp),%edx
+  100f89:	ee                   	out    %al,(%dx)
+  100f8a:	66 c7 45 de f9 03    	movw   $0x3f9,-0x22(%ebp)
+  100f90:	c6 45 dd 01          	movb   $0x1,-0x23(%ebp)
+  100f94:	0f b6 45 dd          	movzbl -0x23(%ebp),%eax
+  100f98:	0f b7 55 de          	movzwl -0x22(%ebp),%edx
+  100f9c:	ee                   	out    %al,(%dx)
+  100f9d:	66 c7 45 da fd 03    	movw   $0x3fd,-0x26(%ebp)
+    asm volatile ("inb %1, %0" : "=a" (data) : "d" (port));
+  100fa3:	0f b7 45 da          	movzwl -0x26(%ebp),%eax
+  100fa7:	89 c2                	mov    %eax,%edx
+  100fa9:	ec                   	in     (%dx),%al
+  100faa:	88 45 d9             	mov    %al,-0x27(%ebp)
+    return data;
+  100fad:	0f b6 45 d9          	movzbl -0x27(%ebp),%eax
+    // Enable rcv interrupts
+    outb(COM1 + COM_IER, COM_IER_RDI);
+
+    // Clear any preexisting overrun indications and interrupts
+    // Serial port doesn't exist if COM_LSR returns 0xFF
+    serial_exists = (inb(COM1 + COM_LSR) != 0xFF);
+  100fb1:	3c ff                	cmp    $0xff,%al
+  100fb3:	0f 95 c0             	setne  %al
+  100fb6:	0f b6 c0             	movzbl %al,%eax
+  100fb9:	a3 68 ee 10 00       	mov    %eax,0x10ee68
+  100fbe:	66 c7 45 d6 fa 03    	movw   $0x3fa,-0x2a(%ebp)
+    asm volatile ("inb %1, %0" : "=a" (data) : "d" (port));
+  100fc4:	0f b7 45 d6          	movzwl -0x2a(%ebp),%eax
+  100fc8:	89 c2                	mov    %eax,%edx
+  100fca:	ec                   	in     (%dx),%al
+  100fcb:	88 45 d5             	mov    %al,-0x2b(%ebp)
+  100fce:	66 c7 45 d2 f8 03    	movw   $0x3f8,-0x2e(%ebp)
+  100fd4:	0f b7 45 d2          	movzwl -0x2e(%ebp),%eax
+  100fd8:	89 c2                	mov    %eax,%edx
+  100fda:	ec                   	in     (%dx),%al
+  100fdb:	88 45 d1             	mov    %al,-0x2f(%ebp)
+    (void) inb(COM1+COM_IIR);
+    (void) inb(COM1+COM_RX);
+
+    if (serial_exists) {
+  100fde:	a1 68 ee 10 00       	mov    0x10ee68,%eax
+  100fe3:	85 c0                	test   %eax,%eax
+  100fe5:	74 0c                	je     100ff3 <serial_init+0xe1>
+        pic_enable(IRQ_COM1);
+  100fe7:	c7 04 24 04 00 00 00 	movl   $0x4,(%esp)
+  100fee:	e8 a4 06 00 00       	call   101697 <pic_enable>
+    }
+}
+  100ff3:	c9                   	leave  
+  100ff4:	c3                   	ret    
+
+00100ff5 <lpt_putc_sub>:
+
+static void
+lpt_putc_sub(int c) {
+  100ff5:	55                   	push   %ebp
+  100ff6:	89 e5                	mov    %esp,%ebp
+  100ff8:	83 ec 20             	sub    $0x20,%esp
+    int i;
+    for (i = 0; !(inb(LPTPORT + 1) & 0x80) && i < 12800; i ++) {
+  100ffb:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
+  101002:	eb 09                	jmp    10100d <lpt_putc_sub+0x18>
+        delay();
+  101004:	e8 db fd ff ff       	call   100de4 <delay>
+    for (i = 0; !(inb(LPTPORT + 1) & 0x80) && i < 12800; i ++) {
+  101009:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
+  10100d:	66 c7 45 fa 79 03    	movw   $0x379,-0x6(%ebp)
+  101013:	0f b7 45 fa          	movzwl -0x6(%ebp),%eax
+  101017:	89 c2                	mov    %eax,%edx
+  101019:	ec                   	in     (%dx),%al
+  10101a:	88 45 f9             	mov    %al,-0x7(%ebp)
+    return data;
+  10101d:	0f b6 45 f9          	movzbl -0x7(%ebp),%eax
+  101021:	84 c0                	test   %al,%al
+  101023:	78 09                	js     10102e <lpt_putc_sub+0x39>
+  101025:	81 7d fc ff 31 00 00 	cmpl   $0x31ff,-0x4(%ebp)
+  10102c:	7e d6                	jle    101004 <lpt_putc_sub+0xf>
+    }
+    outb(LPTPORT + 0, c);
+  10102e:	8b 45 08             	mov    0x8(%ebp),%eax
+  101031:	0f b6 c0             	movzbl %al,%eax
+  101034:	66 c7 45 f6 78 03    	movw   $0x378,-0xa(%ebp)
+  10103a:	88 45 f5             	mov    %al,-0xb(%ebp)
+    asm volatile ("outb %0, %1" :: "a" (data), "d" (port));
+  10103d:	0f b6 45 f5          	movzbl -0xb(%ebp),%eax
+  101041:	0f b7 55 f6          	movzwl -0xa(%ebp),%edx
+  101045:	ee                   	out    %al,(%dx)
+  101046:	66 c7 45 f2 7a 03    	movw   $0x37a,-0xe(%ebp)
+  10104c:	c6 45 f1 0d          	movb   $0xd,-0xf(%ebp)
+  101050:	0f b6 45 f1          	movzbl -0xf(%ebp),%eax
+  101054:	0f b7 55 f2          	movzwl -0xe(%ebp),%edx
+  101058:	ee                   	out    %al,(%dx)
+  101059:	66 c7 45 ee 7a 03    	movw   $0x37a,-0x12(%ebp)
+  10105f:	c6 45 ed 08          	movb   $0x8,-0x13(%ebp)
+  101063:	0f b6 45 ed          	movzbl -0x13(%ebp),%eax
+  101067:	0f b7 55 ee          	movzwl -0x12(%ebp),%edx
+  10106b:	ee                   	out    %al,(%dx)
+    outb(LPTPORT + 2, 0x08 | 0x04 | 0x01);
+    outb(LPTPORT + 2, 0x08);
+}
+  10106c:	c9                   	leave  
+  10106d:	c3                   	ret    
+
+0010106e <lpt_putc>:
+
+/* lpt_putc - copy console output to parallel port */
+static void
+lpt_putc(int c) {
+  10106e:	55                   	push   %ebp
+  10106f:	89 e5                	mov    %esp,%ebp
+  101071:	83 ec 04             	sub    $0x4,%esp
+    if (c != '\b') {
+  101074:	83 7d 08 08          	cmpl   $0x8,0x8(%ebp)
+  101078:	74 0d                	je     101087 <lpt_putc+0x19>
+        lpt_putc_sub(c);
+  10107a:	8b 45 08             	mov    0x8(%ebp),%eax
+  10107d:	89 04 24             	mov    %eax,(%esp)
+  101080:	e8 70 ff ff ff       	call   100ff5 <lpt_putc_sub>
+  101085:	eb 24                	jmp    1010ab <lpt_putc+0x3d>
+    }
+    else {
+        lpt_putc_sub('\b');
+  101087:	c7 04 24 08 00 00 00 	movl   $0x8,(%esp)
+  10108e:	e8 62 ff ff ff       	call   100ff5 <lpt_putc_sub>
+        lpt_putc_sub(' ');
+  101093:	c7 04 24 20 00 00 00 	movl   $0x20,(%esp)
+  10109a:	e8 56 ff ff ff       	call   100ff5 <lpt_putc_sub>
+        lpt_putc_sub('\b');
+  10109f:	c7 04 24 08 00 00 00 	movl   $0x8,(%esp)
+  1010a6:	e8 4a ff ff ff       	call   100ff5 <lpt_putc_sub>
+    }
+}
+  1010ab:	c9                   	leave  
+  1010ac:	c3                   	ret    
+
+001010ad <cga_putc>:
+
+/* cga_putc - print character to console */
+static void
+cga_putc(int c) {
+  1010ad:	55                   	push   %ebp
+  1010ae:	89 e5                	mov    %esp,%ebp
+  1010b0:	53                   	push   %ebx
+  1010b1:	83 ec 34             	sub    $0x34,%esp
+    // set black on white
+    if (!(c & ~0xFF)) {
+  1010b4:	8b 45 08             	mov    0x8(%ebp),%eax
+  1010b7:	b0 00                	mov    $0x0,%al
+  1010b9:	85 c0                	test   %eax,%eax
+  1010bb:	75 07                	jne    1010c4 <cga_putc+0x17>
+        c |= 0x0700;
+  1010bd:	81 4d 08 00 07 00 00 	orl    $0x700,0x8(%ebp)
+    }
+
+    switch (c & 0xff) {
+  1010c4:	8b 45 08             	mov    0x8(%ebp),%eax
+  1010c7:	0f b6 c0             	movzbl %al,%eax
+  1010ca:	83 f8 0a             	cmp    $0xa,%eax
+  1010cd:	74 4c                	je     10111b <cga_putc+0x6e>
+  1010cf:	83 f8 0d             	cmp    $0xd,%eax
+  1010d2:	74 57                	je     10112b <cga_putc+0x7e>
+  1010d4:	83 f8 08             	cmp    $0x8,%eax
+  1010d7:	0f 85 88 00 00 00    	jne    101165 <cga_putc+0xb8>
+    case '\b':
+        if (crt_pos > 0) {
+  1010dd:	0f b7 05 64 ee 10 00 	movzwl 0x10ee64,%eax
+  1010e4:	66 85 c0             	test   %ax,%ax
+  1010e7:	74 30                	je     101119 <cga_putc+0x6c>
+            crt_pos --;
+  1010e9:	0f b7 05 64 ee 10 00 	movzwl 0x10ee64,%eax
+  1010f0:	83 e8 01             	sub    $0x1,%eax
+  1010f3:	66 a3 64 ee 10 00    	mov    %ax,0x10ee64
+            crt_buf[crt_pos] = (c & ~0xff) | ' ';
+  1010f9:	a1 60 ee 10 00       	mov    0x10ee60,%eax
+  1010fe:	0f b7 15 64 ee 10 00 	movzwl 0x10ee64,%edx
+  101105:	0f b7 d2             	movzwl %dx,%edx
+  101108:	01 d2                	add    %edx,%edx
+  10110a:	01 c2                	add    %eax,%edx
+  10110c:	8b 45 08             	mov    0x8(%ebp),%eax
+  10110f:	b0 00                	mov    $0x0,%al
+  101111:	83 c8 20             	or     $0x20,%eax
+  101114:	66 89 02             	mov    %ax,(%edx)
+        }
+        break;
+  101117:	eb 72                	jmp    10118b <cga_putc+0xde>
+  101119:	eb 70                	jmp    10118b <cga_putc+0xde>
+    case '\n':
+        crt_pos += CRT_COLS;
+  10111b:	0f b7 05 64 ee 10 00 	movzwl 0x10ee64,%eax
+  101122:	83 c0 50             	add    $0x50,%eax
+  101125:	66 a3 64 ee 10 00    	mov    %ax,0x10ee64
+    case '\r':
+        crt_pos -= (crt_pos % CRT_COLS);
+  10112b:	0f b7 1d 64 ee 10 00 	movzwl 0x10ee64,%ebx
+  101132:	0f b7 0d 64 ee 10 00 	movzwl 0x10ee64,%ecx
+  101139:	0f b7 c1             	movzwl %cx,%eax
+  10113c:	69 c0 cd cc 00 00    	imul   $0xcccd,%eax,%eax
+  101142:	c1 e8 10             	shr    $0x10,%eax
+  101145:	89 c2                	mov    %eax,%edx
+  101147:	66 c1 ea 06          	shr    $0x6,%dx
+  10114b:	89 d0                	mov    %edx,%eax
+  10114d:	c1 e0 02             	shl    $0x2,%eax
+  101150:	01 d0                	add    %edx,%eax
+  101152:	c1 e0 04             	shl    $0x4,%eax
+  101155:	29 c1                	sub    %eax,%ecx
+  101157:	89 ca                	mov    %ecx,%edx
+  101159:	89 d8                	mov    %ebx,%eax
+  10115b:	29 d0                	sub    %edx,%eax
+  10115d:	66 a3 64 ee 10 00    	mov    %ax,0x10ee64
+        break;
+  101163:	eb 26                	jmp    10118b <cga_putc+0xde>
+    default:
+        crt_buf[crt_pos ++] = c;     // write the character
+  101165:	8b 0d 60 ee 10 00    	mov    0x10ee60,%ecx
+  10116b:	0f b7 05 64 ee 10 00 	movzwl 0x10ee64,%eax
+  101172:	8d 50 01             	lea    0x1(%eax),%edx
+  101175:	66 89 15 64 ee 10 00 	mov    %dx,0x10ee64
+  10117c:	0f b7 c0             	movzwl %ax,%eax
+  10117f:	01 c0                	add    %eax,%eax
+  101181:	8d 14 01             	lea    (%ecx,%eax,1),%edx
+  101184:	8b 45 08             	mov    0x8(%ebp),%eax
+  101187:	66 89 02             	mov    %ax,(%edx)
+        break;
+  10118a:	90                   	nop
+    }
+
+    // What is the purpose of this?
+    if (crt_pos >= CRT_SIZE) {
+  10118b:	0f b7 05 64 ee 10 00 	movzwl 0x10ee64,%eax
+  101192:	66 3d cf 07          	cmp    $0x7cf,%ax
+  101196:	76 5b                	jbe    1011f3 <cga_putc+0x146>
+        int i;
+        memmove(crt_buf, crt_buf + CRT_COLS, (CRT_SIZE - CRT_COLS) * sizeof(uint16_t));
+  101198:	a1 60 ee 10 00       	mov    0x10ee60,%eax
+  10119d:	8d 90 a0 00 00 00    	lea    0xa0(%eax),%edx
+  1011a3:	a1 60 ee 10 00       	mov    0x10ee60,%eax
+  1011a8:	c7 44 24 08 00 0f 00 	movl   $0xf00,0x8(%esp)
+  1011af:	00 
+  1011b0:	89 54 24 04          	mov    %edx,0x4(%esp)
+  1011b4:	89 04 24             	mov    %eax,(%esp)
+  1011b7:	e8 d4 1a 00 00       	call   102c90 <memmove>
+        for (i = CRT_SIZE - CRT_COLS; i < CRT_SIZE; i ++) {
+  1011bc:	c7 45 f4 80 07 00 00 	movl   $0x780,-0xc(%ebp)
+  1011c3:	eb 15                	jmp    1011da <cga_putc+0x12d>
+            crt_buf[i] = 0x0700 | ' ';
+  1011c5:	a1 60 ee 10 00       	mov    0x10ee60,%eax
+  1011ca:	8b 55 f4             	mov    -0xc(%ebp),%edx
+  1011cd:	01 d2                	add    %edx,%edx
+  1011cf:	01 d0                	add    %edx,%eax
+  1011d1:	66 c7 00 20 07       	movw   $0x720,(%eax)
+        for (i = CRT_SIZE - CRT_COLS; i < CRT_SIZE; i ++) {
+  1011d6:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
+  1011da:	81 7d f4 cf 07 00 00 	cmpl   $0x7cf,-0xc(%ebp)
+  1011e1:	7e e2                	jle    1011c5 <cga_putc+0x118>
+        }
+        crt_pos -= CRT_COLS;
+  1011e3:	0f b7 05 64 ee 10 00 	movzwl 0x10ee64,%eax
+  1011ea:	83 e8 50             	sub    $0x50,%eax
+  1011ed:	66 a3 64 ee 10 00    	mov    %ax,0x10ee64
+    }
+
+    // move that little blinky thing
+    outb(addr_6845, 14);
+  1011f3:	0f b7 05 66 ee 10 00 	movzwl 0x10ee66,%eax
+  1011fa:	0f b7 c0             	movzwl %ax,%eax
+  1011fd:	66 89 45 f2          	mov    %ax,-0xe(%ebp)
+  101201:	c6 45 f1 0e          	movb   $0xe,-0xf(%ebp)
+  101205:	0f b6 45 f1          	movzbl -0xf(%ebp),%eax
+  101209:	0f b7 55 f2          	movzwl -0xe(%ebp),%edx
+  10120d:	ee                   	out    %al,(%dx)
+    outb(addr_6845 + 1, crt_pos >> 8);
+  10120e:	0f b7 05 64 ee 10 00 	movzwl 0x10ee64,%eax
+  101215:	66 c1 e8 08          	shr    $0x8,%ax
+  101219:	0f b6 c0             	movzbl %al,%eax
+  10121c:	0f b7 15 66 ee 10 00 	movzwl 0x10ee66,%edx
+  101223:	83 c2 01             	add    $0x1,%edx
+  101226:	0f b7 d2             	movzwl %dx,%edx
+  101229:	66 89 55 ee          	mov    %dx,-0x12(%ebp)
+  10122d:	88 45 ed             	mov    %al,-0x13(%ebp)
+  101230:	0f b6 45 ed          	movzbl -0x13(%ebp),%eax
+  101234:	0f b7 55 ee          	movzwl -0x12(%ebp),%edx
+  101238:	ee                   	out    %al,(%dx)
+    outb(addr_6845, 15);
+  101239:	0f b7 05 66 ee 10 00 	movzwl 0x10ee66,%eax
+  101240:	0f b7 c0             	movzwl %ax,%eax
+  101243:	66 89 45 ea          	mov    %ax,-0x16(%ebp)
+  101247:	c6 45 e9 0f          	movb   $0xf,-0x17(%ebp)
+  10124b:	0f b6 45 e9          	movzbl -0x17(%ebp),%eax
+  10124f:	0f b7 55 ea          	movzwl -0x16(%ebp),%edx
+  101253:	ee                   	out    %al,(%dx)
+    outb(addr_6845 + 1, crt_pos);
+  101254:	0f b7 05 64 ee 10 00 	movzwl 0x10ee64,%eax
+  10125b:	0f b6 c0             	movzbl %al,%eax
+  10125e:	0f b7 15 66 ee 10 00 	movzwl 0x10ee66,%edx
+  101265:	83 c2 01             	add    $0x1,%edx
+  101268:	0f b7 d2             	movzwl %dx,%edx
+  10126b:	66 89 55 e6          	mov    %dx,-0x1a(%ebp)
+  10126f:	88 45 e5             	mov    %al,-0x1b(%ebp)
+  101272:	0f b6 45 e5          	movzbl -0x1b(%ebp),%eax
+  101276:	0f b7 55 e6          	movzwl -0x1a(%ebp),%edx
+  10127a:	ee                   	out    %al,(%dx)
+}
+  10127b:	83 c4 34             	add    $0x34,%esp
+  10127e:	5b                   	pop    %ebx
+  10127f:	5d                   	pop    %ebp
+  101280:	c3                   	ret    
+
+00101281 <serial_putc_sub>:
+
+static void
+serial_putc_sub(int c) {
+  101281:	55                   	push   %ebp
+  101282:	89 e5                	mov    %esp,%ebp
+  101284:	83 ec 10             	sub    $0x10,%esp
+    int i;
+    for (i = 0; !(inb(COM1 + COM_LSR) & COM_LSR_TXRDY) && i < 12800; i ++) {
+  101287:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
+  10128e:	eb 09                	jmp    101299 <serial_putc_sub+0x18>
+        delay();
+  101290:	e8 4f fb ff ff       	call   100de4 <delay>
+    for (i = 0; !(inb(COM1 + COM_LSR) & COM_LSR_TXRDY) && i < 12800; i ++) {
+  101295:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
+  101299:	66 c7 45 fa fd 03    	movw   $0x3fd,-0x6(%ebp)
+    asm volatile ("inb %1, %0" : "=a" (data) : "d" (port));
+  10129f:	0f b7 45 fa          	movzwl -0x6(%ebp),%eax
+  1012a3:	89 c2                	mov    %eax,%edx
+  1012a5:	ec                   	in     (%dx),%al
+  1012a6:	88 45 f9             	mov    %al,-0x7(%ebp)
+    return data;
+  1012a9:	0f b6 45 f9          	movzbl -0x7(%ebp),%eax
+  1012ad:	0f b6 c0             	movzbl %al,%eax
+  1012b0:	83 e0 20             	and    $0x20,%eax
+  1012b3:	85 c0                	test   %eax,%eax
+  1012b5:	75 09                	jne    1012c0 <serial_putc_sub+0x3f>
+  1012b7:	81 7d fc ff 31 00 00 	cmpl   $0x31ff,-0x4(%ebp)
+  1012be:	7e d0                	jle    101290 <serial_putc_sub+0xf>
+    }
+    outb(COM1 + COM_TX, c);
+  1012c0:	8b 45 08             	mov    0x8(%ebp),%eax
+  1012c3:	0f b6 c0             	movzbl %al,%eax
+  1012c6:	66 c7 45 f6 f8 03    	movw   $0x3f8,-0xa(%ebp)
+  1012cc:	88 45 f5             	mov    %al,-0xb(%ebp)
+    asm volatile ("outb %0, %1" :: "a" (data), "d" (port));
+  1012cf:	0f b6 45 f5          	movzbl -0xb(%ebp),%eax
+  1012d3:	0f b7 55 f6          	movzwl -0xa(%ebp),%edx
+  1012d7:	ee                   	out    %al,(%dx)
+}
+  1012d8:	c9                   	leave  
+  1012d9:	c3                   	ret    
+
+001012da <serial_putc>:
+
+/* serial_putc - print character to serial port */
+static void
+serial_putc(int c) {
+  1012da:	55                   	push   %ebp
+  1012db:	89 e5                	mov    %esp,%ebp
+  1012dd:	83 ec 04             	sub    $0x4,%esp
+    if (c != '\b') {
+  1012e0:	83 7d 08 08          	cmpl   $0x8,0x8(%ebp)
+  1012e4:	74 0d                	je     1012f3 <serial_putc+0x19>
+        serial_putc_sub(c);
+  1012e6:	8b 45 08             	mov    0x8(%ebp),%eax
+  1012e9:	89 04 24             	mov    %eax,(%esp)
+  1012ec:	e8 90 ff ff ff       	call   101281 <serial_putc_sub>
+  1012f1:	eb 24                	jmp    101317 <serial_putc+0x3d>
+    }
+    else {
+        serial_putc_sub('\b');
+  1012f3:	c7 04 24 08 00 00 00 	movl   $0x8,(%esp)
+  1012fa:	e8 82 ff ff ff       	call   101281 <serial_putc_sub>
+        serial_putc_sub(' ');
+  1012ff:	c7 04 24 20 00 00 00 	movl   $0x20,(%esp)
+  101306:	e8 76 ff ff ff       	call   101281 <serial_putc_sub>
+        serial_putc_sub('\b');
+  10130b:	c7 04 24 08 00 00 00 	movl   $0x8,(%esp)
+  101312:	e8 6a ff ff ff       	call   101281 <serial_putc_sub>
+    }
+}
+  101317:	c9                   	leave  
+  101318:	c3                   	ret    
+
+00101319 <cons_intr>:
+/* *
+ * cons_intr - called by device interrupt routines to feed input
+ * characters into the circular console input buffer.
+ * */
+static void
+cons_intr(int (*proc)(void)) {
+  101319:	55                   	push   %ebp
+  10131a:	89 e5                	mov    %esp,%ebp
+  10131c:	83 ec 18             	sub    $0x18,%esp
+    int c;
+    while ((c = (*proc)()) != -1) {
+  10131f:	eb 33                	jmp    101354 <cons_intr+0x3b>
+        if (c != 0) {
+  101321:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
+  101325:	74 2d                	je     101354 <cons_intr+0x3b>
+            cons.buf[cons.wpos ++] = c;
+  101327:	a1 84 f0 10 00       	mov    0x10f084,%eax
+  10132c:	8d 50 01             	lea    0x1(%eax),%edx
+  10132f:	89 15 84 f0 10 00    	mov    %edx,0x10f084
+  101335:	8b 55 f4             	mov    -0xc(%ebp),%edx
+  101338:	88 90 80 ee 10 00    	mov    %dl,0x10ee80(%eax)
+            if (cons.wpos == CONSBUFSIZE) {
+  10133e:	a1 84 f0 10 00       	mov    0x10f084,%eax
+  101343:	3d 00 02 00 00       	cmp    $0x200,%eax
+  101348:	75 0a                	jne    101354 <cons_intr+0x3b>
+                cons.wpos = 0;
+  10134a:	c7 05 84 f0 10 00 00 	movl   $0x0,0x10f084
+  101351:	00 00 00 
+    while ((c = (*proc)()) != -1) {
+  101354:	8b 45 08             	mov    0x8(%ebp),%eax
+  101357:	ff d0                	call   *%eax
+  101359:	89 45 f4             	mov    %eax,-0xc(%ebp)
+  10135c:	83 7d f4 ff          	cmpl   $0xffffffff,-0xc(%ebp)
+  101360:	75 bf                	jne    101321 <cons_intr+0x8>
+            }
+        }
+    }
+}
+  101362:	c9                   	leave  
+  101363:	c3                   	ret    
+
+00101364 <serial_proc_data>:
+
+/* serial_proc_data - get data from serial port */
+static int
+serial_proc_data(void) {
+  101364:	55                   	push   %ebp
+  101365:	89 e5                	mov    %esp,%ebp
+  101367:	83 ec 10             	sub    $0x10,%esp
+  10136a:	66 c7 45 fa fd 03    	movw   $0x3fd,-0x6(%ebp)
+    asm volatile ("inb %1, %0" : "=a" (data) : "d" (port));
+  101370:	0f b7 45 fa          	movzwl -0x6(%ebp),%eax
+  101374:	89 c2                	mov    %eax,%edx
+  101376:	ec                   	in     (%dx),%al
+  101377:	88 45 f9             	mov    %al,-0x7(%ebp)
+    return data;
+  10137a:	0f b6 45 f9          	movzbl -0x7(%ebp),%eax
+    if (!(inb(COM1 + COM_LSR) & COM_LSR_DATA)) {
+  10137e:	0f b6 c0             	movzbl %al,%eax
+  101381:	83 e0 01             	and    $0x1,%eax
+  101384:	85 c0                	test   %eax,%eax
+  101386:	75 07                	jne    10138f <serial_proc_data+0x2b>
+        return -1;
+  101388:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
+  10138d:	eb 2a                	jmp    1013b9 <serial_proc_data+0x55>
+  10138f:	66 c7 45 f6 f8 03    	movw   $0x3f8,-0xa(%ebp)
+    asm volatile ("inb %1, %0" : "=a" (data) : "d" (port));
+  101395:	0f b7 45 f6          	movzwl -0xa(%ebp),%eax
+  101399:	89 c2                	mov    %eax,%edx
+  10139b:	ec                   	in     (%dx),%al
+  10139c:	88 45 f5             	mov    %al,-0xb(%ebp)
+    return data;
+  10139f:	0f b6 45 f5          	movzbl -0xb(%ebp),%eax
+    }
+    int c = inb(COM1 + COM_RX);
+  1013a3:	0f b6 c0             	movzbl %al,%eax
+  1013a6:	89 45 fc             	mov    %eax,-0x4(%ebp)
+    if (c == 127) {
+  1013a9:	83 7d fc 7f          	cmpl   $0x7f,-0x4(%ebp)
+  1013ad:	75 07                	jne    1013b6 <serial_proc_data+0x52>
+        c = '\b';
+  1013af:	c7 45 fc 08 00 00 00 	movl   $0x8,-0x4(%ebp)
+    }
+    return c;
+  1013b6:	8b 45 fc             	mov    -0x4(%ebp),%eax
+}
+  1013b9:	c9                   	leave  
+  1013ba:	c3                   	ret    
+
+001013bb <serial_intr>:
+
+/* serial_intr - try to feed input characters from serial port */
+void
+serial_intr(void) {
+  1013bb:	55                   	push   %ebp
+  1013bc:	89 e5                	mov    %esp,%ebp
+  1013be:	83 ec 18             	sub    $0x18,%esp
+    if (serial_exists) {
+  1013c1:	a1 68 ee 10 00       	mov    0x10ee68,%eax
+  1013c6:	85 c0                	test   %eax,%eax
+  1013c8:	74 0c                	je     1013d6 <serial_intr+0x1b>
+        cons_intr(serial_proc_data);
+  1013ca:	c7 04 24 64 13 10 00 	movl   $0x101364,(%esp)
+  1013d1:	e8 43 ff ff ff       	call   101319 <cons_intr>
+    }
+}
+  1013d6:	c9                   	leave  
+  1013d7:	c3                   	ret    
+
+001013d8 <kbd_proc_data>:
+ *
+ * The kbd_proc_data() function gets data from the keyboard.
+ * If we finish a character, return it, else 0. And return -1 if no data.
+ * */
+static int
+kbd_proc_data(void) {
+  1013d8:	55                   	push   %ebp
+  1013d9:	89 e5                	mov    %esp,%ebp
+  1013db:	83 ec 38             	sub    $0x38,%esp
+  1013de:	66 c7 45 f0 64 00    	movw   $0x64,-0x10(%ebp)
+    asm volatile ("inb %1, %0" : "=a" (data) : "d" (port));
+  1013e4:	0f b7 45 f0          	movzwl -0x10(%ebp),%eax
+  1013e8:	89 c2                	mov    %eax,%edx
+  1013ea:	ec                   	in     (%dx),%al
+  1013eb:	88 45 ef             	mov    %al,-0x11(%ebp)
+    return data;
+  1013ee:	0f b6 45 ef          	movzbl -0x11(%ebp),%eax
+    int c;
+    uint8_t data;
+    static uint32_t shift;
+
+    if ((inb(KBSTATP) & KBS_DIB) == 0) {
+  1013f2:	0f b6 c0             	movzbl %al,%eax
+  1013f5:	83 e0 01             	and    $0x1,%eax
+  1013f8:	85 c0                	test   %eax,%eax
+  1013fa:	75 0a                	jne    101406 <kbd_proc_data+0x2e>
+        return -1;
+  1013fc:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
+  101401:	e9 59 01 00 00       	jmp    10155f <kbd_proc_data+0x187>
+  101406:	66 c7 45 ec 60 00    	movw   $0x60,-0x14(%ebp)
+    asm volatile ("inb %1, %0" : "=a" (data) : "d" (port));
+  10140c:	0f b7 45 ec          	movzwl -0x14(%ebp),%eax
+  101410:	89 c2                	mov    %eax,%edx
+  101412:	ec                   	in     (%dx),%al
+  101413:	88 45 eb             	mov    %al,-0x15(%ebp)
+    return data;
+  101416:	0f b6 45 eb          	movzbl -0x15(%ebp),%eax
+    }
+
+    data = inb(KBDATAP);
+  10141a:	88 45 f3             	mov    %al,-0xd(%ebp)
+
+    if (data == 0xE0) {
+  10141d:	80 7d f3 e0          	cmpb   $0xe0,-0xd(%ebp)
+  101421:	75 17                	jne    10143a <kbd_proc_data+0x62>
+        // E0 escape character
+        shift |= E0ESC;
+  101423:	a1 88 f0 10 00       	mov    0x10f088,%eax
+  101428:	83 c8 40             	or     $0x40,%eax
+  10142b:	a3 88 f0 10 00       	mov    %eax,0x10f088
+        return 0;
+  101430:	b8 00 00 00 00       	mov    $0x0,%eax
+  101435:	e9 25 01 00 00       	jmp    10155f <kbd_proc_data+0x187>
+    } else if (data & 0x80) {
+  10143a:	0f b6 45 f3          	movzbl -0xd(%ebp),%eax
+  10143e:	84 c0                	test   %al,%al
+  101440:	79 47                	jns    101489 <kbd_proc_data+0xb1>
+        // Key released
+        data = (shift & E0ESC ? data : data & 0x7F);
+  101442:	a1 88 f0 10 00       	mov    0x10f088,%eax
+  101447:	83 e0 40             	and    $0x40,%eax
+  10144a:	85 c0                	test   %eax,%eax
+  10144c:	75 09                	jne    101457 <kbd_proc_data+0x7f>
+  10144e:	0f b6 45 f3          	movzbl -0xd(%ebp),%eax
+  101452:	83 e0 7f             	and    $0x7f,%eax
+  101455:	eb 04                	jmp    10145b <kbd_proc_data+0x83>
+  101457:	0f b6 45 f3          	movzbl -0xd(%ebp),%eax
+  10145b:	88 45 f3             	mov    %al,-0xd(%ebp)
+        shift &= ~(shiftcode[data] | E0ESC);
+  10145e:	0f b6 45 f3          	movzbl -0xd(%ebp),%eax
+  101462:	0f b6 80 40 e0 10 00 	movzbl 0x10e040(%eax),%eax
+  101469:	83 c8 40             	or     $0x40,%eax
+  10146c:	0f b6 c0             	movzbl %al,%eax
+  10146f:	f7 d0                	not    %eax
+  101471:	89 c2                	mov    %eax,%edx
+  101473:	a1 88 f0 10 00       	mov    0x10f088,%eax
+  101478:	21 d0                	and    %edx,%eax
+  10147a:	a3 88 f0 10 00       	mov    %eax,0x10f088
+        return 0;
+  10147f:	b8 00 00 00 00       	mov    $0x0,%eax
+  101484:	e9 d6 00 00 00       	jmp    10155f <kbd_proc_data+0x187>
+    } else if (shift & E0ESC) {
+  101489:	a1 88 f0 10 00       	mov    0x10f088,%eax
+  10148e:	83 e0 40             	and    $0x40,%eax
+  101491:	85 c0                	test   %eax,%eax
+  101493:	74 11                	je     1014a6 <kbd_proc_data+0xce>
+        // Last character was an E0 escape; or with 0x80
+        data |= 0x80;
+  101495:	80 4d f3 80          	orb    $0x80,-0xd(%ebp)
+        shift &= ~E0ESC;
+  101499:	a1 88 f0 10 00       	mov    0x10f088,%eax
+  10149e:	83 e0 bf             	and    $0xffffffbf,%eax
+  1014a1:	a3 88 f0 10 00       	mov    %eax,0x10f088
+    }
+
+    shift |= shiftcode[data];
+  1014a6:	0f b6 45 f3          	movzbl -0xd(%ebp),%eax
+  1014aa:	0f b6 80 40 e0 10 00 	movzbl 0x10e040(%eax),%eax
+  1014b1:	0f b6 d0             	movzbl %al,%edx
+  1014b4:	a1 88 f0 10 00       	mov    0x10f088,%eax
+  1014b9:	09 d0                	or     %edx,%eax
+  1014bb:	a3 88 f0 10 00       	mov    %eax,0x10f088
+    shift ^= togglecode[data];
+  1014c0:	0f b6 45 f3          	movzbl -0xd(%ebp),%eax
+  1014c4:	0f b6 80 40 e1 10 00 	movzbl 0x10e140(%eax),%eax
+  1014cb:	0f b6 d0             	movzbl %al,%edx
+  1014ce:	a1 88 f0 10 00       	mov    0x10f088,%eax
+  1014d3:	31 d0                	xor    %edx,%eax
+  1014d5:	a3 88 f0 10 00       	mov    %eax,0x10f088
+
+    c = charcode[shift & (CTL | SHIFT)][data];
+  1014da:	a1 88 f0 10 00       	mov    0x10f088,%eax
+  1014df:	83 e0 03             	and    $0x3,%eax
+  1014e2:	8b 14 85 40 e5 10 00 	mov    0x10e540(,%eax,4),%edx
+  1014e9:	0f b6 45 f3          	movzbl -0xd(%ebp),%eax
+  1014ed:	01 d0                	add    %edx,%eax
+  1014ef:	0f b6 00             	movzbl (%eax),%eax
+  1014f2:	0f b6 c0             	movzbl %al,%eax
+  1014f5:	89 45 f4             	mov    %eax,-0xc(%ebp)
+    if (shift & CAPSLOCK) {
+  1014f8:	a1 88 f0 10 00       	mov    0x10f088,%eax
+  1014fd:	83 e0 08             	and    $0x8,%eax
+  101500:	85 c0                	test   %eax,%eax
+  101502:	74 22                	je     101526 <kbd_proc_data+0x14e>
+        if ('a' <= c && c <= 'z')
+  101504:	83 7d f4 60          	cmpl   $0x60,-0xc(%ebp)
+  101508:	7e 0c                	jle    101516 <kbd_proc_data+0x13e>
+  10150a:	83 7d f4 7a          	cmpl   $0x7a,-0xc(%ebp)
+  10150e:	7f 06                	jg     101516 <kbd_proc_data+0x13e>
+            c += 'A' - 'a';
+  101510:	83 6d f4 20          	subl   $0x20,-0xc(%ebp)
+  101514:	eb 10                	jmp    101526 <kbd_proc_data+0x14e>
+        else if ('A' <= c && c <= 'Z')
+  101516:	83 7d f4 40          	cmpl   $0x40,-0xc(%ebp)
+  10151a:	7e 0a                	jle    101526 <kbd_proc_data+0x14e>
+  10151c:	83 7d f4 5a          	cmpl   $0x5a,-0xc(%ebp)
+  101520:	7f 04                	jg     101526 <kbd_proc_data+0x14e>
+            c += 'a' - 'A';
+  101522:	83 45 f4 20          	addl   $0x20,-0xc(%ebp)
+    }
+
+    // Process special keys
+    // Ctrl-Alt-Del: reboot
+    if (!(~shift & (CTL | ALT)) && c == KEY_DEL) {
+  101526:	a1 88 f0 10 00       	mov    0x10f088,%eax
+  10152b:	f7 d0                	not    %eax
+  10152d:	83 e0 06             	and    $0x6,%eax
+  101530:	85 c0                	test   %eax,%eax
+  101532:	75 28                	jne    10155c <kbd_proc_data+0x184>
+  101534:	81 7d f4 e9 00 00 00 	cmpl   $0xe9,-0xc(%ebp)
+  10153b:	75 1f                	jne    10155c <kbd_proc_data+0x184>
+        cprintf("Rebooting!\n");
+  10153d:	c7 04 24 a1 37 10 00 	movl   $0x1037a1,(%esp)
+  101544:	e8 13 ed ff ff       	call   10025c <cprintf>
+  101549:	66 c7 45 e8 92 00    	movw   $0x92,-0x18(%ebp)
+  10154f:	c6 45 e7 03          	movb   $0x3,-0x19(%ebp)
+    asm volatile ("outb %0, %1" :: "a" (data), "d" (port));
+  101553:	0f b6 45 e7          	movzbl -0x19(%ebp),%eax
+  101557:	0f b7 55 e8          	movzwl -0x18(%ebp),%edx
+  10155b:	ee                   	out    %al,(%dx)
+        outb(0x92, 0x3); // courtesy of Chris Frost
+    }
+    return c;
+  10155c:	8b 45 f4             	mov    -0xc(%ebp),%eax
+}
+  10155f:	c9                   	leave  
+  101560:	c3                   	ret    
+
+00101561 <kbd_intr>:
+
+/* kbd_intr - try to feed input characters from keyboard */
+static void
+kbd_intr(void) {
+  101561:	55                   	push   %ebp
+  101562:	89 e5                	mov    %esp,%ebp
+  101564:	83 ec 18             	sub    $0x18,%esp
+    cons_intr(kbd_proc_data);
+  101567:	c7 04 24 d8 13 10 00 	movl   $0x1013d8,(%esp)
+  10156e:	e8 a6 fd ff ff       	call   101319 <cons_intr>
+}
+  101573:	c9                   	leave  
+  101574:	c3                   	ret    
+
+00101575 <kbd_init>:
+
+static void
+kbd_init(void) {
+  101575:	55                   	push   %ebp
+  101576:	89 e5                	mov    %esp,%ebp
+  101578:	83 ec 18             	sub    $0x18,%esp
+    // drain the kbd buffer
+    kbd_intr();
+  10157b:	e8 e1 ff ff ff       	call   101561 <kbd_intr>
+    pic_enable(IRQ_KBD);
+  101580:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
+  101587:	e8 0b 01 00 00       	call   101697 <pic_enable>
+}
+  10158c:	c9                   	leave  
+  10158d:	c3                   	ret    
+
+0010158e <cons_init>:
+
+/* cons_init - initializes the console devices */
+void
+cons_init(void) {
+  10158e:	55                   	push   %ebp
+  10158f:	89 e5                	mov    %esp,%ebp
+  101591:	83 ec 18             	sub    $0x18,%esp
+    cga_init();
+  101594:	e8 93 f8 ff ff       	call   100e2c <cga_init>
+    serial_init();
+  101599:	e8 74 f9 ff ff       	call   100f12 <serial_init>
+    kbd_init();
+  10159e:	e8 d2 ff ff ff       	call   101575 <kbd_init>
+    if (!serial_exists) {
+  1015a3:	a1 68 ee 10 00       	mov    0x10ee68,%eax
+  1015a8:	85 c0                	test   %eax,%eax
+  1015aa:	75 0c                	jne    1015b8 <cons_init+0x2a>
+        cprintf("serial port does not exist!!\n");
+  1015ac:	c7 04 24 ad 37 10 00 	movl   $0x1037ad,(%esp)
+  1015b3:	e8 a4 ec ff ff       	call   10025c <cprintf>
+    }
+}
+  1015b8:	c9                   	leave  
+  1015b9:	c3                   	ret    
+
+001015ba <cons_putc>:
+
+/* cons_putc - print a single character @c to console devices */
+void
+cons_putc(int c) {
+  1015ba:	55                   	push   %ebp
+  1015bb:	89 e5                	mov    %esp,%ebp
+  1015bd:	83 ec 18             	sub    $0x18,%esp
+    lpt_putc(c);
+  1015c0:	8b 45 08             	mov    0x8(%ebp),%eax
+  1015c3:	89 04 24             	mov    %eax,(%esp)
+  1015c6:	e8 a3 fa ff ff       	call   10106e <lpt_putc>
+    cga_putc(c);
+  1015cb:	8b 45 08             	mov    0x8(%ebp),%eax
+  1015ce:	89 04 24             	mov    %eax,(%esp)
+  1015d1:	e8 d7 fa ff ff       	call   1010ad <cga_putc>
+    serial_putc(c);
+  1015d6:	8b 45 08             	mov    0x8(%ebp),%eax
+  1015d9:	89 04 24             	mov    %eax,(%esp)
+  1015dc:	e8 f9 fc ff ff       	call   1012da <serial_putc>
+}
+  1015e1:	c9                   	leave  
+  1015e2:	c3                   	ret    
+
+001015e3 <cons_getc>:
+/* *
+ * cons_getc - return the next input character from console,
+ * or 0 if none waiting.
+ * */
+int
+cons_getc(void) {
+  1015e3:	55                   	push   %ebp
+  1015e4:	89 e5                	mov    %esp,%ebp
+  1015e6:	83 ec 18             	sub    $0x18,%esp
+    int c;
+
+    // poll for any pending input characters,
+    // so that this function works even when interrupts are disabled
+    // (e.g., when called from the kernel monitor).
+    serial_intr();
+  1015e9:	e8 cd fd ff ff       	call   1013bb <serial_intr>
+    kbd_intr();
+  1015ee:	e8 6e ff ff ff       	call   101561 <kbd_intr>
+
+    // grab the next character from the input buffer.
+    if (cons.rpos != cons.wpos) {
+  1015f3:	8b 15 80 f0 10 00    	mov    0x10f080,%edx
+  1015f9:	a1 84 f0 10 00       	mov    0x10f084,%eax
+  1015fe:	39 c2                	cmp    %eax,%edx
+  101600:	74 36                	je     101638 <cons_getc+0x55>
+        c = cons.buf[cons.rpos ++];
+  101602:	a1 80 f0 10 00       	mov    0x10f080,%eax
+  101607:	8d 50 01             	lea    0x1(%eax),%edx
+  10160a:	89 15 80 f0 10 00    	mov    %edx,0x10f080
+  101610:	0f b6 80 80 ee 10 00 	movzbl 0x10ee80(%eax),%eax
+  101617:	0f b6 c0             	movzbl %al,%eax
+  10161a:	89 45 f4             	mov    %eax,-0xc(%ebp)
+        if (cons.rpos == CONSBUFSIZE) {
+  10161d:	a1 80 f0 10 00       	mov    0x10f080,%eax
+  101622:	3d 00 02 00 00       	cmp    $0x200,%eax
+  101627:	75 0a                	jne    101633 <cons_getc+0x50>
+            cons.rpos = 0;
+  101629:	c7 05 80 f0 10 00 00 	movl   $0x0,0x10f080
+  101630:	00 00 00 
+        }
+        return c;
+  101633:	8b 45 f4             	mov    -0xc(%ebp),%eax
+  101636:	eb 05                	jmp    10163d <cons_getc+0x5a>
+    }
+    return 0;
+  101638:	b8 00 00 00 00       	mov    $0x0,%eax
+}
+  10163d:	c9                   	leave  
+  10163e:	c3                   	ret    
+
+0010163f <pic_setmask>:
+// Initial IRQ mask has interrupt 2 enabled (for slave 8259A).
+static uint16_t irq_mask = 0xFFFF & ~(1 << IRQ_SLAVE);
+static bool did_init = 0;
+
+static void
+pic_setmask(uint16_t mask) {
+  10163f:	55                   	push   %ebp
+  101640:	89 e5                	mov    %esp,%ebp
+  101642:	83 ec 14             	sub    $0x14,%esp
+  101645:	8b 45 08             	mov    0x8(%ebp),%eax
+  101648:	66 89 45 ec          	mov    %ax,-0x14(%ebp)
+    irq_mask = mask;
+  10164c:	0f b7 45 ec          	movzwl -0x14(%ebp),%eax
+  101650:	66 a3 50 e5 10 00    	mov    %ax,0x10e550
+    if (did_init) {
+  101656:	a1 8c f0 10 00       	mov    0x10f08c,%eax
+  10165b:	85 c0                	test   %eax,%eax
+  10165d:	74 36                	je     101695 <pic_setmask+0x56>
+        outb(IO_PIC1 + 1, mask);
+  10165f:	0f b7 45 ec          	movzwl -0x14(%ebp),%eax
+  101663:	0f b6 c0             	movzbl %al,%eax
+  101666:	66 c7 45 fe 21 00    	movw   $0x21,-0x2(%ebp)
+  10166c:	88 45 fd             	mov    %al,-0x3(%ebp)
+  10166f:	0f b6 45 fd          	movzbl -0x3(%ebp),%eax
+  101673:	0f b7 55 fe          	movzwl -0x2(%ebp),%edx
+  101677:	ee                   	out    %al,(%dx)
+        outb(IO_PIC2 + 1, mask >> 8);
+  101678:	0f b7 45 ec          	movzwl -0x14(%ebp),%eax
+  10167c:	66 c1 e8 08          	shr    $0x8,%ax
+  101680:	0f b6 c0             	movzbl %al,%eax
+  101683:	66 c7 45 fa a1 00    	movw   $0xa1,-0x6(%ebp)
+  101689:	88 45 f9             	mov    %al,-0x7(%ebp)
+  10168c:	0f b6 45 f9          	movzbl -0x7(%ebp),%eax
+  101690:	0f b7 55 fa          	movzwl -0x6(%ebp),%edx
+  101694:	ee                   	out    %al,(%dx)
+    }
+}
+  101695:	c9                   	leave  
+  101696:	c3                   	ret    
+
+00101697 <pic_enable>:
+
+void
+pic_enable(unsigned int irq) {
+  101697:	55                   	push   %ebp
+  101698:	89 e5                	mov    %esp,%ebp
+  10169a:	83 ec 04             	sub    $0x4,%esp
+    pic_setmask(irq_mask & ~(1 << irq));
+  10169d:	8b 45 08             	mov    0x8(%ebp),%eax
+  1016a0:	ba 01 00 00 00       	mov    $0x1,%edx
+  1016a5:	89 c1                	mov    %eax,%ecx
+  1016a7:	d3 e2                	shl    %cl,%edx
+  1016a9:	89 d0                	mov    %edx,%eax
+  1016ab:	f7 d0                	not    %eax
+  1016ad:	89 c2                	mov    %eax,%edx
+  1016af:	0f b7 05 50 e5 10 00 	movzwl 0x10e550,%eax
+  1016b6:	21 d0                	and    %edx,%eax
+  1016b8:	0f b7 c0             	movzwl %ax,%eax
+  1016bb:	89 04 24             	mov    %eax,(%esp)
+  1016be:	e8 7c ff ff ff       	call   10163f <pic_setmask>
+}
+  1016c3:	c9                   	leave  
+  1016c4:	c3                   	ret    
+
+001016c5 <pic_init>:
+
+/* pic_init - initialize the 8259A interrupt controllers */
+void
+pic_init(void) {
+  1016c5:	55                   	push   %ebp
+  1016c6:	89 e5                	mov    %esp,%ebp
+  1016c8:	83 ec 44             	sub    $0x44,%esp
+    did_init = 1;
+  1016cb:	c7 05 8c f0 10 00 01 	movl   $0x1,0x10f08c
+  1016d2:	00 00 00 
+  1016d5:	66 c7 45 fe 21 00    	movw   $0x21,-0x2(%ebp)
+  1016db:	c6 45 fd ff          	movb   $0xff,-0x3(%ebp)
+  1016df:	0f b6 45 fd          	movzbl -0x3(%ebp),%eax
+  1016e3:	0f b7 55 fe          	movzwl -0x2(%ebp),%edx
+  1016e7:	ee                   	out    %al,(%dx)
+  1016e8:	66 c7 45 fa a1 00    	movw   $0xa1,-0x6(%ebp)
+  1016ee:	c6 45 f9 ff          	movb   $0xff,-0x7(%ebp)
+  1016f2:	0f b6 45 f9          	movzbl -0x7(%ebp),%eax
+  1016f6:	0f b7 55 fa          	movzwl -0x6(%ebp),%edx
+  1016fa:	ee                   	out    %al,(%dx)
+  1016fb:	66 c7 45 f6 20 00    	movw   $0x20,-0xa(%ebp)
+  101701:	c6 45 f5 11          	movb   $0x11,-0xb(%ebp)
+  101705:	0f b6 45 f5          	movzbl -0xb(%ebp),%eax
+  101709:	0f b7 55 f6          	movzwl -0xa(%ebp),%edx
+  10170d:	ee                   	out    %al,(%dx)
+  10170e:	66 c7 45 f2 21 00    	movw   $0x21,-0xe(%ebp)
+  101714:	c6 45 f1 20          	movb   $0x20,-0xf(%ebp)
+  101718:	0f b6 45 f1          	movzbl -0xf(%ebp),%eax
+  10171c:	0f b7 55 f2          	movzwl -0xe(%ebp),%edx
+  101720:	ee                   	out    %al,(%dx)
+  101721:	66 c7 45 ee 21 00    	movw   $0x21,-0x12(%ebp)
+  101727:	c6 45 ed 04          	movb   $0x4,-0x13(%ebp)
+  10172b:	0f b6 45 ed          	movzbl -0x13(%ebp),%eax
+  10172f:	0f b7 55 ee          	movzwl -0x12(%ebp),%edx
+  101733:	ee                   	out    %al,(%dx)
+  101734:	66 c7 45 ea 21 00    	movw   $0x21,-0x16(%ebp)
+  10173a:	c6 45 e9 03          	movb   $0x3,-0x17(%ebp)
+  10173e:	0f b6 45 e9          	movzbl -0x17(%ebp),%eax
+  101742:	0f b7 55 ea          	movzwl -0x16(%ebp),%edx
+  101746:	ee                   	out    %al,(%dx)
+  101747:	66 c7 45 e6 a0 00    	movw   $0xa0,-0x1a(%ebp)
+  10174d:	c6 45 e5 11          	movb   $0x11,-0x1b(%ebp)
+  101751:	0f b6 45 e5          	movzbl -0x1b(%ebp),%eax
+  101755:	0f b7 55 e6          	movzwl -0x1a(%ebp),%edx
+  101759:	ee                   	out    %al,(%dx)
+  10175a:	66 c7 45 e2 a1 00    	movw   $0xa1,-0x1e(%ebp)
+  101760:	c6 45 e1 28          	movb   $0x28,-0x1f(%ebp)
+  101764:	0f b6 45 e1          	movzbl -0x1f(%ebp),%eax
+  101768:	0f b7 55 e2          	movzwl -0x1e(%ebp),%edx
+  10176c:	ee                   	out    %al,(%dx)
+  10176d:	66 c7 45 de a1 00    	movw   $0xa1,-0x22(%ebp)
+  101773:	c6 45 dd 02          	movb   $0x2,-0x23(%ebp)
+  101777:	0f b6 45 dd          	movzbl -0x23(%ebp),%eax
+  10177b:	0f b7 55 de          	movzwl -0x22(%ebp),%edx
+  10177f:	ee                   	out    %al,(%dx)
+  101780:	66 c7 45 da a1 00    	movw   $0xa1,-0x26(%ebp)
+  101786:	c6 45 d9 03          	movb   $0x3,-0x27(%ebp)
+  10178a:	0f b6 45 d9          	movzbl -0x27(%ebp),%eax
+  10178e:	0f b7 55 da          	movzwl -0x26(%ebp),%edx
+  101792:	ee                   	out    %al,(%dx)
+  101793:	66 c7 45 d6 20 00    	movw   $0x20,-0x2a(%ebp)
+  101799:	c6 45 d5 68          	movb   $0x68,-0x2b(%ebp)
+  10179d:	0f b6 45 d5          	movzbl -0x2b(%ebp),%eax
+  1017a1:	0f b7 55 d6          	movzwl -0x2a(%ebp),%edx
+  1017a5:	ee                   	out    %al,(%dx)
+  1017a6:	66 c7 45 d2 20 00    	movw   $0x20,-0x2e(%ebp)
+  1017ac:	c6 45 d1 0a          	movb   $0xa,-0x2f(%ebp)
+  1017b0:	0f b6 45 d1          	movzbl -0x2f(%ebp),%eax
+  1017b4:	0f b7 55 d2          	movzwl -0x2e(%ebp),%edx
+  1017b8:	ee                   	out    %al,(%dx)
+  1017b9:	66 c7 45 ce a0 00    	movw   $0xa0,-0x32(%ebp)
+  1017bf:	c6 45 cd 68          	movb   $0x68,-0x33(%ebp)
+  1017c3:	0f b6 45 cd          	movzbl -0x33(%ebp),%eax
+  1017c7:	0f b7 55 ce          	movzwl -0x32(%ebp),%edx
+  1017cb:	ee                   	out    %al,(%dx)
+  1017cc:	66 c7 45 ca a0 00    	movw   $0xa0,-0x36(%ebp)
+  1017d2:	c6 45 c9 0a          	movb   $0xa,-0x37(%ebp)
+  1017d6:	0f b6 45 c9          	movzbl -0x37(%ebp),%eax
+  1017da:	0f b7 55 ca          	movzwl -0x36(%ebp),%edx
+  1017de:	ee                   	out    %al,(%dx)
+    outb(IO_PIC1, 0x0a);    // read IRR by default
+
+    outb(IO_PIC2, 0x68);    // OCW3
+    outb(IO_PIC2, 0x0a);    // OCW3
+
+    if (irq_mask != 0xFFFF) {
+  1017df:	0f b7 05 50 e5 10 00 	movzwl 0x10e550,%eax
+  1017e6:	66 83 f8 ff          	cmp    $0xffff,%ax
+  1017ea:	74 12                	je     1017fe <pic_init+0x139>
+        pic_setmask(irq_mask);
+  1017ec:	0f b7 05 50 e5 10 00 	movzwl 0x10e550,%eax
+  1017f3:	0f b7 c0             	movzwl %ax,%eax
+  1017f6:	89 04 24             	mov    %eax,(%esp)
+  1017f9:	e8 41 fe ff ff       	call   10163f <pic_setmask>
+    }
+}
+  1017fe:	c9                   	leave  
+  1017ff:	c3                   	ret    
+
+00101800 <intr_enable>:
+#include <x86.h>
+#include <intr.h>
+
+/* intr_enable - enable irq interrupt */
+void
+intr_enable(void) {
+  101800:	55                   	push   %ebp
+  101801:	89 e5                	mov    %esp,%ebp
+    asm volatile ("lidt (%0)" :: "r" (pd));
+}
+
+static inline void
+sti(void) {
+    asm volatile ("sti");
+  101803:	fb                   	sti    
+    sti();
+}
+  101804:	5d                   	pop    %ebp
+  101805:	c3                   	ret    
+
+00101806 <intr_disable>:
+
+/* intr_disable - disable irq interrupt */
+void
+intr_disable(void) {
+  101806:	55                   	push   %ebp
+  101807:	89 e5                	mov    %esp,%ebp
+}
+
+static inline void
+cli(void) {
+    asm volatile ("cli");
+  101809:	fa                   	cli    
+    cli();
+}
+  10180a:	5d                   	pop    %ebp
+  10180b:	c3                   	ret    
+
+0010180c <print_ticks>:
+#include <kdebug.h>
+
+#define TICK_NUM 100
+int cur_tick = 0;
+
+static void print_ticks() {
+  10180c:	55                   	push   %ebp
+  10180d:	89 e5                	mov    %esp,%ebp
+  10180f:	83 ec 18             	sub    $0x18,%esp
+    cprintf("%d ticks\n",TICK_NUM);
+  101812:	c7 44 24 04 64 00 00 	movl   $0x64,0x4(%esp)
+  101819:	00 
+  10181a:	c7 04 24 e0 37 10 00 	movl   $0x1037e0,(%esp)
+  101821:	e8 36 ea ff ff       	call   10025c <cprintf>
+#ifdef DEBUG_GRADE
+    cprintf("End of Test.\n");
+    panic("EOT: kernel seems ok.");
+#endif
+}
+  101826:	c9                   	leave  
+  101827:	c3                   	ret    
+
+00101828 <idt_init>:
+    sizeof(idt) - 1, (uintptr_t)idt
+};
+
+/* idt_init - initialize IDT to each of the entry points in kern/trap/vectors.S */
+void
+idt_init(void) {
+  101828:	55                   	push   %ebp
+  101829:	89 e5                	mov    %esp,%ebp
+  10182b:	83 ec 10             	sub    $0x10,%esp
+	 *   - dpl: Descriptor Privilege Level - the privilege level required
+	 *          for software to invoke this interrupt/trap gate explicitly
+	 *          using an int instruction.
+	 * */
+	//	SETGATE(gate, istrap, sel, off, dpl)
+	int i = 0;
+  10182e:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
+	for(i = 0;i < 256;i++ ){
+  101835:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
+  10183c:	e9 f2 00 00 00       	jmp    101933 <idt_init+0x10b>
+		int dpl = DPL_KERNEL;
+  101841:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
+		if(i == T_SYSCALL || i == T_SWITCH_TOK){
+  101848:	81 7d fc 80 00 00 00 	cmpl   $0x80,-0x4(%ebp)
+  10184f:	74 06                	je     101857 <idt_init+0x2f>
+  101851:	83 7d fc 79          	cmpl   $0x79,-0x4(%ebp)
+  101855:	75 07                	jne    10185e <idt_init+0x36>
+			dpl = DPL_USER;
+  101857:	c7 45 f8 03 00 00 00 	movl   $0x3,-0x8(%ebp)
+		}
+		SETGATE(idt[i],0,KERNEL_CS,__vectors[i],dpl);
+  10185e:	8b 45 fc             	mov    -0x4(%ebp),%eax
+  101861:	8b 04 85 e0 e5 10 00 	mov    0x10e5e0(,%eax,4),%eax
+  101868:	89 c2                	mov    %eax,%edx
+  10186a:	8b 45 fc             	mov    -0x4(%ebp),%eax
+  10186d:	66 89 14 c5 c0 f0 10 	mov    %dx,0x10f0c0(,%eax,8)
+  101874:	00 
+  101875:	8b 45 fc             	mov    -0x4(%ebp),%eax
+  101878:	66 c7 04 c5 c2 f0 10 	movw   $0x8,0x10f0c2(,%eax,8)
+  10187f:	00 08 00 
+  101882:	8b 45 fc             	mov    -0x4(%ebp),%eax
+  101885:	0f b6 14 c5 c4 f0 10 	movzbl 0x10f0c4(,%eax,8),%edx
+  10188c:	00 
+  10188d:	83 e2 e0             	and    $0xffffffe0,%edx
+  101890:	88 14 c5 c4 f0 10 00 	mov    %dl,0x10f0c4(,%eax,8)
+  101897:	8b 45 fc             	mov    -0x4(%ebp),%eax
+  10189a:	0f b6 14 c5 c4 f0 10 	movzbl 0x10f0c4(,%eax,8),%edx
+  1018a1:	00 
+  1018a2:	83 e2 1f             	and    $0x1f,%edx
+  1018a5:	88 14 c5 c4 f0 10 00 	mov    %dl,0x10f0c4(,%eax,8)
+  1018ac:	8b 45 fc             	mov    -0x4(%ebp),%eax
+  1018af:	0f b6 14 c5 c5 f0 10 	movzbl 0x10f0c5(,%eax,8),%edx
+  1018b6:	00 
+  1018b7:	83 e2 f0             	and    $0xfffffff0,%edx
+  1018ba:	83 ca 0e             	or     $0xe,%edx
+  1018bd:	88 14 c5 c5 f0 10 00 	mov    %dl,0x10f0c5(,%eax,8)
+  1018c4:	8b 45 fc             	mov    -0x4(%ebp),%eax
+  1018c7:	0f b6 14 c5 c5 f0 10 	movzbl 0x10f0c5(,%eax,8),%edx
+  1018ce:	00 
+  1018cf:	83 e2 ef             	and    $0xffffffef,%edx
+  1018d2:	88 14 c5 c5 f0 10 00 	mov    %dl,0x10f0c5(,%eax,8)
+  1018d9:	8b 45 f8             	mov    -0x8(%ebp),%eax
+  1018dc:	83 e0 03             	and    $0x3,%eax
+  1018df:	89 c2                	mov    %eax,%edx
+  1018e1:	8b 45 fc             	mov    -0x4(%ebp),%eax
+  1018e4:	83 e2 03             	and    $0x3,%edx
+  1018e7:	89 d1                	mov    %edx,%ecx
+  1018e9:	c1 e1 05             	shl    $0x5,%ecx
+  1018ec:	0f b6 14 c5 c5 f0 10 	movzbl 0x10f0c5(,%eax,8),%edx
+  1018f3:	00 
+  1018f4:	83 e2 9f             	and    $0xffffff9f,%edx
+  1018f7:	09 ca                	or     %ecx,%edx
+  1018f9:	88 14 c5 c5 f0 10 00 	mov    %dl,0x10f0c5(,%eax,8)
+  101900:	8b 45 fc             	mov    -0x4(%ebp),%eax
+  101903:	0f b6 14 c5 c5 f0 10 	movzbl 0x10f0c5(,%eax,8),%edx
+  10190a:	00 
+  10190b:	83 ca 80             	or     $0xffffff80,%edx
+  10190e:	88 14 c5 c5 f0 10 00 	mov    %dl,0x10f0c5(,%eax,8)
+  101915:	8b 45 fc             	mov    -0x4(%ebp),%eax
+  101918:	8b 04 85 e0 e5 10 00 	mov    0x10e5e0(,%eax,4),%eax
+  10191f:	c1 e8 10             	shr    $0x10,%eax
+  101922:	89 c2                	mov    %eax,%edx
+  101924:	8b 45 fc             	mov    -0x4(%ebp),%eax
+  101927:	66 89 14 c5 c6 f0 10 	mov    %dx,0x10f0c6(,%eax,8)
+  10192e:	00 
+	for(i = 0;i < 256;i++ ){
+  10192f:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
+  101933:	81 7d fc ff 00 00 00 	cmpl   $0xff,-0x4(%ebp)
+  10193a:	0f 8e 01 ff ff ff    	jle    101841 <idt_init+0x19>
+	}
+	asm ("lidt %0\n"::"m"(idt_pd));
+  101940:	0f 01 1d 60 e5 10 00 	lidtl  0x10e560
+}
+  101947:	c9                   	leave  
+  101948:	c3                   	ret    
+
+00101949 <trapname>:
+
+static const char *
+trapname(int trapno) {
+  101949:	55                   	push   %ebp
+  10194a:	89 e5                	mov    %esp,%ebp
+        "Alignment Check",
+        "Machine-Check",
+        "SIMD Floating-Point Exception"
+    };
+
+    if (trapno < sizeof(excnames)/sizeof(const char * const)) {
+  10194c:	8b 45 08             	mov    0x8(%ebp),%eax
+  10194f:	83 f8 13             	cmp    $0x13,%eax
+  101952:	77 0c                	ja     101960 <trapname+0x17>
+        return excnames[trapno];
+  101954:	8b 45 08             	mov    0x8(%ebp),%eax
+  101957:	8b 04 85 40 3b 10 00 	mov    0x103b40(,%eax,4),%eax
+  10195e:	eb 18                	jmp    101978 <trapname+0x2f>
+    }
+    if (trapno >= IRQ_OFFSET && trapno < IRQ_OFFSET + 16) {
+  101960:	83 7d 08 1f          	cmpl   $0x1f,0x8(%ebp)
+  101964:	7e 0d                	jle    101973 <trapname+0x2a>
+  101966:	83 7d 08 2f          	cmpl   $0x2f,0x8(%ebp)
+  10196a:	7f 07                	jg     101973 <trapname+0x2a>
+        return "Hardware Interrupt";
+  10196c:	b8 ea 37 10 00       	mov    $0x1037ea,%eax
+  101971:	eb 05                	jmp    101978 <trapname+0x2f>
+    }
+    return "(unknown trap)";
+  101973:	b8 fd 37 10 00       	mov    $0x1037fd,%eax
+}
+  101978:	5d                   	pop    %ebp
+  101979:	c3                   	ret    
+
+0010197a <trap_in_kernel>:
+
+/* trap_in_kernel - test if trap happened in kernel */
+bool
+trap_in_kernel(struct trapframe *tf) {
+  10197a:	55                   	push   %ebp
+  10197b:	89 e5                	mov    %esp,%ebp
+    return (tf->tf_cs == (uint16_t)KERNEL_CS);
+  10197d:	8b 45 08             	mov    0x8(%ebp),%eax
+  101980:	0f b7 40 3c          	movzwl 0x3c(%eax),%eax
+  101984:	66 83 f8 08          	cmp    $0x8,%ax
+  101988:	0f 94 c0             	sete   %al
+  10198b:	0f b6 c0             	movzbl %al,%eax
+}
+  10198e:	5d                   	pop    %ebp
+  10198f:	c3                   	ret    
+
+00101990 <print_trapframe>:
+    "TF", "IF", "DF", "OF", NULL, NULL, "NT", NULL,
+    "RF", "VM", "AC", "VIF", "VIP", "ID", NULL, NULL,
+};
+
+void
+print_trapframe(struct trapframe *tf) {
+  101990:	55                   	push   %ebp
+  101991:	89 e5                	mov    %esp,%ebp
+  101993:	83 ec 28             	sub    $0x28,%esp
+    cprintf("trapframe at %p\n", tf);
+  101996:	8b 45 08             	mov    0x8(%ebp),%eax
+  101999:	89 44 24 04          	mov    %eax,0x4(%esp)
+  10199d:	c7 04 24 3e 38 10 00 	movl   $0x10383e,(%esp)
+  1019a4:	e8 b3 e8 ff ff       	call   10025c <cprintf>
+    print_regs(&tf->tf_regs);
+  1019a9:	8b 45 08             	mov    0x8(%ebp),%eax
+  1019ac:	89 04 24             	mov    %eax,(%esp)
+  1019af:	e8 a1 01 00 00       	call   101b55 <print_regs>
+    cprintf("  ds   0x----%04x\n", tf->tf_ds);
+  1019b4:	8b 45 08             	mov    0x8(%ebp),%eax
+  1019b7:	0f b7 40 2c          	movzwl 0x2c(%eax),%eax
+  1019bb:	0f b7 c0             	movzwl %ax,%eax
+  1019be:	89 44 24 04          	mov    %eax,0x4(%esp)
+  1019c2:	c7 04 24 4f 38 10 00 	movl   $0x10384f,(%esp)
+  1019c9:	e8 8e e8 ff ff       	call   10025c <cprintf>
+    cprintf("  es   0x----%04x\n", tf->tf_es);
+  1019ce:	8b 45 08             	mov    0x8(%ebp),%eax
+  1019d1:	0f b7 40 28          	movzwl 0x28(%eax),%eax
+  1019d5:	0f b7 c0             	movzwl %ax,%eax
+  1019d8:	89 44 24 04          	mov    %eax,0x4(%esp)
+  1019dc:	c7 04 24 62 38 10 00 	movl   $0x103862,(%esp)
+  1019e3:	e8 74 e8 ff ff       	call   10025c <cprintf>
+    cprintf("  fs   0x----%04x\n", tf->tf_fs);
+  1019e8:	8b 45 08             	mov    0x8(%ebp),%eax
+  1019eb:	0f b7 40 24          	movzwl 0x24(%eax),%eax
+  1019ef:	0f b7 c0             	movzwl %ax,%eax
+  1019f2:	89 44 24 04          	mov    %eax,0x4(%esp)
+  1019f6:	c7 04 24 75 38 10 00 	movl   $0x103875,(%esp)
+  1019fd:	e8 5a e8 ff ff       	call   10025c <cprintf>
+    cprintf("  gs   0x----%04x\n", tf->tf_gs);
+  101a02:	8b 45 08             	mov    0x8(%ebp),%eax
+  101a05:	0f b7 40 20          	movzwl 0x20(%eax),%eax
+  101a09:	0f b7 c0             	movzwl %ax,%eax
+  101a0c:	89 44 24 04          	mov    %eax,0x4(%esp)
+  101a10:	c7 04 24 88 38 10 00 	movl   $0x103888,(%esp)
+  101a17:	e8 40 e8 ff ff       	call   10025c <cprintf>
+    cprintf("  trap 0x%08x %s\n", tf->tf_trapno, trapname(tf->tf_trapno));
+  101a1c:	8b 45 08             	mov    0x8(%ebp),%eax
+  101a1f:	8b 40 30             	mov    0x30(%eax),%eax
+  101a22:	89 04 24             	mov    %eax,(%esp)
+  101a25:	e8 1f ff ff ff       	call   101949 <trapname>
+  101a2a:	8b 55 08             	mov    0x8(%ebp),%edx
+  101a2d:	8b 52 30             	mov    0x30(%edx),%edx
+  101a30:	89 44 24 08          	mov    %eax,0x8(%esp)
+  101a34:	89 54 24 04          	mov    %edx,0x4(%esp)
+  101a38:	c7 04 24 9b 38 10 00 	movl   $0x10389b,(%esp)
+  101a3f:	e8 18 e8 ff ff       	call   10025c <cprintf>
+    cprintf("  err  0x%08x\n", tf->tf_err);
+  101a44:	8b 45 08             	mov    0x8(%ebp),%eax
+  101a47:	8b 40 34             	mov    0x34(%eax),%eax
+  101a4a:	89 44 24 04          	mov    %eax,0x4(%esp)
+  101a4e:	c7 04 24 ad 38 10 00 	movl   $0x1038ad,(%esp)
+  101a55:	e8 02 e8 ff ff       	call   10025c <cprintf>
+    cprintf("  eip  0x%08x\n", tf->tf_eip);
+  101a5a:	8b 45 08             	mov    0x8(%ebp),%eax
+  101a5d:	8b 40 38             	mov    0x38(%eax),%eax
+  101a60:	89 44 24 04          	mov    %eax,0x4(%esp)
+  101a64:	c7 04 24 bc 38 10 00 	movl   $0x1038bc,(%esp)
+  101a6b:	e8 ec e7 ff ff       	call   10025c <cprintf>
+    cprintf("  cs   0x----%04x\n", tf->tf_cs);
+  101a70:	8b 45 08             	mov    0x8(%ebp),%eax
+  101a73:	0f b7 40 3c          	movzwl 0x3c(%eax),%eax
+  101a77:	0f b7 c0             	movzwl %ax,%eax
+  101a7a:	89 44 24 04          	mov    %eax,0x4(%esp)
+  101a7e:	c7 04 24 cb 38 10 00 	movl   $0x1038cb,(%esp)
+  101a85:	e8 d2 e7 ff ff       	call   10025c <cprintf>
+    cprintf("  flag 0x%08x ", tf->tf_eflags);
+  101a8a:	8b 45 08             	mov    0x8(%ebp),%eax
+  101a8d:	8b 40 40             	mov    0x40(%eax),%eax
+  101a90:	89 44 24 04          	mov    %eax,0x4(%esp)
+  101a94:	c7 04 24 de 38 10 00 	movl   $0x1038de,(%esp)
+  101a9b:	e8 bc e7 ff ff       	call   10025c <cprintf>
+
+    int i, j;
+    for (i = 0, j = 1; i < sizeof(IA32flags) / sizeof(IA32flags[0]); i ++, j <<= 1) {
+  101aa0:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
+  101aa7:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
+  101aae:	eb 3e                	jmp    101aee <print_trapframe+0x15e>
+        if ((tf->tf_eflags & j) && IA32flags[i] != NULL) {
+  101ab0:	8b 45 08             	mov    0x8(%ebp),%eax
+  101ab3:	8b 50 40             	mov    0x40(%eax),%edx
+  101ab6:	8b 45 f0             	mov    -0x10(%ebp),%eax
+  101ab9:	21 d0                	and    %edx,%eax
+  101abb:	85 c0                	test   %eax,%eax
+  101abd:	74 28                	je     101ae7 <print_trapframe+0x157>
+  101abf:	8b 45 f4             	mov    -0xc(%ebp),%eax
+  101ac2:	8b 04 85 80 e5 10 00 	mov    0x10e580(,%eax,4),%eax
+  101ac9:	85 c0                	test   %eax,%eax
+  101acb:	74 1a                	je     101ae7 <print_trapframe+0x157>
+            cprintf("%s,", IA32flags[i]);
+  101acd:	8b 45 f4             	mov    -0xc(%ebp),%eax
+  101ad0:	8b 04 85 80 e5 10 00 	mov    0x10e580(,%eax,4),%eax
+  101ad7:	89 44 24 04          	mov    %eax,0x4(%esp)
+  101adb:	c7 04 24 ed 38 10 00 	movl   $0x1038ed,(%esp)
+  101ae2:	e8 75 e7 ff ff       	call   10025c <cprintf>
+    for (i = 0, j = 1; i < sizeof(IA32flags) / sizeof(IA32flags[0]); i ++, j <<= 1) {
+  101ae7:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
+  101aeb:	d1 65 f0             	shll   -0x10(%ebp)
+  101aee:	8b 45 f4             	mov    -0xc(%ebp),%eax
+  101af1:	83 f8 17             	cmp    $0x17,%eax
+  101af4:	76 ba                	jbe    101ab0 <print_trapframe+0x120>
+        }
+    }
+    cprintf("IOPL=%d\n", (tf->tf_eflags & FL_IOPL_MASK) >> 12);
+  101af6:	8b 45 08             	mov    0x8(%ebp),%eax
+  101af9:	8b 40 40             	mov    0x40(%eax),%eax
+  101afc:	25 00 30 00 00       	and    $0x3000,%eax
+  101b01:	c1 e8 0c             	shr    $0xc,%eax
+  101b04:	89 44 24 04          	mov    %eax,0x4(%esp)
+  101b08:	c7 04 24 f1 38 10 00 	movl   $0x1038f1,(%esp)
+  101b0f:	e8 48 e7 ff ff       	call   10025c <cprintf>
+
+    if (!trap_in_kernel(tf)) {
+  101b14:	8b 45 08             	mov    0x8(%ebp),%eax
+  101b17:	89 04 24             	mov    %eax,(%esp)
+  101b1a:	e8 5b fe ff ff       	call   10197a <trap_in_kernel>
+  101b1f:	85 c0                	test   %eax,%eax
+  101b21:	75 30                	jne    101b53 <print_trapframe+0x1c3>
+        cprintf("  esp  0x%08x\n", tf->tf_esp);
+  101b23:	8b 45 08             	mov    0x8(%ebp),%eax
+  101b26:	8b 40 44             	mov    0x44(%eax),%eax
+  101b29:	89 44 24 04          	mov    %eax,0x4(%esp)
+  101b2d:	c7 04 24 fa 38 10 00 	movl   $0x1038fa,(%esp)
+  101b34:	e8 23 e7 ff ff       	call   10025c <cprintf>
+        cprintf("  ss   0x----%04x\n", tf->tf_ss);
+  101b39:	8b 45 08             	mov    0x8(%ebp),%eax
+  101b3c:	0f b7 40 48          	movzwl 0x48(%eax),%eax
+  101b40:	0f b7 c0             	movzwl %ax,%eax
+  101b43:	89 44 24 04          	mov    %eax,0x4(%esp)
+  101b47:	c7 04 24 09 39 10 00 	movl   $0x103909,(%esp)
+  101b4e:	e8 09 e7 ff ff       	call   10025c <cprintf>
+    }
+}
+  101b53:	c9                   	leave  
+  101b54:	c3                   	ret    
+
+00101b55 <print_regs>:
+
+void
+print_regs(struct pushregs *regs) {
+  101b55:	55                   	push   %ebp
+  101b56:	89 e5                	mov    %esp,%ebp
+  101b58:	83 ec 18             	sub    $0x18,%esp
+    cprintf("  edi  0x%08x\n", regs->reg_edi);
+  101b5b:	8b 45 08             	mov    0x8(%ebp),%eax
+  101b5e:	8b 00                	mov    (%eax),%eax
+  101b60:	89 44 24 04          	mov    %eax,0x4(%esp)
+  101b64:	c7 04 24 1c 39 10 00 	movl   $0x10391c,(%esp)
+  101b6b:	e8 ec e6 ff ff       	call   10025c <cprintf>
+    cprintf("  esi  0x%08x\n", regs->reg_esi);
+  101b70:	8b 45 08             	mov    0x8(%ebp),%eax
+  101b73:	8b 40 04             	mov    0x4(%eax),%eax
+  101b76:	89 44 24 04          	mov    %eax,0x4(%esp)
+  101b7a:	c7 04 24 2b 39 10 00 	movl   $0x10392b,(%esp)
+  101b81:	e8 d6 e6 ff ff       	call   10025c <cprintf>
+    cprintf("  ebp  0x%08x\n", regs->reg_ebp);
+  101b86:	8b 45 08             	mov    0x8(%ebp),%eax
+  101b89:	8b 40 08             	mov    0x8(%eax),%eax
+  101b8c:	89 44 24 04          	mov    %eax,0x4(%esp)
+  101b90:	c7 04 24 3a 39 10 00 	movl   $0x10393a,(%esp)
+  101b97:	e8 c0 e6 ff ff       	call   10025c <cprintf>
+    cprintf("  oesp 0x%08x\n", regs->reg_oesp);
+  101b9c:	8b 45 08             	mov    0x8(%ebp),%eax
+  101b9f:	8b 40 0c             	mov    0xc(%eax),%eax
+  101ba2:	89 44 24 04          	mov    %eax,0x4(%esp)
+  101ba6:	c7 04 24 49 39 10 00 	movl   $0x103949,(%esp)
+  101bad:	e8 aa e6 ff ff       	call   10025c <cprintf>
+    cprintf("  ebx  0x%08x\n", regs->reg_ebx);
+  101bb2:	8b 45 08             	mov    0x8(%ebp),%eax
+  101bb5:	8b 40 10             	mov    0x10(%eax),%eax
+  101bb8:	89 44 24 04          	mov    %eax,0x4(%esp)
+  101bbc:	c7 04 24 58 39 10 00 	movl   $0x103958,(%esp)
+  101bc3:	e8 94 e6 ff ff       	call   10025c <cprintf>
+    cprintf("  edx  0x%08x\n", regs->reg_edx);
+  101bc8:	8b 45 08             	mov    0x8(%ebp),%eax
+  101bcb:	8b 40 14             	mov    0x14(%eax),%eax
+  101bce:	89 44 24 04          	mov    %eax,0x4(%esp)
+  101bd2:	c7 04 24 67 39 10 00 	movl   $0x103967,(%esp)
+  101bd9:	e8 7e e6 ff ff       	call   10025c <cprintf>
+    cprintf("  ecx  0x%08x\n", regs->reg_ecx);
+  101bde:	8b 45 08             	mov    0x8(%ebp),%eax
+  101be1:	8b 40 18             	mov    0x18(%eax),%eax
+  101be4:	89 44 24 04          	mov    %eax,0x4(%esp)
+  101be8:	c7 04 24 76 39 10 00 	movl   $0x103976,(%esp)
+  101bef:	e8 68 e6 ff ff       	call   10025c <cprintf>
+    cprintf("  eax  0x%08x\n", regs->reg_eax);
+  101bf4:	8b 45 08             	mov    0x8(%ebp),%eax
+  101bf7:	8b 40 1c             	mov    0x1c(%eax),%eax
+  101bfa:	89 44 24 04          	mov    %eax,0x4(%esp)
+  101bfe:	c7 04 24 85 39 10 00 	movl   $0x103985,(%esp)
+  101c05:	e8 52 e6 ff ff       	call   10025c <cprintf>
+}
+  101c0a:	c9                   	leave  
+  101c0b:	c3                   	ret    
+
+00101c0c <trap_dispatch>:
+
+/* trap_dispatch - dispatch based on what type of trap occurred */
+static void
+trap_dispatch(struct trapframe *tf) {
+  101c0c:	55                   	push   %ebp
+  101c0d:	89 e5                	mov    %esp,%ebp
+  101c0f:	83 ec 28             	sub    $0x28,%esp
+    char c;
+
+    switch (tf->tf_trapno) {
+  101c12:	8b 45 08             	mov    0x8(%ebp),%eax
+  101c15:	8b 40 30             	mov    0x30(%eax),%eax
+  101c18:	83 f8 2f             	cmp    $0x2f,%eax
+  101c1b:	77 21                	ja     101c3e <trap_dispatch+0x32>
+  101c1d:	83 f8 2e             	cmp    $0x2e,%eax
+  101c20:	0f 83 13 01 00 00    	jae    101d39 <trap_dispatch+0x12d>
+  101c26:	83 f8 21             	cmp    $0x21,%eax
+  101c29:	0f 84 90 00 00 00    	je     101cbf <trap_dispatch+0xb3>
+  101c2f:	83 f8 24             	cmp    $0x24,%eax
+  101c32:	74 65                	je     101c99 <trap_dispatch+0x8d>
+  101c34:	83 f8 20             	cmp    $0x20,%eax
+  101c37:	74 16                	je     101c4f <trap_dispatch+0x43>
+  101c39:	e9 c3 00 00 00       	jmp    101d01 <trap_dispatch+0xf5>
+  101c3e:	83 e8 78             	sub    $0x78,%eax
+  101c41:	83 f8 01             	cmp    $0x1,%eax
+  101c44:	0f 87 b7 00 00 00    	ja     101d01 <trap_dispatch+0xf5>
+  101c4a:	e9 96 00 00 00       	jmp    101ce5 <trap_dispatch+0xd9>
+        /* handle the timer interrupt */
+        /* (1) After a timer interrupt, you should record this event using a global variable (increase it), such as ticks in kern/driver/clock.c
+         * (2) Every TICK_NUM cycle, you can print some info using a funciton, such as print_ticks().
+         * (3) Too Simple? Yes, I think so!
+         */
+		cur_tick++;
+  101c4f:	a1 a0 f0 10 00       	mov    0x10f0a0,%eax
+  101c54:	83 c0 01             	add    $0x1,%eax
+  101c57:	a3 a0 f0 10 00       	mov    %eax,0x10f0a0
+		if(cur_tick % TICK_NUM == 0){
+  101c5c:	8b 0d a0 f0 10 00    	mov    0x10f0a0,%ecx
+  101c62:	ba 1f 85 eb 51       	mov    $0x51eb851f,%edx
+  101c67:	89 c8                	mov    %ecx,%eax
+  101c69:	f7 ea                	imul   %edx
+  101c6b:	c1 fa 05             	sar    $0x5,%edx
+  101c6e:	89 c8                	mov    %ecx,%eax
+  101c70:	c1 f8 1f             	sar    $0x1f,%eax
+  101c73:	29 c2                	sub    %eax,%edx
+  101c75:	89 d0                	mov    %edx,%eax
+  101c77:	6b c0 64             	imul   $0x64,%eax,%eax
+  101c7a:	29 c1                	sub    %eax,%ecx
+  101c7c:	89 c8                	mov    %ecx,%eax
+  101c7e:	85 c0                	test   %eax,%eax
+  101c80:	75 12                	jne    101c94 <trap_dispatch+0x88>
+				print_ticks(cur_tick);
+  101c82:	a1 a0 f0 10 00       	mov    0x10f0a0,%eax
+  101c87:	89 04 24             	mov    %eax,(%esp)
+  101c8a:	e8 7d fb ff ff       	call   10180c <print_ticks>
+		}
+        break;
+  101c8f:	e9 a6 00 00 00       	jmp    101d3a <trap_dispatch+0x12e>
+  101c94:	e9 a1 00 00 00       	jmp    101d3a <trap_dispatch+0x12e>
+    case IRQ_OFFSET + IRQ_COM1:
+        c = cons_getc();
+  101c99:	e8 45 f9 ff ff       	call   1015e3 <cons_getc>
+  101c9e:	88 45 f7             	mov    %al,-0x9(%ebp)
+        cprintf("serial [%03d] %c\n", c, c);
+  101ca1:	0f be 55 f7          	movsbl -0x9(%ebp),%edx
+  101ca5:	0f be 45 f7          	movsbl -0x9(%ebp),%eax
+  101ca9:	89 54 24 08          	mov    %edx,0x8(%esp)
+  101cad:	89 44 24 04          	mov    %eax,0x4(%esp)
+  101cb1:	c7 04 24 94 39 10 00 	movl   $0x103994,(%esp)
+  101cb8:	e8 9f e5 ff ff       	call   10025c <cprintf>
+        break;
+  101cbd:	eb 7b                	jmp    101d3a <trap_dispatch+0x12e>
+    case IRQ_OFFSET + IRQ_KBD:
+        c = cons_getc();
+  101cbf:	e8 1f f9 ff ff       	call   1015e3 <cons_getc>
+  101cc4:	88 45 f7             	mov    %al,-0x9(%ebp)
+        cprintf("kbd [%03d] %c\n", c, c);
+  101cc7:	0f be 55 f7          	movsbl -0x9(%ebp),%edx
+  101ccb:	0f be 45 f7          	movsbl -0x9(%ebp),%eax
+  101ccf:	89 54 24 08          	mov    %edx,0x8(%esp)
+  101cd3:	89 44 24 04          	mov    %eax,0x4(%esp)
+  101cd7:	c7 04 24 a6 39 10 00 	movl   $0x1039a6,(%esp)
+  101cde:	e8 79 e5 ff ff       	call   10025c <cprintf>
+        break;
+  101ce3:	eb 55                	jmp    101d3a <trap_dispatch+0x12e>
+    //LAB1 CHALLENGE 1 : YOUR CODE you should modify below codes.
+    case T_SWITCH_TOU:
+    case T_SWITCH_TOK:
+        panic("T_SWITCH_** ??\n");
+  101ce5:	c7 44 24 08 b5 39 10 	movl   $0x1039b5,0x8(%esp)
+  101cec:	00 
+  101ced:	c7 44 24 04 bc 00 00 	movl   $0xbc,0x4(%esp)
+  101cf4:	00 
+  101cf5:	c7 04 24 c5 39 10 00 	movl   $0x1039c5,(%esp)
+  101cfc:	e8 b2 e6 ff ff       	call   1003b3 <__panic>
+    case IRQ_OFFSET + IRQ_IDE2:
+        /* do nothing */
+        break;
+    default:
+        // in kernel, it must be a mistake
+        if ((tf->tf_cs & 3) == 0) {
+  101d01:	8b 45 08             	mov    0x8(%ebp),%eax
+  101d04:	0f b7 40 3c          	movzwl 0x3c(%eax),%eax
+  101d08:	0f b7 c0             	movzwl %ax,%eax
+  101d0b:	83 e0 03             	and    $0x3,%eax
+  101d0e:	85 c0                	test   %eax,%eax
+  101d10:	75 28                	jne    101d3a <trap_dispatch+0x12e>
+            print_trapframe(tf);
+  101d12:	8b 45 08             	mov    0x8(%ebp),%eax
+  101d15:	89 04 24             	mov    %eax,(%esp)
+  101d18:	e8 73 fc ff ff       	call   101990 <print_trapframe>
+            panic("unexpected trap in kernel.\n");
+  101d1d:	c7 44 24 08 d6 39 10 	movl   $0x1039d6,0x8(%esp)
+  101d24:	00 
+  101d25:	c7 44 24 04 c6 00 00 	movl   $0xc6,0x4(%esp)
+  101d2c:	00 
+  101d2d:	c7 04 24 c5 39 10 00 	movl   $0x1039c5,(%esp)
+  101d34:	e8 7a e6 ff ff       	call   1003b3 <__panic>
+        break;
+  101d39:	90                   	nop
+        }
+    }
+}
+  101d3a:	c9                   	leave  
+  101d3b:	c3                   	ret    
+
+00101d3c <trap>:
+ * trap - handles or dispatches an exception/interrupt. if and when trap() returns,
+ * the code in kern/trap/trapentry.S restores the old CPU state saved in the
+ * trapframe and then uses the iret instruction to return from the exception.
+ * */
+void
+trap(struct trapframe *tf) {
+  101d3c:	55                   	push   %ebp
+  101d3d:	89 e5                	mov    %esp,%ebp
+  101d3f:	83 ec 18             	sub    $0x18,%esp
+    // dispatch based on what type of trap occurred
+    trap_dispatch(tf);
+  101d42:	8b 45 08             	mov    0x8(%ebp),%eax
+  101d45:	89 04 24             	mov    %eax,(%esp)
+  101d48:	e8 bf fe ff ff       	call   101c0c <trap_dispatch>
+}
+  101d4d:	c9                   	leave  
+  101d4e:	c3                   	ret    
+
+00101d4f <vector0>:
+# handler
+.text
+.globl __alltraps
+.globl vector0
+vector0:
+  pushl $0
+  101d4f:	6a 00                	push   $0x0
+  pushl $0
+  101d51:	6a 00                	push   $0x0
+  jmp __alltraps
+  101d53:	e9 69 0a 00 00       	jmp    1027c1 <__alltraps>
+
+00101d58 <vector1>:
+.globl vector1
+vector1:
+  pushl $0
+  101d58:	6a 00                	push   $0x0
+  pushl $1
+  101d5a:	6a 01                	push   $0x1
+  jmp __alltraps
+  101d5c:	e9 60 0a 00 00       	jmp    1027c1 <__alltraps>
+
+00101d61 <vector2>:
+.globl vector2
+vector2:
+  pushl $0
+  101d61:	6a 00                	push   $0x0
+  pushl $2
+  101d63:	6a 02                	push   $0x2
+  jmp __alltraps
+  101d65:	e9 57 0a 00 00       	jmp    1027c1 <__alltraps>
+
+00101d6a <vector3>:
+.globl vector3
+vector3:
+  pushl $0
+  101d6a:	6a 00                	push   $0x0
+  pushl $3
+  101d6c:	6a 03                	push   $0x3
+  jmp __alltraps
+  101d6e:	e9 4e 0a 00 00       	jmp    1027c1 <__alltraps>
+
+00101d73 <vector4>:
+.globl vector4
+vector4:
+  pushl $0
+  101d73:	6a 00                	push   $0x0
+  pushl $4
+  101d75:	6a 04                	push   $0x4
+  jmp __alltraps
+  101d77:	e9 45 0a 00 00       	jmp    1027c1 <__alltraps>
+
+00101d7c <vector5>:
+.globl vector5
+vector5:
+  pushl $0
+  101d7c:	6a 00                	push   $0x0
+  pushl $5
+  101d7e:	6a 05                	push   $0x5
+  jmp __alltraps
+  101d80:	e9 3c 0a 00 00       	jmp    1027c1 <__alltraps>
+
+00101d85 <vector6>:
+.globl vector6
+vector6:
+  pushl $0
+  101d85:	6a 00                	push   $0x0
+  pushl $6
+  101d87:	6a 06                	push   $0x6
+  jmp __alltraps
+  101d89:	e9 33 0a 00 00       	jmp    1027c1 <__alltraps>
+
+00101d8e <vector7>:
+.globl vector7
+vector7:
+  pushl $0
+  101d8e:	6a 00                	push   $0x0
+  pushl $7
+  101d90:	6a 07                	push   $0x7
+  jmp __alltraps
+  101d92:	e9 2a 0a 00 00       	jmp    1027c1 <__alltraps>
+
+00101d97 <vector8>:
+.globl vector8
+vector8:
+  pushl $8
+  101d97:	6a 08                	push   $0x8
+  jmp __alltraps
+  101d99:	e9 23 0a 00 00       	jmp    1027c1 <__alltraps>
+
+00101d9e <vector9>:
+.globl vector9
+vector9:
+  pushl $0
+  101d9e:	6a 00                	push   $0x0
+  pushl $9
+  101da0:	6a 09                	push   $0x9
+  jmp __alltraps
+  101da2:	e9 1a 0a 00 00       	jmp    1027c1 <__alltraps>
+
+00101da7 <vector10>:
+.globl vector10
+vector10:
+  pushl $10
+  101da7:	6a 0a                	push   $0xa
+  jmp __alltraps
+  101da9:	e9 13 0a 00 00       	jmp    1027c1 <__alltraps>
+
+00101dae <vector11>:
+.globl vector11
+vector11:
+  pushl $11
+  101dae:	6a 0b                	push   $0xb
+  jmp __alltraps
+  101db0:	e9 0c 0a 00 00       	jmp    1027c1 <__alltraps>
+
+00101db5 <vector12>:
+.globl vector12
+vector12:
+  pushl $12
+  101db5:	6a 0c                	push   $0xc
+  jmp __alltraps
+  101db7:	e9 05 0a 00 00       	jmp    1027c1 <__alltraps>
+
+00101dbc <vector13>:
+.globl vector13
+vector13:
+  pushl $13
+  101dbc:	6a 0d                	push   $0xd
+  jmp __alltraps
+  101dbe:	e9 fe 09 00 00       	jmp    1027c1 <__alltraps>
+
+00101dc3 <vector14>:
+.globl vector14
+vector14:
+  pushl $14
+  101dc3:	6a 0e                	push   $0xe
+  jmp __alltraps
+  101dc5:	e9 f7 09 00 00       	jmp    1027c1 <__alltraps>
+
+00101dca <vector15>:
+.globl vector15
+vector15:
+  pushl $0
+  101dca:	6a 00                	push   $0x0
+  pushl $15
+  101dcc:	6a 0f                	push   $0xf
+  jmp __alltraps
+  101dce:	e9 ee 09 00 00       	jmp    1027c1 <__alltraps>
+
+00101dd3 <vector16>:
+.globl vector16
+vector16:
+  pushl $0
+  101dd3:	6a 00                	push   $0x0
+  pushl $16
+  101dd5:	6a 10                	push   $0x10
+  jmp __alltraps
+  101dd7:	e9 e5 09 00 00       	jmp    1027c1 <__alltraps>
+
+00101ddc <vector17>:
+.globl vector17
+vector17:
+  pushl $17
+  101ddc:	6a 11                	push   $0x11
+  jmp __alltraps
+  101dde:	e9 de 09 00 00       	jmp    1027c1 <__alltraps>
+
+00101de3 <vector18>:
+.globl vector18
+vector18:
+  pushl $0
+  101de3:	6a 00                	push   $0x0
+  pushl $18
+  101de5:	6a 12                	push   $0x12
+  jmp __alltraps
+  101de7:	e9 d5 09 00 00       	jmp    1027c1 <__alltraps>
+
+00101dec <vector19>:
+.globl vector19
+vector19:
+  pushl $0
+  101dec:	6a 00                	push   $0x0
+  pushl $19
+  101dee:	6a 13                	push   $0x13
+  jmp __alltraps
+  101df0:	e9 cc 09 00 00       	jmp    1027c1 <__alltraps>
+
+00101df5 <vector20>:
+.globl vector20
+vector20:
+  pushl $0
+  101df5:	6a 00                	push   $0x0
+  pushl $20
+  101df7:	6a 14                	push   $0x14
+  jmp __alltraps
+  101df9:	e9 c3 09 00 00       	jmp    1027c1 <__alltraps>
+
+00101dfe <vector21>:
+.globl vector21
+vector21:
+  pushl $0
+  101dfe:	6a 00                	push   $0x0
+  pushl $21
+  101e00:	6a 15                	push   $0x15
+  jmp __alltraps
+  101e02:	e9 ba 09 00 00       	jmp    1027c1 <__alltraps>
+
+00101e07 <vector22>:
+.globl vector22
+vector22:
+  pushl $0
+  101e07:	6a 00                	push   $0x0
+  pushl $22
+  101e09:	6a 16                	push   $0x16
+  jmp __alltraps
+  101e0b:	e9 b1 09 00 00       	jmp    1027c1 <__alltraps>
+
+00101e10 <vector23>:
+.globl vector23
+vector23:
+  pushl $0
+  101e10:	6a 00                	push   $0x0
+  pushl $23
+  101e12:	6a 17                	push   $0x17
+  jmp __alltraps
+  101e14:	e9 a8 09 00 00       	jmp    1027c1 <__alltraps>
+
+00101e19 <vector24>:
+.globl vector24
+vector24:
+  pushl $0
+  101e19:	6a 00                	push   $0x0
+  pushl $24
+  101e1b:	6a 18                	push   $0x18
+  jmp __alltraps
+  101e1d:	e9 9f 09 00 00       	jmp    1027c1 <__alltraps>
+
+00101e22 <vector25>:
+.globl vector25
+vector25:
+  pushl $0
+  101e22:	6a 00                	push   $0x0
+  pushl $25
+  101e24:	6a 19                	push   $0x19
+  jmp __alltraps
+  101e26:	e9 96 09 00 00       	jmp    1027c1 <__alltraps>
+
+00101e2b <vector26>:
+.globl vector26
+vector26:
+  pushl $0
+  101e2b:	6a 00                	push   $0x0
+  pushl $26
+  101e2d:	6a 1a                	push   $0x1a
+  jmp __alltraps
+  101e2f:	e9 8d 09 00 00       	jmp    1027c1 <__alltraps>
+
+00101e34 <vector27>:
+.globl vector27
+vector27:
+  pushl $0
+  101e34:	6a 00                	push   $0x0
+  pushl $27
+  101e36:	6a 1b                	push   $0x1b
+  jmp __alltraps
+  101e38:	e9 84 09 00 00       	jmp    1027c1 <__alltraps>
+
+00101e3d <vector28>:
+.globl vector28
+vector28:
+  pushl $0
+  101e3d:	6a 00                	push   $0x0
+  pushl $28
+  101e3f:	6a 1c                	push   $0x1c
+  jmp __alltraps
+  101e41:	e9 7b 09 00 00       	jmp    1027c1 <__alltraps>
+
+00101e46 <vector29>:
+.globl vector29
+vector29:
+  pushl $0
+  101e46:	6a 00                	push   $0x0
+  pushl $29
+  101e48:	6a 1d                	push   $0x1d
+  jmp __alltraps
+  101e4a:	e9 72 09 00 00       	jmp    1027c1 <__alltraps>
+
+00101e4f <vector30>:
+.globl vector30
+vector30:
+  pushl $0
+  101e4f:	6a 00                	push   $0x0
+  pushl $30
+  101e51:	6a 1e                	push   $0x1e
+  jmp __alltraps
+  101e53:	e9 69 09 00 00       	jmp    1027c1 <__alltraps>
+
+00101e58 <vector31>:
+.globl vector31
+vector31:
+  pushl $0
+  101e58:	6a 00                	push   $0x0
+  pushl $31
+  101e5a:	6a 1f                	push   $0x1f
+  jmp __alltraps
+  101e5c:	e9 60 09 00 00       	jmp    1027c1 <__alltraps>
+
+00101e61 <vector32>:
+.globl vector32
+vector32:
+  pushl $0
+  101e61:	6a 00                	push   $0x0
+  pushl $32
+  101e63:	6a 20                	push   $0x20
+  jmp __alltraps
+  101e65:	e9 57 09 00 00       	jmp    1027c1 <__alltraps>
+
+00101e6a <vector33>:
+.globl vector33
+vector33:
+  pushl $0
+  101e6a:	6a 00                	push   $0x0
+  pushl $33
+  101e6c:	6a 21                	push   $0x21
+  jmp __alltraps
+  101e6e:	e9 4e 09 00 00       	jmp    1027c1 <__alltraps>
+
+00101e73 <vector34>:
+.globl vector34
+vector34:
+  pushl $0
+  101e73:	6a 00                	push   $0x0
+  pushl $34
+  101e75:	6a 22                	push   $0x22
+  jmp __alltraps
+  101e77:	e9 45 09 00 00       	jmp    1027c1 <__alltraps>
+
+00101e7c <vector35>:
+.globl vector35
+vector35:
+  pushl $0
+  101e7c:	6a 00                	push   $0x0
+  pushl $35
+  101e7e:	6a 23                	push   $0x23
+  jmp __alltraps
+  101e80:	e9 3c 09 00 00       	jmp    1027c1 <__alltraps>
+
+00101e85 <vector36>:
+.globl vector36
+vector36:
+  pushl $0
+  101e85:	6a 00                	push   $0x0
+  pushl $36
+  101e87:	6a 24                	push   $0x24
+  jmp __alltraps
+  101e89:	e9 33 09 00 00       	jmp    1027c1 <__alltraps>
+
+00101e8e <vector37>:
+.globl vector37
+vector37:
+  pushl $0
+  101e8e:	6a 00                	push   $0x0
+  pushl $37
+  101e90:	6a 25                	push   $0x25
+  jmp __alltraps
+  101e92:	e9 2a 09 00 00       	jmp    1027c1 <__alltraps>
+
+00101e97 <vector38>:
+.globl vector38
+vector38:
+  pushl $0
+  101e97:	6a 00                	push   $0x0
+  pushl $38
+  101e99:	6a 26                	push   $0x26
+  jmp __alltraps
+  101e9b:	e9 21 09 00 00       	jmp    1027c1 <__alltraps>
+
+00101ea0 <vector39>:
+.globl vector39
+vector39:
+  pushl $0
+  101ea0:	6a 00                	push   $0x0
+  pushl $39
+  101ea2:	6a 27                	push   $0x27
+  jmp __alltraps
+  101ea4:	e9 18 09 00 00       	jmp    1027c1 <__alltraps>
+
+00101ea9 <vector40>:
+.globl vector40
+vector40:
+  pushl $0
+  101ea9:	6a 00                	push   $0x0
+  pushl $40
+  101eab:	6a 28                	push   $0x28
+  jmp __alltraps
+  101ead:	e9 0f 09 00 00       	jmp    1027c1 <__alltraps>
+
+00101eb2 <vector41>:
+.globl vector41
+vector41:
+  pushl $0
+  101eb2:	6a 00                	push   $0x0
+  pushl $41
+  101eb4:	6a 29                	push   $0x29
+  jmp __alltraps
+  101eb6:	e9 06 09 00 00       	jmp    1027c1 <__alltraps>
+
+00101ebb <vector42>:
+.globl vector42
+vector42:
+  pushl $0
+  101ebb:	6a 00                	push   $0x0
+  pushl $42
+  101ebd:	6a 2a                	push   $0x2a
+  jmp __alltraps
+  101ebf:	e9 fd 08 00 00       	jmp    1027c1 <__alltraps>
+
+00101ec4 <vector43>:
+.globl vector43
+vector43:
+  pushl $0
+  101ec4:	6a 00                	push   $0x0
+  pushl $43
+  101ec6:	6a 2b                	push   $0x2b
+  jmp __alltraps
+  101ec8:	e9 f4 08 00 00       	jmp    1027c1 <__alltraps>
+
+00101ecd <vector44>:
+.globl vector44
+vector44:
+  pushl $0
+  101ecd:	6a 00                	push   $0x0
+  pushl $44
+  101ecf:	6a 2c                	push   $0x2c
+  jmp __alltraps
+  101ed1:	e9 eb 08 00 00       	jmp    1027c1 <__alltraps>
+
+00101ed6 <vector45>:
+.globl vector45
+vector45:
+  pushl $0
+  101ed6:	6a 00                	push   $0x0
+  pushl $45
+  101ed8:	6a 2d                	push   $0x2d
+  jmp __alltraps
+  101eda:	e9 e2 08 00 00       	jmp    1027c1 <__alltraps>
+
+00101edf <vector46>:
+.globl vector46
+vector46:
+  pushl $0
+  101edf:	6a 00                	push   $0x0
+  pushl $46
+  101ee1:	6a 2e                	push   $0x2e
+  jmp __alltraps
+  101ee3:	e9 d9 08 00 00       	jmp    1027c1 <__alltraps>
+
+00101ee8 <vector47>:
+.globl vector47
+vector47:
+  pushl $0
+  101ee8:	6a 00                	push   $0x0
+  pushl $47
+  101eea:	6a 2f                	push   $0x2f
+  jmp __alltraps
+  101eec:	e9 d0 08 00 00       	jmp    1027c1 <__alltraps>
+
+00101ef1 <vector48>:
+.globl vector48
+vector48:
+  pushl $0
+  101ef1:	6a 00                	push   $0x0
+  pushl $48
+  101ef3:	6a 30                	push   $0x30
+  jmp __alltraps
+  101ef5:	e9 c7 08 00 00       	jmp    1027c1 <__alltraps>
+
+00101efa <vector49>:
+.globl vector49
+vector49:
+  pushl $0
+  101efa:	6a 00                	push   $0x0
+  pushl $49
+  101efc:	6a 31                	push   $0x31
+  jmp __alltraps
+  101efe:	e9 be 08 00 00       	jmp    1027c1 <__alltraps>
+
+00101f03 <vector50>:
+.globl vector50
+vector50:
+  pushl $0
+  101f03:	6a 00                	push   $0x0
+  pushl $50
+  101f05:	6a 32                	push   $0x32
+  jmp __alltraps
+  101f07:	e9 b5 08 00 00       	jmp    1027c1 <__alltraps>
+
+00101f0c <vector51>:
+.globl vector51
+vector51:
+  pushl $0
+  101f0c:	6a 00                	push   $0x0
+  pushl $51
+  101f0e:	6a 33                	push   $0x33
+  jmp __alltraps
+  101f10:	e9 ac 08 00 00       	jmp    1027c1 <__alltraps>
+
+00101f15 <vector52>:
+.globl vector52
+vector52:
+  pushl $0
+  101f15:	6a 00                	push   $0x0
+  pushl $52
+  101f17:	6a 34                	push   $0x34
+  jmp __alltraps
+  101f19:	e9 a3 08 00 00       	jmp    1027c1 <__alltraps>
+
+00101f1e <vector53>:
+.globl vector53
+vector53:
+  pushl $0
+  101f1e:	6a 00                	push   $0x0
+  pushl $53
+  101f20:	6a 35                	push   $0x35
+  jmp __alltraps
+  101f22:	e9 9a 08 00 00       	jmp    1027c1 <__alltraps>
+
+00101f27 <vector54>:
+.globl vector54
+vector54:
+  pushl $0
+  101f27:	6a 00                	push   $0x0
+  pushl $54
+  101f29:	6a 36                	push   $0x36
+  jmp __alltraps
+  101f2b:	e9 91 08 00 00       	jmp    1027c1 <__alltraps>
+
+00101f30 <vector55>:
+.globl vector55
+vector55:
+  pushl $0
+  101f30:	6a 00                	push   $0x0
+  pushl $55
+  101f32:	6a 37                	push   $0x37
+  jmp __alltraps
+  101f34:	e9 88 08 00 00       	jmp    1027c1 <__alltraps>
+
+00101f39 <vector56>:
+.globl vector56
+vector56:
+  pushl $0
+  101f39:	6a 00                	push   $0x0
+  pushl $56
+  101f3b:	6a 38                	push   $0x38
+  jmp __alltraps
+  101f3d:	e9 7f 08 00 00       	jmp    1027c1 <__alltraps>
+
+00101f42 <vector57>:
+.globl vector57
+vector57:
+  pushl $0
+  101f42:	6a 00                	push   $0x0
+  pushl $57
+  101f44:	6a 39                	push   $0x39
+  jmp __alltraps
+  101f46:	e9 76 08 00 00       	jmp    1027c1 <__alltraps>
+
+00101f4b <vector58>:
+.globl vector58
+vector58:
+  pushl $0
+  101f4b:	6a 00                	push   $0x0
+  pushl $58
+  101f4d:	6a 3a                	push   $0x3a
+  jmp __alltraps
+  101f4f:	e9 6d 08 00 00       	jmp    1027c1 <__alltraps>
+
+00101f54 <vector59>:
+.globl vector59
+vector59:
+  pushl $0
+  101f54:	6a 00                	push   $0x0
+  pushl $59
+  101f56:	6a 3b                	push   $0x3b
+  jmp __alltraps
+  101f58:	e9 64 08 00 00       	jmp    1027c1 <__alltraps>
+
+00101f5d <vector60>:
+.globl vector60
+vector60:
+  pushl $0
+  101f5d:	6a 00                	push   $0x0
+  pushl $60
+  101f5f:	6a 3c                	push   $0x3c
+  jmp __alltraps
+  101f61:	e9 5b 08 00 00       	jmp    1027c1 <__alltraps>
+
+00101f66 <vector61>:
+.globl vector61
+vector61:
+  pushl $0
+  101f66:	6a 00                	push   $0x0
+  pushl $61
+  101f68:	6a 3d                	push   $0x3d
+  jmp __alltraps
+  101f6a:	e9 52 08 00 00       	jmp    1027c1 <__alltraps>
+
+00101f6f <vector62>:
+.globl vector62
+vector62:
+  pushl $0
+  101f6f:	6a 00                	push   $0x0
+  pushl $62
+  101f71:	6a 3e                	push   $0x3e
+  jmp __alltraps
+  101f73:	e9 49 08 00 00       	jmp    1027c1 <__alltraps>
+
+00101f78 <vector63>:
+.globl vector63
+vector63:
+  pushl $0
+  101f78:	6a 00                	push   $0x0
+  pushl $63
+  101f7a:	6a 3f                	push   $0x3f
+  jmp __alltraps
+  101f7c:	e9 40 08 00 00       	jmp    1027c1 <__alltraps>
+
+00101f81 <vector64>:
+.globl vector64
+vector64:
+  pushl $0
+  101f81:	6a 00                	push   $0x0
+  pushl $64
+  101f83:	6a 40                	push   $0x40
+  jmp __alltraps
+  101f85:	e9 37 08 00 00       	jmp    1027c1 <__alltraps>
+
+00101f8a <vector65>:
+.globl vector65
+vector65:
+  pushl $0
+  101f8a:	6a 00                	push   $0x0
+  pushl $65
+  101f8c:	6a 41                	push   $0x41
+  jmp __alltraps
+  101f8e:	e9 2e 08 00 00       	jmp    1027c1 <__alltraps>
+
+00101f93 <vector66>:
+.globl vector66
+vector66:
+  pushl $0
+  101f93:	6a 00                	push   $0x0
+  pushl $66
+  101f95:	6a 42                	push   $0x42
+  jmp __alltraps
+  101f97:	e9 25 08 00 00       	jmp    1027c1 <__alltraps>
+
+00101f9c <vector67>:
+.globl vector67
+vector67:
+  pushl $0
+  101f9c:	6a 00                	push   $0x0
+  pushl $67
+  101f9e:	6a 43                	push   $0x43
+  jmp __alltraps
+  101fa0:	e9 1c 08 00 00       	jmp    1027c1 <__alltraps>
+
+00101fa5 <vector68>:
+.globl vector68
+vector68:
+  pushl $0
+  101fa5:	6a 00                	push   $0x0
+  pushl $68
+  101fa7:	6a 44                	push   $0x44
+  jmp __alltraps
+  101fa9:	e9 13 08 00 00       	jmp    1027c1 <__alltraps>
+
+00101fae <vector69>:
+.globl vector69
+vector69:
+  pushl $0
+  101fae:	6a 00                	push   $0x0
+  pushl $69
+  101fb0:	6a 45                	push   $0x45
+  jmp __alltraps
+  101fb2:	e9 0a 08 00 00       	jmp    1027c1 <__alltraps>
+
+00101fb7 <vector70>:
+.globl vector70
+vector70:
+  pushl $0
+  101fb7:	6a 00                	push   $0x0
+  pushl $70
+  101fb9:	6a 46                	push   $0x46
+  jmp __alltraps
+  101fbb:	e9 01 08 00 00       	jmp    1027c1 <__alltraps>
+
+00101fc0 <vector71>:
+.globl vector71
+vector71:
+  pushl $0
+  101fc0:	6a 00                	push   $0x0
+  pushl $71
+  101fc2:	6a 47                	push   $0x47
+  jmp __alltraps
+  101fc4:	e9 f8 07 00 00       	jmp    1027c1 <__alltraps>
+
+00101fc9 <vector72>:
+.globl vector72
+vector72:
+  pushl $0
+  101fc9:	6a 00                	push   $0x0
+  pushl $72
+  101fcb:	6a 48                	push   $0x48
+  jmp __alltraps
+  101fcd:	e9 ef 07 00 00       	jmp    1027c1 <__alltraps>
+
+00101fd2 <vector73>:
+.globl vector73
+vector73:
+  pushl $0
+  101fd2:	6a 00                	push   $0x0
+  pushl $73
+  101fd4:	6a 49                	push   $0x49
+  jmp __alltraps
+  101fd6:	e9 e6 07 00 00       	jmp    1027c1 <__alltraps>
+
+00101fdb <vector74>:
+.globl vector74
+vector74:
+  pushl $0
+  101fdb:	6a 00                	push   $0x0
+  pushl $74
+  101fdd:	6a 4a                	push   $0x4a
+  jmp __alltraps
+  101fdf:	e9 dd 07 00 00       	jmp    1027c1 <__alltraps>
+
+00101fe4 <vector75>:
+.globl vector75
+vector75:
+  pushl $0
+  101fe4:	6a 00                	push   $0x0
+  pushl $75
+  101fe6:	6a 4b                	push   $0x4b
+  jmp __alltraps
+  101fe8:	e9 d4 07 00 00       	jmp    1027c1 <__alltraps>
+
+00101fed <vector76>:
+.globl vector76
+vector76:
+  pushl $0
+  101fed:	6a 00                	push   $0x0
+  pushl $76
+  101fef:	6a 4c                	push   $0x4c
+  jmp __alltraps
+  101ff1:	e9 cb 07 00 00       	jmp    1027c1 <__alltraps>
+
+00101ff6 <vector77>:
+.globl vector77
+vector77:
+  pushl $0
+  101ff6:	6a 00                	push   $0x0
+  pushl $77
+  101ff8:	6a 4d                	push   $0x4d
+  jmp __alltraps
+  101ffa:	e9 c2 07 00 00       	jmp    1027c1 <__alltraps>
+
+00101fff <vector78>:
+.globl vector78
+vector78:
+  pushl $0
+  101fff:	6a 00                	push   $0x0
+  pushl $78
+  102001:	6a 4e                	push   $0x4e
+  jmp __alltraps
+  102003:	e9 b9 07 00 00       	jmp    1027c1 <__alltraps>
+
+00102008 <vector79>:
+.globl vector79
+vector79:
+  pushl $0
+  102008:	6a 00                	push   $0x0
+  pushl $79
+  10200a:	6a 4f                	push   $0x4f
+  jmp __alltraps
+  10200c:	e9 b0 07 00 00       	jmp    1027c1 <__alltraps>
+
+00102011 <vector80>:
+.globl vector80
+vector80:
+  pushl $0
+  102011:	6a 00                	push   $0x0
+  pushl $80
+  102013:	6a 50                	push   $0x50
+  jmp __alltraps
+  102015:	e9 a7 07 00 00       	jmp    1027c1 <__alltraps>
+
+0010201a <vector81>:
+.globl vector81
+vector81:
+  pushl $0
+  10201a:	6a 00                	push   $0x0
+  pushl $81
+  10201c:	6a 51                	push   $0x51
+  jmp __alltraps
+  10201e:	e9 9e 07 00 00       	jmp    1027c1 <__alltraps>
+
+00102023 <vector82>:
+.globl vector82
+vector82:
+  pushl $0
+  102023:	6a 00                	push   $0x0
+  pushl $82
+  102025:	6a 52                	push   $0x52
+  jmp __alltraps
+  102027:	e9 95 07 00 00       	jmp    1027c1 <__alltraps>
+
+0010202c <vector83>:
+.globl vector83
+vector83:
+  pushl $0
+  10202c:	6a 00                	push   $0x0
+  pushl $83
+  10202e:	6a 53                	push   $0x53
+  jmp __alltraps
+  102030:	e9 8c 07 00 00       	jmp    1027c1 <__alltraps>
+
+00102035 <vector84>:
+.globl vector84
+vector84:
+  pushl $0
+  102035:	6a 00                	push   $0x0
+  pushl $84
+  102037:	6a 54                	push   $0x54
+  jmp __alltraps
+  102039:	e9 83 07 00 00       	jmp    1027c1 <__alltraps>
+
+0010203e <vector85>:
+.globl vector85
+vector85:
+  pushl $0
+  10203e:	6a 00                	push   $0x0
+  pushl $85
+  102040:	6a 55                	push   $0x55
+  jmp __alltraps
+  102042:	e9 7a 07 00 00       	jmp    1027c1 <__alltraps>
+
+00102047 <vector86>:
+.globl vector86
+vector86:
+  pushl $0
+  102047:	6a 00                	push   $0x0
+  pushl $86
+  102049:	6a 56                	push   $0x56
+  jmp __alltraps
+  10204b:	e9 71 07 00 00       	jmp    1027c1 <__alltraps>
+
+00102050 <vector87>:
+.globl vector87
+vector87:
+  pushl $0
+  102050:	6a 00                	push   $0x0
+  pushl $87
+  102052:	6a 57                	push   $0x57
+  jmp __alltraps
+  102054:	e9 68 07 00 00       	jmp    1027c1 <__alltraps>
+
+00102059 <vector88>:
+.globl vector88
+vector88:
+  pushl $0
+  102059:	6a 00                	push   $0x0
+  pushl $88
+  10205b:	6a 58                	push   $0x58
+  jmp __alltraps
+  10205d:	e9 5f 07 00 00       	jmp    1027c1 <__alltraps>
+
+00102062 <vector89>:
+.globl vector89
+vector89:
+  pushl $0
+  102062:	6a 00                	push   $0x0
+  pushl $89
+  102064:	6a 59                	push   $0x59
+  jmp __alltraps
+  102066:	e9 56 07 00 00       	jmp    1027c1 <__alltraps>
+
+0010206b <vector90>:
+.globl vector90
+vector90:
+  pushl $0
+  10206b:	6a 00                	push   $0x0
+  pushl $90
+  10206d:	6a 5a                	push   $0x5a
+  jmp __alltraps
+  10206f:	e9 4d 07 00 00       	jmp    1027c1 <__alltraps>
+
+00102074 <vector91>:
+.globl vector91
+vector91:
+  pushl $0
+  102074:	6a 00                	push   $0x0
+  pushl $91
+  102076:	6a 5b                	push   $0x5b
+  jmp __alltraps
+  102078:	e9 44 07 00 00       	jmp    1027c1 <__alltraps>
+
+0010207d <vector92>:
+.globl vector92
+vector92:
+  pushl $0
+  10207d:	6a 00                	push   $0x0
+  pushl $92
+  10207f:	6a 5c                	push   $0x5c
+  jmp __alltraps
+  102081:	e9 3b 07 00 00       	jmp    1027c1 <__alltraps>
+
+00102086 <vector93>:
+.globl vector93
+vector93:
+  pushl $0
+  102086:	6a 00                	push   $0x0
+  pushl $93
+  102088:	6a 5d                	push   $0x5d
+  jmp __alltraps
+  10208a:	e9 32 07 00 00       	jmp    1027c1 <__alltraps>
+
+0010208f <vector94>:
+.globl vector94
+vector94:
+  pushl $0
+  10208f:	6a 00                	push   $0x0
+  pushl $94
+  102091:	6a 5e                	push   $0x5e
+  jmp __alltraps
+  102093:	e9 29 07 00 00       	jmp    1027c1 <__alltraps>
+
+00102098 <vector95>:
+.globl vector95
+vector95:
+  pushl $0
+  102098:	6a 00                	push   $0x0
+  pushl $95
+  10209a:	6a 5f                	push   $0x5f
+  jmp __alltraps
+  10209c:	e9 20 07 00 00       	jmp    1027c1 <__alltraps>
+
+001020a1 <vector96>:
+.globl vector96
+vector96:
+  pushl $0
+  1020a1:	6a 00                	push   $0x0
+  pushl $96
+  1020a3:	6a 60                	push   $0x60
+  jmp __alltraps
+  1020a5:	e9 17 07 00 00       	jmp    1027c1 <__alltraps>
+
+001020aa <vector97>:
+.globl vector97
+vector97:
+  pushl $0
+  1020aa:	6a 00                	push   $0x0
+  pushl $97
+  1020ac:	6a 61                	push   $0x61
+  jmp __alltraps
+  1020ae:	e9 0e 07 00 00       	jmp    1027c1 <__alltraps>
+
+001020b3 <vector98>:
+.globl vector98
+vector98:
+  pushl $0
+  1020b3:	6a 00                	push   $0x0
+  pushl $98
+  1020b5:	6a 62                	push   $0x62
+  jmp __alltraps
+  1020b7:	e9 05 07 00 00       	jmp    1027c1 <__alltraps>
+
+001020bc <vector99>:
+.globl vector99
+vector99:
+  pushl $0
+  1020bc:	6a 00                	push   $0x0
+  pushl $99
+  1020be:	6a 63                	push   $0x63
+  jmp __alltraps
+  1020c0:	e9 fc 06 00 00       	jmp    1027c1 <__alltraps>
+
+001020c5 <vector100>:
+.globl vector100
+vector100:
+  pushl $0
+  1020c5:	6a 00                	push   $0x0
+  pushl $100
+  1020c7:	6a 64                	push   $0x64
+  jmp __alltraps
+  1020c9:	e9 f3 06 00 00       	jmp    1027c1 <__alltraps>
+
+001020ce <vector101>:
+.globl vector101
+vector101:
+  pushl $0
+  1020ce:	6a 00                	push   $0x0
+  pushl $101
+  1020d0:	6a 65                	push   $0x65
+  jmp __alltraps
+  1020d2:	e9 ea 06 00 00       	jmp    1027c1 <__alltraps>
+
+001020d7 <vector102>:
+.globl vector102
+vector102:
+  pushl $0
+  1020d7:	6a 00                	push   $0x0
+  pushl $102
+  1020d9:	6a 66                	push   $0x66
+  jmp __alltraps
+  1020db:	e9 e1 06 00 00       	jmp    1027c1 <__alltraps>
+
+001020e0 <vector103>:
+.globl vector103
+vector103:
+  pushl $0
+  1020e0:	6a 00                	push   $0x0
+  pushl $103
+  1020e2:	6a 67                	push   $0x67
+  jmp __alltraps
+  1020e4:	e9 d8 06 00 00       	jmp    1027c1 <__alltraps>
+
+001020e9 <vector104>:
+.globl vector104
+vector104:
+  pushl $0
+  1020e9:	6a 00                	push   $0x0
+  pushl $104
+  1020eb:	6a 68                	push   $0x68
+  jmp __alltraps
+  1020ed:	e9 cf 06 00 00       	jmp    1027c1 <__alltraps>
+
+001020f2 <vector105>:
+.globl vector105
+vector105:
+  pushl $0
+  1020f2:	6a 00                	push   $0x0
+  pushl $105
+  1020f4:	6a 69                	push   $0x69
+  jmp __alltraps
+  1020f6:	e9 c6 06 00 00       	jmp    1027c1 <__alltraps>
+
+001020fb <vector106>:
+.globl vector106
+vector106:
+  pushl $0
+  1020fb:	6a 00                	push   $0x0
+  pushl $106
+  1020fd:	6a 6a                	push   $0x6a
+  jmp __alltraps
+  1020ff:	e9 bd 06 00 00       	jmp    1027c1 <__alltraps>
+
+00102104 <vector107>:
+.globl vector107
+vector107:
+  pushl $0
+  102104:	6a 00                	push   $0x0
+  pushl $107
+  102106:	6a 6b                	push   $0x6b
+  jmp __alltraps
+  102108:	e9 b4 06 00 00       	jmp    1027c1 <__alltraps>
+
+0010210d <vector108>:
+.globl vector108
+vector108:
+  pushl $0
+  10210d:	6a 00                	push   $0x0
+  pushl $108
+  10210f:	6a 6c                	push   $0x6c
+  jmp __alltraps
+  102111:	e9 ab 06 00 00       	jmp    1027c1 <__alltraps>
+
+00102116 <vector109>:
+.globl vector109
+vector109:
+  pushl $0
+  102116:	6a 00                	push   $0x0
+  pushl $109
+  102118:	6a 6d                	push   $0x6d
+  jmp __alltraps
+  10211a:	e9 a2 06 00 00       	jmp    1027c1 <__alltraps>
+
+0010211f <vector110>:
+.globl vector110
+vector110:
+  pushl $0
+  10211f:	6a 00                	push   $0x0
+  pushl $110
+  102121:	6a 6e                	push   $0x6e
+  jmp __alltraps
+  102123:	e9 99 06 00 00       	jmp    1027c1 <__alltraps>
+
+00102128 <vector111>:
+.globl vector111
+vector111:
+  pushl $0
+  102128:	6a 00                	push   $0x0
+  pushl $111
+  10212a:	6a 6f                	push   $0x6f
+  jmp __alltraps
+  10212c:	e9 90 06 00 00       	jmp    1027c1 <__alltraps>
+
+00102131 <vector112>:
+.globl vector112
+vector112:
+  pushl $0
+  102131:	6a 00                	push   $0x0
+  pushl $112
+  102133:	6a 70                	push   $0x70
+  jmp __alltraps
+  102135:	e9 87 06 00 00       	jmp    1027c1 <__alltraps>
+
+0010213a <vector113>:
+.globl vector113
+vector113:
+  pushl $0
+  10213a:	6a 00                	push   $0x0
+  pushl $113
+  10213c:	6a 71                	push   $0x71
+  jmp __alltraps
+  10213e:	e9 7e 06 00 00       	jmp    1027c1 <__alltraps>
+
+00102143 <vector114>:
+.globl vector114
+vector114:
+  pushl $0
+  102143:	6a 00                	push   $0x0
+  pushl $114
+  102145:	6a 72                	push   $0x72
+  jmp __alltraps
+  102147:	e9 75 06 00 00       	jmp    1027c1 <__alltraps>
+
+0010214c <vector115>:
+.globl vector115
+vector115:
+  pushl $0
+  10214c:	6a 00                	push   $0x0
+  pushl $115
+  10214e:	6a 73                	push   $0x73
+  jmp __alltraps
+  102150:	e9 6c 06 00 00       	jmp    1027c1 <__alltraps>
+
+00102155 <vector116>:
+.globl vector116
+vector116:
+  pushl $0
+  102155:	6a 00                	push   $0x0
+  pushl $116
+  102157:	6a 74                	push   $0x74
+  jmp __alltraps
+  102159:	e9 63 06 00 00       	jmp    1027c1 <__alltraps>
+
+0010215e <vector117>:
+.globl vector117
+vector117:
+  pushl $0
+  10215e:	6a 00                	push   $0x0
+  pushl $117
+  102160:	6a 75                	push   $0x75
+  jmp __alltraps
+  102162:	e9 5a 06 00 00       	jmp    1027c1 <__alltraps>
+
+00102167 <vector118>:
+.globl vector118
+vector118:
+  pushl $0
+  102167:	6a 00                	push   $0x0
+  pushl $118
+  102169:	6a 76                	push   $0x76
+  jmp __alltraps
+  10216b:	e9 51 06 00 00       	jmp    1027c1 <__alltraps>
+
+00102170 <vector119>:
+.globl vector119
+vector119:
+  pushl $0
+  102170:	6a 00                	push   $0x0
+  pushl $119
+  102172:	6a 77                	push   $0x77
+  jmp __alltraps
+  102174:	e9 48 06 00 00       	jmp    1027c1 <__alltraps>
+
+00102179 <vector120>:
+.globl vector120
+vector120:
+  pushl $0
+  102179:	6a 00                	push   $0x0
+  pushl $120
+  10217b:	6a 78                	push   $0x78
+  jmp __alltraps
+  10217d:	e9 3f 06 00 00       	jmp    1027c1 <__alltraps>
+
+00102182 <vector121>:
+.globl vector121
+vector121:
+  pushl $0
+  102182:	6a 00                	push   $0x0
+  pushl $121
+  102184:	6a 79                	push   $0x79
+  jmp __alltraps
+  102186:	e9 36 06 00 00       	jmp    1027c1 <__alltraps>
+
+0010218b <vector122>:
+.globl vector122
+vector122:
+  pushl $0
+  10218b:	6a 00                	push   $0x0
+  pushl $122
+  10218d:	6a 7a                	push   $0x7a
+  jmp __alltraps
+  10218f:	e9 2d 06 00 00       	jmp    1027c1 <__alltraps>
+
+00102194 <vector123>:
+.globl vector123
+vector123:
+  pushl $0
+  102194:	6a 00                	push   $0x0
+  pushl $123
+  102196:	6a 7b                	push   $0x7b
+  jmp __alltraps
+  102198:	e9 24 06 00 00       	jmp    1027c1 <__alltraps>
+
+0010219d <vector124>:
+.globl vector124
+vector124:
+  pushl $0
+  10219d:	6a 00                	push   $0x0
+  pushl $124
+  10219f:	6a 7c                	push   $0x7c
+  jmp __alltraps
+  1021a1:	e9 1b 06 00 00       	jmp    1027c1 <__alltraps>
+
+001021a6 <vector125>:
+.globl vector125
+vector125:
+  pushl $0
+  1021a6:	6a 00                	push   $0x0
+  pushl $125
+  1021a8:	6a 7d                	push   $0x7d
+  jmp __alltraps
+  1021aa:	e9 12 06 00 00       	jmp    1027c1 <__alltraps>
+
+001021af <vector126>:
+.globl vector126
+vector126:
+  pushl $0
+  1021af:	6a 00                	push   $0x0
+  pushl $126
+  1021b1:	6a 7e                	push   $0x7e
+  jmp __alltraps
+  1021b3:	e9 09 06 00 00       	jmp    1027c1 <__alltraps>
+
+001021b8 <vector127>:
+.globl vector127
+vector127:
+  pushl $0
+  1021b8:	6a 00                	push   $0x0
+  pushl $127
+  1021ba:	6a 7f                	push   $0x7f
+  jmp __alltraps
+  1021bc:	e9 00 06 00 00       	jmp    1027c1 <__alltraps>
+
+001021c1 <vector128>:
+.globl vector128
+vector128:
+  pushl $0
+  1021c1:	6a 00                	push   $0x0
+  pushl $128
+  1021c3:	68 80 00 00 00       	push   $0x80
+  jmp __alltraps
+  1021c8:	e9 f4 05 00 00       	jmp    1027c1 <__alltraps>
+
+001021cd <vector129>:
+.globl vector129
+vector129:
+  pushl $0
+  1021cd:	6a 00                	push   $0x0
+  pushl $129
+  1021cf:	68 81 00 00 00       	push   $0x81
+  jmp __alltraps
+  1021d4:	e9 e8 05 00 00       	jmp    1027c1 <__alltraps>
+
+001021d9 <vector130>:
+.globl vector130
+vector130:
+  pushl $0
+  1021d9:	6a 00                	push   $0x0
+  pushl $130
+  1021db:	68 82 00 00 00       	push   $0x82
+  jmp __alltraps
+  1021e0:	e9 dc 05 00 00       	jmp    1027c1 <__alltraps>
+
+001021e5 <vector131>:
+.globl vector131
+vector131:
+  pushl $0
+  1021e5:	6a 00                	push   $0x0
+  pushl $131
+  1021e7:	68 83 00 00 00       	push   $0x83
+  jmp __alltraps
+  1021ec:	e9 d0 05 00 00       	jmp    1027c1 <__alltraps>
+
+001021f1 <vector132>:
+.globl vector132
+vector132:
+  pushl $0
+  1021f1:	6a 00                	push   $0x0
+  pushl $132
+  1021f3:	68 84 00 00 00       	push   $0x84
+  jmp __alltraps
+  1021f8:	e9 c4 05 00 00       	jmp    1027c1 <__alltraps>
+
+001021fd <vector133>:
+.globl vector133
+vector133:
+  pushl $0
+  1021fd:	6a 00                	push   $0x0
+  pushl $133
+  1021ff:	68 85 00 00 00       	push   $0x85
+  jmp __alltraps
+  102204:	e9 b8 05 00 00       	jmp    1027c1 <__alltraps>
+
+00102209 <vector134>:
+.globl vector134
+vector134:
+  pushl $0
+  102209:	6a 00                	push   $0x0
+  pushl $134
+  10220b:	68 86 00 00 00       	push   $0x86
+  jmp __alltraps
+  102210:	e9 ac 05 00 00       	jmp    1027c1 <__alltraps>
+
+00102215 <vector135>:
+.globl vector135
+vector135:
+  pushl $0
+  102215:	6a 00                	push   $0x0
+  pushl $135
+  102217:	68 87 00 00 00       	push   $0x87
+  jmp __alltraps
+  10221c:	e9 a0 05 00 00       	jmp    1027c1 <__alltraps>
+
+00102221 <vector136>:
+.globl vector136
+vector136:
+  pushl $0
+  102221:	6a 00                	push   $0x0
+  pushl $136
+  102223:	68 88 00 00 00       	push   $0x88
+  jmp __alltraps
+  102228:	e9 94 05 00 00       	jmp    1027c1 <__alltraps>
+
+0010222d <vector137>:
+.globl vector137
+vector137:
+  pushl $0
+  10222d:	6a 00                	push   $0x0
+  pushl $137
+  10222f:	68 89 00 00 00       	push   $0x89
+  jmp __alltraps
+  102234:	e9 88 05 00 00       	jmp    1027c1 <__alltraps>
+
+00102239 <vector138>:
+.globl vector138
+vector138:
+  pushl $0
+  102239:	6a 00                	push   $0x0
+  pushl $138
+  10223b:	68 8a 00 00 00       	push   $0x8a
+  jmp __alltraps
+  102240:	e9 7c 05 00 00       	jmp    1027c1 <__alltraps>
+
+00102245 <vector139>:
+.globl vector139
+vector139:
+  pushl $0
+  102245:	6a 00                	push   $0x0
+  pushl $139
+  102247:	68 8b 00 00 00       	push   $0x8b
+  jmp __alltraps
+  10224c:	e9 70 05 00 00       	jmp    1027c1 <__alltraps>
+
+00102251 <vector140>:
+.globl vector140
+vector140:
+  pushl $0
+  102251:	6a 00                	push   $0x0
+  pushl $140
+  102253:	68 8c 00 00 00       	push   $0x8c
+  jmp __alltraps
+  102258:	e9 64 05 00 00       	jmp    1027c1 <__alltraps>
+
+0010225d <vector141>:
+.globl vector141
+vector141:
+  pushl $0
+  10225d:	6a 00                	push   $0x0
+  pushl $141
+  10225f:	68 8d 00 00 00       	push   $0x8d
+  jmp __alltraps
+  102264:	e9 58 05 00 00       	jmp    1027c1 <__alltraps>
+
+00102269 <vector142>:
+.globl vector142
+vector142:
+  pushl $0
+  102269:	6a 00                	push   $0x0
+  pushl $142
+  10226b:	68 8e 00 00 00       	push   $0x8e
+  jmp __alltraps
+  102270:	e9 4c 05 00 00       	jmp    1027c1 <__alltraps>
+
+00102275 <vector143>:
+.globl vector143
+vector143:
+  pushl $0
+  102275:	6a 00                	push   $0x0
+  pushl $143
+  102277:	68 8f 00 00 00       	push   $0x8f
+  jmp __alltraps
+  10227c:	e9 40 05 00 00       	jmp    1027c1 <__alltraps>
+
+00102281 <vector144>:
+.globl vector144
+vector144:
+  pushl $0
+  102281:	6a 00                	push   $0x0
+  pushl $144
+  102283:	68 90 00 00 00       	push   $0x90
+  jmp __alltraps
+  102288:	e9 34 05 00 00       	jmp    1027c1 <__alltraps>
+
+0010228d <vector145>:
+.globl vector145
+vector145:
+  pushl $0
+  10228d:	6a 00                	push   $0x0
+  pushl $145
+  10228f:	68 91 00 00 00       	push   $0x91
+  jmp __alltraps
+  102294:	e9 28 05 00 00       	jmp    1027c1 <__alltraps>
+
+00102299 <vector146>:
+.globl vector146
+vector146:
+  pushl $0
+  102299:	6a 00                	push   $0x0
+  pushl $146
+  10229b:	68 92 00 00 00       	push   $0x92
+  jmp __alltraps
+  1022a0:	e9 1c 05 00 00       	jmp    1027c1 <__alltraps>
+
+001022a5 <vector147>:
+.globl vector147
+vector147:
+  pushl $0
+  1022a5:	6a 00                	push   $0x0
+  pushl $147
+  1022a7:	68 93 00 00 00       	push   $0x93
+  jmp __alltraps
+  1022ac:	e9 10 05 00 00       	jmp    1027c1 <__alltraps>
+
+001022b1 <vector148>:
+.globl vector148
+vector148:
+  pushl $0
+  1022b1:	6a 00                	push   $0x0
+  pushl $148
+  1022b3:	68 94 00 00 00       	push   $0x94
+  jmp __alltraps
+  1022b8:	e9 04 05 00 00       	jmp    1027c1 <__alltraps>
+
+001022bd <vector149>:
+.globl vector149
+vector149:
+  pushl $0
+  1022bd:	6a 00                	push   $0x0
+  pushl $149
+  1022bf:	68 95 00 00 00       	push   $0x95
+  jmp __alltraps
+  1022c4:	e9 f8 04 00 00       	jmp    1027c1 <__alltraps>
+
+001022c9 <vector150>:
+.globl vector150
+vector150:
+  pushl $0
+  1022c9:	6a 00                	push   $0x0
+  pushl $150
+  1022cb:	68 96 00 00 00       	push   $0x96
+  jmp __alltraps
+  1022d0:	e9 ec 04 00 00       	jmp    1027c1 <__alltraps>
+
+001022d5 <vector151>:
+.globl vector151
+vector151:
+  pushl $0
+  1022d5:	6a 00                	push   $0x0
+  pushl $151
+  1022d7:	68 97 00 00 00       	push   $0x97
+  jmp __alltraps
+  1022dc:	e9 e0 04 00 00       	jmp    1027c1 <__alltraps>
+
+001022e1 <vector152>:
+.globl vector152
+vector152:
+  pushl $0
+  1022e1:	6a 00                	push   $0x0
+  pushl $152
+  1022e3:	68 98 00 00 00       	push   $0x98
+  jmp __alltraps
+  1022e8:	e9 d4 04 00 00       	jmp    1027c1 <__alltraps>
+
+001022ed <vector153>:
+.globl vector153
+vector153:
+  pushl $0
+  1022ed:	6a 00                	push   $0x0
+  pushl $153
+  1022ef:	68 99 00 00 00       	push   $0x99
+  jmp __alltraps
+  1022f4:	e9 c8 04 00 00       	jmp    1027c1 <__alltraps>
+
+001022f9 <vector154>:
+.globl vector154
+vector154:
+  pushl $0
+  1022f9:	6a 00                	push   $0x0
+  pushl $154
+  1022fb:	68 9a 00 00 00       	push   $0x9a
+  jmp __alltraps
+  102300:	e9 bc 04 00 00       	jmp    1027c1 <__alltraps>
+
+00102305 <vector155>:
+.globl vector155
+vector155:
+  pushl $0
+  102305:	6a 00                	push   $0x0
+  pushl $155
+  102307:	68 9b 00 00 00       	push   $0x9b
+  jmp __alltraps
+  10230c:	e9 b0 04 00 00       	jmp    1027c1 <__alltraps>
+
+00102311 <vector156>:
+.globl vector156
+vector156:
+  pushl $0
+  102311:	6a 00                	push   $0x0
+  pushl $156
+  102313:	68 9c 00 00 00       	push   $0x9c
+  jmp __alltraps
+  102318:	e9 a4 04 00 00       	jmp    1027c1 <__alltraps>
+
+0010231d <vector157>:
+.globl vector157
+vector157:
+  pushl $0
+  10231d:	6a 00                	push   $0x0
+  pushl $157
+  10231f:	68 9d 00 00 00       	push   $0x9d
+  jmp __alltraps
+  102324:	e9 98 04 00 00       	jmp    1027c1 <__alltraps>
+
+00102329 <vector158>:
+.globl vector158
+vector158:
+  pushl $0
+  102329:	6a 00                	push   $0x0
+  pushl $158
+  10232b:	68 9e 00 00 00       	push   $0x9e
+  jmp __alltraps
+  102330:	e9 8c 04 00 00       	jmp    1027c1 <__alltraps>
+
+00102335 <vector159>:
+.globl vector159
+vector159:
+  pushl $0
+  102335:	6a 00                	push   $0x0
+  pushl $159
+  102337:	68 9f 00 00 00       	push   $0x9f
+  jmp __alltraps
+  10233c:	e9 80 04 00 00       	jmp    1027c1 <__alltraps>
+
+00102341 <vector160>:
+.globl vector160
+vector160:
+  pushl $0
+  102341:	6a 00                	push   $0x0
+  pushl $160
+  102343:	68 a0 00 00 00       	push   $0xa0
+  jmp __alltraps
+  102348:	e9 74 04 00 00       	jmp    1027c1 <__alltraps>
+
+0010234d <vector161>:
+.globl vector161
+vector161:
+  pushl $0
+  10234d:	6a 00                	push   $0x0
+  pushl $161
+  10234f:	68 a1 00 00 00       	push   $0xa1
+  jmp __alltraps
+  102354:	e9 68 04 00 00       	jmp    1027c1 <__alltraps>
+
+00102359 <vector162>:
+.globl vector162
+vector162:
+  pushl $0
+  102359:	6a 00                	push   $0x0
+  pushl $162
+  10235b:	68 a2 00 00 00       	push   $0xa2
+  jmp __alltraps
+  102360:	e9 5c 04 00 00       	jmp    1027c1 <__alltraps>
+
+00102365 <vector163>:
+.globl vector163
+vector163:
+  pushl $0
+  102365:	6a 00                	push   $0x0
+  pushl $163
+  102367:	68 a3 00 00 00       	push   $0xa3
+  jmp __alltraps
+  10236c:	e9 50 04 00 00       	jmp    1027c1 <__alltraps>
+
+00102371 <vector164>:
+.globl vector164
+vector164:
+  pushl $0
+  102371:	6a 00                	push   $0x0
+  pushl $164
+  102373:	68 a4 00 00 00       	push   $0xa4
+  jmp __alltraps
+  102378:	e9 44 04 00 00       	jmp    1027c1 <__alltraps>
+
+0010237d <vector165>:
+.globl vector165
+vector165:
+  pushl $0
+  10237d:	6a 00                	push   $0x0
+  pushl $165
+  10237f:	68 a5 00 00 00       	push   $0xa5
+  jmp __alltraps
+  102384:	e9 38 04 00 00       	jmp    1027c1 <__alltraps>
+
+00102389 <vector166>:
+.globl vector166
+vector166:
+  pushl $0
+  102389:	6a 00                	push   $0x0
+  pushl $166
+  10238b:	68 a6 00 00 00       	push   $0xa6
+  jmp __alltraps
+  102390:	e9 2c 04 00 00       	jmp    1027c1 <__alltraps>
+
+00102395 <vector167>:
+.globl vector167
+vector167:
+  pushl $0
+  102395:	6a 00                	push   $0x0
+  pushl $167
+  102397:	68 a7 00 00 00       	push   $0xa7
+  jmp __alltraps
+  10239c:	e9 20 04 00 00       	jmp    1027c1 <__alltraps>
+
+001023a1 <vector168>:
+.globl vector168
+vector168:
+  pushl $0
+  1023a1:	6a 00                	push   $0x0
+  pushl $168
+  1023a3:	68 a8 00 00 00       	push   $0xa8
+  jmp __alltraps
+  1023a8:	e9 14 04 00 00       	jmp    1027c1 <__alltraps>
+
+001023ad <vector169>:
+.globl vector169
+vector169:
+  pushl $0
+  1023ad:	6a 00                	push   $0x0
+  pushl $169
+  1023af:	68 a9 00 00 00       	push   $0xa9
+  jmp __alltraps
+  1023b4:	e9 08 04 00 00       	jmp    1027c1 <__alltraps>
+
+001023b9 <vector170>:
+.globl vector170
+vector170:
+  pushl $0
+  1023b9:	6a 00                	push   $0x0
+  pushl $170
+  1023bb:	68 aa 00 00 00       	push   $0xaa
+  jmp __alltraps
+  1023c0:	e9 fc 03 00 00       	jmp    1027c1 <__alltraps>
+
+001023c5 <vector171>:
+.globl vector171
+vector171:
+  pushl $0
+  1023c5:	6a 00                	push   $0x0
+  pushl $171
+  1023c7:	68 ab 00 00 00       	push   $0xab
+  jmp __alltraps
+  1023cc:	e9 f0 03 00 00       	jmp    1027c1 <__alltraps>
+
+001023d1 <vector172>:
+.globl vector172
+vector172:
+  pushl $0
+  1023d1:	6a 00                	push   $0x0
+  pushl $172
+  1023d3:	68 ac 00 00 00       	push   $0xac
+  jmp __alltraps
+  1023d8:	e9 e4 03 00 00       	jmp    1027c1 <__alltraps>
+
+001023dd <vector173>:
+.globl vector173
+vector173:
+  pushl $0
+  1023dd:	6a 00                	push   $0x0
+  pushl $173
+  1023df:	68 ad 00 00 00       	push   $0xad
+  jmp __alltraps
+  1023e4:	e9 d8 03 00 00       	jmp    1027c1 <__alltraps>
+
+001023e9 <vector174>:
+.globl vector174
+vector174:
+  pushl $0
+  1023e9:	6a 00                	push   $0x0
+  pushl $174
+  1023eb:	68 ae 00 00 00       	push   $0xae
+  jmp __alltraps
+  1023f0:	e9 cc 03 00 00       	jmp    1027c1 <__alltraps>
+
+001023f5 <vector175>:
+.globl vector175
+vector175:
+  pushl $0
+  1023f5:	6a 00                	push   $0x0
+  pushl $175
+  1023f7:	68 af 00 00 00       	push   $0xaf
+  jmp __alltraps
+  1023fc:	e9 c0 03 00 00       	jmp    1027c1 <__alltraps>
+
+00102401 <vector176>:
+.globl vector176
+vector176:
+  pushl $0
+  102401:	6a 00                	push   $0x0
+  pushl $176
+  102403:	68 b0 00 00 00       	push   $0xb0
+  jmp __alltraps
+  102408:	e9 b4 03 00 00       	jmp    1027c1 <__alltraps>
+
+0010240d <vector177>:
+.globl vector177
+vector177:
+  pushl $0
+  10240d:	6a 00                	push   $0x0
+  pushl $177
+  10240f:	68 b1 00 00 00       	push   $0xb1
+  jmp __alltraps
+  102414:	e9 a8 03 00 00       	jmp    1027c1 <__alltraps>
+
+00102419 <vector178>:
+.globl vector178
+vector178:
+  pushl $0
+  102419:	6a 00                	push   $0x0
+  pushl $178
+  10241b:	68 b2 00 00 00       	push   $0xb2
+  jmp __alltraps
+  102420:	e9 9c 03 00 00       	jmp    1027c1 <__alltraps>
+
+00102425 <vector179>:
+.globl vector179
+vector179:
+  pushl $0
+  102425:	6a 00                	push   $0x0
+  pushl $179
+  102427:	68 b3 00 00 00       	push   $0xb3
+  jmp __alltraps
+  10242c:	e9 90 03 00 00       	jmp    1027c1 <__alltraps>
+
+00102431 <vector180>:
+.globl vector180
+vector180:
+  pushl $0
+  102431:	6a 00                	push   $0x0
+  pushl $180
+  102433:	68 b4 00 00 00       	push   $0xb4
+  jmp __alltraps
+  102438:	e9 84 03 00 00       	jmp    1027c1 <__alltraps>
+
+0010243d <vector181>:
+.globl vector181
+vector181:
+  pushl $0
+  10243d:	6a 00                	push   $0x0
+  pushl $181
+  10243f:	68 b5 00 00 00       	push   $0xb5
+  jmp __alltraps
+  102444:	e9 78 03 00 00       	jmp    1027c1 <__alltraps>
+
+00102449 <vector182>:
+.globl vector182
+vector182:
+  pushl $0
+  102449:	6a 00                	push   $0x0
+  pushl $182
+  10244b:	68 b6 00 00 00       	push   $0xb6
+  jmp __alltraps
+  102450:	e9 6c 03 00 00       	jmp    1027c1 <__alltraps>
+
+00102455 <vector183>:
+.globl vector183
+vector183:
+  pushl $0
+  102455:	6a 00                	push   $0x0
+  pushl $183
+  102457:	68 b7 00 00 00       	push   $0xb7
+  jmp __alltraps
+  10245c:	e9 60 03 00 00       	jmp    1027c1 <__alltraps>
+
+00102461 <vector184>:
+.globl vector184
+vector184:
+  pushl $0
+  102461:	6a 00                	push   $0x0
+  pushl $184
+  102463:	68 b8 00 00 00       	push   $0xb8
+  jmp __alltraps
+  102468:	e9 54 03 00 00       	jmp    1027c1 <__alltraps>
+
+0010246d <vector185>:
+.globl vector185
+vector185:
+  pushl $0
+  10246d:	6a 00                	push   $0x0
+  pushl $185
+  10246f:	68 b9 00 00 00       	push   $0xb9
+  jmp __alltraps
+  102474:	e9 48 03 00 00       	jmp    1027c1 <__alltraps>
+
+00102479 <vector186>:
+.globl vector186
+vector186:
+  pushl $0
+  102479:	6a 00                	push   $0x0
+  pushl $186
+  10247b:	68 ba 00 00 00       	push   $0xba
+  jmp __alltraps
+  102480:	e9 3c 03 00 00       	jmp    1027c1 <__alltraps>
+
+00102485 <vector187>:
+.globl vector187
+vector187:
+  pushl $0
+  102485:	6a 00                	push   $0x0
+  pushl $187
+  102487:	68 bb 00 00 00       	push   $0xbb
+  jmp __alltraps
+  10248c:	e9 30 03 00 00       	jmp    1027c1 <__alltraps>
+
+00102491 <vector188>:
+.globl vector188
+vector188:
+  pushl $0
+  102491:	6a 00                	push   $0x0
+  pushl $188
+  102493:	68 bc 00 00 00       	push   $0xbc
+  jmp __alltraps
+  102498:	e9 24 03 00 00       	jmp    1027c1 <__alltraps>
+
+0010249d <vector189>:
+.globl vector189
+vector189:
+  pushl $0
+  10249d:	6a 00                	push   $0x0
+  pushl $189
+  10249f:	68 bd 00 00 00       	push   $0xbd
+  jmp __alltraps
+  1024a4:	e9 18 03 00 00       	jmp    1027c1 <__alltraps>
+
+001024a9 <vector190>:
+.globl vector190
+vector190:
+  pushl $0
+  1024a9:	6a 00                	push   $0x0
+  pushl $190
+  1024ab:	68 be 00 00 00       	push   $0xbe
+  jmp __alltraps
+  1024b0:	e9 0c 03 00 00       	jmp    1027c1 <__alltraps>
+
+001024b5 <vector191>:
+.globl vector191
+vector191:
+  pushl $0
+  1024b5:	6a 00                	push   $0x0
+  pushl $191
+  1024b7:	68 bf 00 00 00       	push   $0xbf
+  jmp __alltraps
+  1024bc:	e9 00 03 00 00       	jmp    1027c1 <__alltraps>
+
+001024c1 <vector192>:
+.globl vector192
+vector192:
+  pushl $0
+  1024c1:	6a 00                	push   $0x0
+  pushl $192
+  1024c3:	68 c0 00 00 00       	push   $0xc0
+  jmp __alltraps
+  1024c8:	e9 f4 02 00 00       	jmp    1027c1 <__alltraps>
+
+001024cd <vector193>:
+.globl vector193
+vector193:
+  pushl $0
+  1024cd:	6a 00                	push   $0x0
+  pushl $193
+  1024cf:	68 c1 00 00 00       	push   $0xc1
+  jmp __alltraps
+  1024d4:	e9 e8 02 00 00       	jmp    1027c1 <__alltraps>
+
+001024d9 <vector194>:
+.globl vector194
+vector194:
+  pushl $0
+  1024d9:	6a 00                	push   $0x0
+  pushl $194
+  1024db:	68 c2 00 00 00       	push   $0xc2
+  jmp __alltraps
+  1024e0:	e9 dc 02 00 00       	jmp    1027c1 <__alltraps>
+
+001024e5 <vector195>:
+.globl vector195
+vector195:
+  pushl $0
+  1024e5:	6a 00                	push   $0x0
+  pushl $195
+  1024e7:	68 c3 00 00 00       	push   $0xc3
+  jmp __alltraps
+  1024ec:	e9 d0 02 00 00       	jmp    1027c1 <__alltraps>
+
+001024f1 <vector196>:
+.globl vector196
+vector196:
+  pushl $0
+  1024f1:	6a 00                	push   $0x0
+  pushl $196
+  1024f3:	68 c4 00 00 00       	push   $0xc4
+  jmp __alltraps
+  1024f8:	e9 c4 02 00 00       	jmp    1027c1 <__alltraps>
+
+001024fd <vector197>:
+.globl vector197
+vector197:
+  pushl $0
+  1024fd:	6a 00                	push   $0x0
+  pushl $197
+  1024ff:	68 c5 00 00 00       	push   $0xc5
+  jmp __alltraps
+  102504:	e9 b8 02 00 00       	jmp    1027c1 <__alltraps>
+
+00102509 <vector198>:
+.globl vector198
+vector198:
+  pushl $0
+  102509:	6a 00                	push   $0x0
+  pushl $198
+  10250b:	68 c6 00 00 00       	push   $0xc6
+  jmp __alltraps
+  102510:	e9 ac 02 00 00       	jmp    1027c1 <__alltraps>
+
+00102515 <vector199>:
+.globl vector199
+vector199:
+  pushl $0
+  102515:	6a 00                	push   $0x0
+  pushl $199
+  102517:	68 c7 00 00 00       	push   $0xc7
+  jmp __alltraps
+  10251c:	e9 a0 02 00 00       	jmp    1027c1 <__alltraps>
+
+00102521 <vector200>:
+.globl vector200
+vector200:
+  pushl $0
+  102521:	6a 00                	push   $0x0
+  pushl $200
+  102523:	68 c8 00 00 00       	push   $0xc8
+  jmp __alltraps
+  102528:	e9 94 02 00 00       	jmp    1027c1 <__alltraps>
+
+0010252d <vector201>:
+.globl vector201
+vector201:
+  pushl $0
+  10252d:	6a 00                	push   $0x0
+  pushl $201
+  10252f:	68 c9 00 00 00       	push   $0xc9
+  jmp __alltraps
+  102534:	e9 88 02 00 00       	jmp    1027c1 <__alltraps>
+
+00102539 <vector202>:
+.globl vector202
+vector202:
+  pushl $0
+  102539:	6a 00                	push   $0x0
+  pushl $202
+  10253b:	68 ca 00 00 00       	push   $0xca
+  jmp __alltraps
+  102540:	e9 7c 02 00 00       	jmp    1027c1 <__alltraps>
+
+00102545 <vector203>:
+.globl vector203
+vector203:
+  pushl $0
+  102545:	6a 00                	push   $0x0
+  pushl $203
+  102547:	68 cb 00 00 00       	push   $0xcb
+  jmp __alltraps
+  10254c:	e9 70 02 00 00       	jmp    1027c1 <__alltraps>
+
+00102551 <vector204>:
+.globl vector204
+vector204:
+  pushl $0
+  102551:	6a 00                	push   $0x0
+  pushl $204
+  102553:	68 cc 00 00 00       	push   $0xcc
+  jmp __alltraps
+  102558:	e9 64 02 00 00       	jmp    1027c1 <__alltraps>
+
+0010255d <vector205>:
+.globl vector205
+vector205:
+  pushl $0
+  10255d:	6a 00                	push   $0x0
+  pushl $205
+  10255f:	68 cd 00 00 00       	push   $0xcd
+  jmp __alltraps
+  102564:	e9 58 02 00 00       	jmp    1027c1 <__alltraps>
+
+00102569 <vector206>:
+.globl vector206
+vector206:
+  pushl $0
+  102569:	6a 00                	push   $0x0
+  pushl $206
+  10256b:	68 ce 00 00 00       	push   $0xce
+  jmp __alltraps
+  102570:	e9 4c 02 00 00       	jmp    1027c1 <__alltraps>
+
+00102575 <vector207>:
+.globl vector207
+vector207:
+  pushl $0
+  102575:	6a 00                	push   $0x0
+  pushl $207
+  102577:	68 cf 00 00 00       	push   $0xcf
+  jmp __alltraps
+  10257c:	e9 40 02 00 00       	jmp    1027c1 <__alltraps>
+
+00102581 <vector208>:
+.globl vector208
+vector208:
+  pushl $0
+  102581:	6a 00                	push   $0x0
+  pushl $208
+  102583:	68 d0 00 00 00       	push   $0xd0
+  jmp __alltraps
+  102588:	e9 34 02 00 00       	jmp    1027c1 <__alltraps>
+
+0010258d <vector209>:
+.globl vector209
+vector209:
+  pushl $0
+  10258d:	6a 00                	push   $0x0
+  pushl $209
+  10258f:	68 d1 00 00 00       	push   $0xd1
+  jmp __alltraps
+  102594:	e9 28 02 00 00       	jmp    1027c1 <__alltraps>
+
+00102599 <vector210>:
+.globl vector210
+vector210:
+  pushl $0
+  102599:	6a 00                	push   $0x0
+  pushl $210
+  10259b:	68 d2 00 00 00       	push   $0xd2
+  jmp __alltraps
+  1025a0:	e9 1c 02 00 00       	jmp    1027c1 <__alltraps>
+
+001025a5 <vector211>:
+.globl vector211
+vector211:
+  pushl $0
+  1025a5:	6a 00                	push   $0x0
+  pushl $211
+  1025a7:	68 d3 00 00 00       	push   $0xd3
+  jmp __alltraps
+  1025ac:	e9 10 02 00 00       	jmp    1027c1 <__alltraps>
+
+001025b1 <vector212>:
+.globl vector212
+vector212:
+  pushl $0
+  1025b1:	6a 00                	push   $0x0
+  pushl $212
+  1025b3:	68 d4 00 00 00       	push   $0xd4
+  jmp __alltraps
+  1025b8:	e9 04 02 00 00       	jmp    1027c1 <__alltraps>
+
+001025bd <vector213>:
+.globl vector213
+vector213:
+  pushl $0
+  1025bd:	6a 00                	push   $0x0
+  pushl $213
+  1025bf:	68 d5 00 00 00       	push   $0xd5
+  jmp __alltraps
+  1025c4:	e9 f8 01 00 00       	jmp    1027c1 <__alltraps>
+
+001025c9 <vector214>:
+.globl vector214
+vector214:
+  pushl $0
+  1025c9:	6a 00                	push   $0x0
+  pushl $214
+  1025cb:	68 d6 00 00 00       	push   $0xd6
+  jmp __alltraps
+  1025d0:	e9 ec 01 00 00       	jmp    1027c1 <__alltraps>
+
+001025d5 <vector215>:
+.globl vector215
+vector215:
+  pushl $0
+  1025d5:	6a 00                	push   $0x0
+  pushl $215
+  1025d7:	68 d7 00 00 00       	push   $0xd7
+  jmp __alltraps
+  1025dc:	e9 e0 01 00 00       	jmp    1027c1 <__alltraps>
+
+001025e1 <vector216>:
+.globl vector216
+vector216:
+  pushl $0
+  1025e1:	6a 00                	push   $0x0
+  pushl $216
+  1025e3:	68 d8 00 00 00       	push   $0xd8
+  jmp __alltraps
+  1025e8:	e9 d4 01 00 00       	jmp    1027c1 <__alltraps>
+
+001025ed <vector217>:
+.globl vector217
+vector217:
+  pushl $0
+  1025ed:	6a 00                	push   $0x0
+  pushl $217
+  1025ef:	68 d9 00 00 00       	push   $0xd9
+  jmp __alltraps
+  1025f4:	e9 c8 01 00 00       	jmp    1027c1 <__alltraps>
+
+001025f9 <vector218>:
+.globl vector218
+vector218:
+  pushl $0
+  1025f9:	6a 00                	push   $0x0
+  pushl $218
+  1025fb:	68 da 00 00 00       	push   $0xda
+  jmp __alltraps
+  102600:	e9 bc 01 00 00       	jmp    1027c1 <__alltraps>
+
+00102605 <vector219>:
+.globl vector219
+vector219:
+  pushl $0
+  102605:	6a 00                	push   $0x0
+  pushl $219
+  102607:	68 db 00 00 00       	push   $0xdb
+  jmp __alltraps
+  10260c:	e9 b0 01 00 00       	jmp    1027c1 <__alltraps>
+
+00102611 <vector220>:
+.globl vector220
+vector220:
+  pushl $0
+  102611:	6a 00                	push   $0x0
+  pushl $220
+  102613:	68 dc 00 00 00       	push   $0xdc
+  jmp __alltraps
+  102618:	e9 a4 01 00 00       	jmp    1027c1 <__alltraps>
+
+0010261d <vector221>:
+.globl vector221
+vector221:
+  pushl $0
+  10261d:	6a 00                	push   $0x0
+  pushl $221
+  10261f:	68 dd 00 00 00       	push   $0xdd
+  jmp __alltraps
+  102624:	e9 98 01 00 00       	jmp    1027c1 <__alltraps>
+
+00102629 <vector222>:
+.globl vector222
+vector222:
+  pushl $0
+  102629:	6a 00                	push   $0x0
+  pushl $222
+  10262b:	68 de 00 00 00       	push   $0xde
+  jmp __alltraps
+  102630:	e9 8c 01 00 00       	jmp    1027c1 <__alltraps>
+
+00102635 <vector223>:
+.globl vector223
+vector223:
+  pushl $0
+  102635:	6a 00                	push   $0x0
+  pushl $223
+  102637:	68 df 00 00 00       	push   $0xdf
+  jmp __alltraps
+  10263c:	e9 80 01 00 00       	jmp    1027c1 <__alltraps>
+
+00102641 <vector224>:
+.globl vector224
+vector224:
+  pushl $0
+  102641:	6a 00                	push   $0x0
+  pushl $224
+  102643:	68 e0 00 00 00       	push   $0xe0
+  jmp __alltraps
+  102648:	e9 74 01 00 00       	jmp    1027c1 <__alltraps>
+
+0010264d <vector225>:
+.globl vector225
+vector225:
+  pushl $0
+  10264d:	6a 00                	push   $0x0
+  pushl $225
+  10264f:	68 e1 00 00 00       	push   $0xe1
+  jmp __alltraps
+  102654:	e9 68 01 00 00       	jmp    1027c1 <__alltraps>
+
+00102659 <vector226>:
+.globl vector226
+vector226:
+  pushl $0
+  102659:	6a 00                	push   $0x0
+  pushl $226
+  10265b:	68 e2 00 00 00       	push   $0xe2
+  jmp __alltraps
+  102660:	e9 5c 01 00 00       	jmp    1027c1 <__alltraps>
+
+00102665 <vector227>:
+.globl vector227
+vector227:
+  pushl $0
+  102665:	6a 00                	push   $0x0
+  pushl $227
+  102667:	68 e3 00 00 00       	push   $0xe3
+  jmp __alltraps
+  10266c:	e9 50 01 00 00       	jmp    1027c1 <__alltraps>
+
+00102671 <vector228>:
+.globl vector228
+vector228:
+  pushl $0
+  102671:	6a 00                	push   $0x0
+  pushl $228
+  102673:	68 e4 00 00 00       	push   $0xe4
+  jmp __alltraps
+  102678:	e9 44 01 00 00       	jmp    1027c1 <__alltraps>
+
+0010267d <vector229>:
+.globl vector229
+vector229:
+  pushl $0
+  10267d:	6a 00                	push   $0x0
+  pushl $229
+  10267f:	68 e5 00 00 00       	push   $0xe5
+  jmp __alltraps
+  102684:	e9 38 01 00 00       	jmp    1027c1 <__alltraps>
+
+00102689 <vector230>:
+.globl vector230
+vector230:
+  pushl $0
+  102689:	6a 00                	push   $0x0
+  pushl $230
+  10268b:	68 e6 00 00 00       	push   $0xe6
+  jmp __alltraps
+  102690:	e9 2c 01 00 00       	jmp    1027c1 <__alltraps>
+
+00102695 <vector231>:
+.globl vector231
+vector231:
+  pushl $0
+  102695:	6a 00                	push   $0x0
+  pushl $231
+  102697:	68 e7 00 00 00       	push   $0xe7
+  jmp __alltraps
+  10269c:	e9 20 01 00 00       	jmp    1027c1 <__alltraps>
+
+001026a1 <vector232>:
+.globl vector232
+vector232:
+  pushl $0
+  1026a1:	6a 00                	push   $0x0
+  pushl $232
+  1026a3:	68 e8 00 00 00       	push   $0xe8
+  jmp __alltraps
+  1026a8:	e9 14 01 00 00       	jmp    1027c1 <__alltraps>
+
+001026ad <vector233>:
+.globl vector233
+vector233:
+  pushl $0
+  1026ad:	6a 00                	push   $0x0
+  pushl $233
+  1026af:	68 e9 00 00 00       	push   $0xe9
+  jmp __alltraps
+  1026b4:	e9 08 01 00 00       	jmp    1027c1 <__alltraps>
+
+001026b9 <vector234>:
+.globl vector234
+vector234:
+  pushl $0
+  1026b9:	6a 00                	push   $0x0
+  pushl $234
+  1026bb:	68 ea 00 00 00       	push   $0xea
+  jmp __alltraps
+  1026c0:	e9 fc 00 00 00       	jmp    1027c1 <__alltraps>
+
+001026c5 <vector235>:
+.globl vector235
+vector235:
+  pushl $0
+  1026c5:	6a 00                	push   $0x0
+  pushl $235
+  1026c7:	68 eb 00 00 00       	push   $0xeb
+  jmp __alltraps
+  1026cc:	e9 f0 00 00 00       	jmp    1027c1 <__alltraps>
+
+001026d1 <vector236>:
+.globl vector236
+vector236:
+  pushl $0
+  1026d1:	6a 00                	push   $0x0
+  pushl $236
+  1026d3:	68 ec 00 00 00       	push   $0xec
+  jmp __alltraps
+  1026d8:	e9 e4 00 00 00       	jmp    1027c1 <__alltraps>
+
+001026dd <vector237>:
+.globl vector237
+vector237:
+  pushl $0
+  1026dd:	6a 00                	push   $0x0
+  pushl $237
+  1026df:	68 ed 00 00 00       	push   $0xed
+  jmp __alltraps
+  1026e4:	e9 d8 00 00 00       	jmp    1027c1 <__alltraps>
+
+001026e9 <vector238>:
+.globl vector238
+vector238:
+  pushl $0
+  1026e9:	6a 00                	push   $0x0
+  pushl $238
+  1026eb:	68 ee 00 00 00       	push   $0xee
+  jmp __alltraps
+  1026f0:	e9 cc 00 00 00       	jmp    1027c1 <__alltraps>
+
+001026f5 <vector239>:
+.globl vector239
+vector239:
+  pushl $0
+  1026f5:	6a 00                	push   $0x0
+  pushl $239
+  1026f7:	68 ef 00 00 00       	push   $0xef
+  jmp __alltraps
+  1026fc:	e9 c0 00 00 00       	jmp    1027c1 <__alltraps>
+
+00102701 <vector240>:
+.globl vector240
+vector240:
+  pushl $0
+  102701:	6a 00                	push   $0x0
+  pushl $240
+  102703:	68 f0 00 00 00       	push   $0xf0
+  jmp __alltraps
+  102708:	e9 b4 00 00 00       	jmp    1027c1 <__alltraps>
+
+0010270d <vector241>:
+.globl vector241
+vector241:
+  pushl $0
+  10270d:	6a 00                	push   $0x0
+  pushl $241
+  10270f:	68 f1 00 00 00       	push   $0xf1
+  jmp __alltraps
+  102714:	e9 a8 00 00 00       	jmp    1027c1 <__alltraps>
+
+00102719 <vector242>:
+.globl vector242
+vector242:
+  pushl $0
+  102719:	6a 00                	push   $0x0
+  pushl $242
+  10271b:	68 f2 00 00 00       	push   $0xf2
+  jmp __alltraps
+  102720:	e9 9c 00 00 00       	jmp    1027c1 <__alltraps>
+
+00102725 <vector243>:
+.globl vector243
+vector243:
+  pushl $0
+  102725:	6a 00                	push   $0x0
+  pushl $243
+  102727:	68 f3 00 00 00       	push   $0xf3
+  jmp __alltraps
+  10272c:	e9 90 00 00 00       	jmp    1027c1 <__alltraps>
+
+00102731 <vector244>:
+.globl vector244
+vector244:
+  pushl $0
+  102731:	6a 00                	push   $0x0
+  pushl $244
+  102733:	68 f4 00 00 00       	push   $0xf4
+  jmp __alltraps
+  102738:	e9 84 00 00 00       	jmp    1027c1 <__alltraps>
+
+0010273d <vector245>:
+.globl vector245
+vector245:
+  pushl $0
+  10273d:	6a 00                	push   $0x0
+  pushl $245
+  10273f:	68 f5 00 00 00       	push   $0xf5
+  jmp __alltraps
+  102744:	e9 78 00 00 00       	jmp    1027c1 <__alltraps>
+
+00102749 <vector246>:
+.globl vector246
+vector246:
+  pushl $0
+  102749:	6a 00                	push   $0x0
+  pushl $246
+  10274b:	68 f6 00 00 00       	push   $0xf6
+  jmp __alltraps
+  102750:	e9 6c 00 00 00       	jmp    1027c1 <__alltraps>
+
+00102755 <vector247>:
+.globl vector247
+vector247:
+  pushl $0
+  102755:	6a 00                	push   $0x0
+  pushl $247
+  102757:	68 f7 00 00 00       	push   $0xf7
+  jmp __alltraps
+  10275c:	e9 60 00 00 00       	jmp    1027c1 <__alltraps>
+
+00102761 <vector248>:
+.globl vector248
+vector248:
+  pushl $0
+  102761:	6a 00                	push   $0x0
+  pushl $248
+  102763:	68 f8 00 00 00       	push   $0xf8
+  jmp __alltraps
+  102768:	e9 54 00 00 00       	jmp    1027c1 <__alltraps>
+
+0010276d <vector249>:
+.globl vector249
+vector249:
+  pushl $0
+  10276d:	6a 00                	push   $0x0
+  pushl $249
+  10276f:	68 f9 00 00 00       	push   $0xf9
+  jmp __alltraps
+  102774:	e9 48 00 00 00       	jmp    1027c1 <__alltraps>
+
+00102779 <vector250>:
+.globl vector250
+vector250:
+  pushl $0
+  102779:	6a 00                	push   $0x0
+  pushl $250
+  10277b:	68 fa 00 00 00       	push   $0xfa
+  jmp __alltraps
+  102780:	e9 3c 00 00 00       	jmp    1027c1 <__alltraps>
+
+00102785 <vector251>:
+.globl vector251
+vector251:
+  pushl $0
+  102785:	6a 00                	push   $0x0
+  pushl $251
+  102787:	68 fb 00 00 00       	push   $0xfb
+  jmp __alltraps
+  10278c:	e9 30 00 00 00       	jmp    1027c1 <__alltraps>
+
+00102791 <vector252>:
+.globl vector252
+vector252:
+  pushl $0
+  102791:	6a 00                	push   $0x0
+  pushl $252
+  102793:	68 fc 00 00 00       	push   $0xfc
+  jmp __alltraps
+  102798:	e9 24 00 00 00       	jmp    1027c1 <__alltraps>
+
+0010279d <vector253>:
+.globl vector253
+vector253:
+  pushl $0
+  10279d:	6a 00                	push   $0x0
+  pushl $253
+  10279f:	68 fd 00 00 00       	push   $0xfd
+  jmp __alltraps
+  1027a4:	e9 18 00 00 00       	jmp    1027c1 <__alltraps>
+
+001027a9 <vector254>:
+.globl vector254
+vector254:
+  pushl $0
+  1027a9:	6a 00                	push   $0x0
+  pushl $254
+  1027ab:	68 fe 00 00 00       	push   $0xfe
+  jmp __alltraps
+  1027b0:	e9 0c 00 00 00       	jmp    1027c1 <__alltraps>
+
+001027b5 <vector255>:
+.globl vector255
+vector255:
+  pushl $0
+  1027b5:	6a 00                	push   $0x0
+  pushl $255
+  1027b7:	68 ff 00 00 00       	push   $0xff
+  jmp __alltraps
+  1027bc:	e9 00 00 00 00       	jmp    1027c1 <__alltraps>
+
+001027c1 <__alltraps>:
+.text
+.globl __alltraps
+__alltraps:
+    # push registers to build a trap frame
+    # therefore make the stack look like a struct trapframe
+    pushl %ds
+  1027c1:	1e                   	push   %ds
+    pushl %es
+  1027c2:	06                   	push   %es
+    pushl %fs
+  1027c3:	0f a0                	push   %fs
+    pushl %gs
+  1027c5:	0f a8                	push   %gs
+    pushal
+  1027c7:	60                   	pusha  
+
+    # load GD_KDATA into %ds and %es to set up data segments for kernel
+    movl $GD_KDATA, %eax
+  1027c8:	b8 10 00 00 00       	mov    $0x10,%eax
+    movw %ax, %ds
+  1027cd:	8e d8                	mov    %eax,%ds
+    movw %ax, %es
+  1027cf:	8e c0                	mov    %eax,%es
+
+    # push %esp to pass a pointer to the trapframe as an argument to trap()
+    pushl %esp
+  1027d1:	54                   	push   %esp
+
+    # call trap(tf), where tf=%esp
+    call trap
+  1027d2:	e8 65 f5 ff ff       	call   101d3c <trap>
+
+    # pop the pushed stack pointer
+    popl %esp
+  1027d7:	5c                   	pop    %esp
+
+001027d8 <__trapret>:
+
+    # return falls through to trapret...
+.globl __trapret
+__trapret:
+    # restore registers from stack
+    popal
+  1027d8:	61                   	popa   
+
+    # restore %ds, %es, %fs and %gs
+    popl %gs
+  1027d9:	0f a9                	pop    %gs
+    popl %fs
+  1027db:	0f a1                	pop    %fs
+    popl %es
+  1027dd:	07                   	pop    %es
+    popl %ds
+  1027de:	1f                   	pop    %ds
+
+    # get rid of the trap number and error code
+    addl $0x8, %esp
+  1027df:	83 c4 08             	add    $0x8,%esp
+    iret
+  1027e2:	cf                   	iret   
+
+001027e3 <lgdt>:
+/* *
+ * lgdt - load the global descriptor table register and reset the
+ * data/code segement registers for kernel.
+ * */
+static inline void
+lgdt(struct pseudodesc *pd) {
+  1027e3:	55                   	push   %ebp
+  1027e4:	89 e5                	mov    %esp,%ebp
+    asm volatile ("lgdt (%0)" :: "r" (pd));
+  1027e6:	8b 45 08             	mov    0x8(%ebp),%eax
+  1027e9:	0f 01 10             	lgdtl  (%eax)
+    asm volatile ("movw %%ax, %%gs" :: "a" (USER_DS));
+  1027ec:	b8 23 00 00 00       	mov    $0x23,%eax
+  1027f1:	8e e8                	mov    %eax,%gs
+    asm volatile ("movw %%ax, %%fs" :: "a" (USER_DS));
+  1027f3:	b8 23 00 00 00       	mov    $0x23,%eax
+  1027f8:	8e e0                	mov    %eax,%fs
+    asm volatile ("movw %%ax, %%es" :: "a" (KERNEL_DS));
+  1027fa:	b8 10 00 00 00       	mov    $0x10,%eax
+  1027ff:	8e c0                	mov    %eax,%es
+    asm volatile ("movw %%ax, %%ds" :: "a" (KERNEL_DS));
+  102801:	b8 10 00 00 00       	mov    $0x10,%eax
+  102806:	8e d8                	mov    %eax,%ds
+    asm volatile ("movw %%ax, %%ss" :: "a" (KERNEL_DS));
+  102808:	b8 10 00 00 00       	mov    $0x10,%eax
+  10280d:	8e d0                	mov    %eax,%ss
+    // reload cs
+    asm volatile ("ljmp %0, $1f\n 1:\n" :: "i" (KERNEL_CS));
+  10280f:	ea 16 28 10 00 08 00 	ljmp   $0x8,$0x102816
+}
+  102816:	5d                   	pop    %ebp
+  102817:	c3                   	ret    
+
+00102818 <gdt_init>:
+/* temporary kernel stack */
+uint8_t stack0[1024];
+
+/* gdt_init - initialize the default GDT and TSS */
+static void
+gdt_init(void) {
+  102818:	55                   	push   %ebp
+  102819:	89 e5                	mov    %esp,%ebp
+  10281b:	83 ec 14             	sub    $0x14,%esp
+    // Setup a TSS so that we can get the right stack when we trap from
+    // user to the kernel. But not safe here, it's only a temporary value,
+    // it will be set to KSTACKTOP in lab2.
+    ts.ts_esp0 = (uint32_t)&stack0 + sizeof(stack0);
+  10281e:	b8 40 f9 10 00       	mov    $0x10f940,%eax
+  102823:	05 00 04 00 00       	add    $0x400,%eax
+  102828:	a3 c4 f8 10 00       	mov    %eax,0x10f8c4
+    ts.ts_ss0 = KERNEL_DS;
+  10282d:	66 c7 05 c8 f8 10 00 	movw   $0x10,0x10f8c8
+  102834:	10 00 
+
+    // initialize the TSS filed of the gdt
+    gdt[SEG_TSS] = SEG16(STS_T32A, (uint32_t)&ts, sizeof(ts), DPL_KERNEL);
+  102836:	66 c7 05 08 ea 10 00 	movw   $0x68,0x10ea08
+  10283d:	68 00 
+  10283f:	b8 c0 f8 10 00       	mov    $0x10f8c0,%eax
+  102844:	66 a3 0a ea 10 00    	mov    %ax,0x10ea0a
+  10284a:	b8 c0 f8 10 00       	mov    $0x10f8c0,%eax
+  10284f:	c1 e8 10             	shr    $0x10,%eax
+  102852:	a2 0c ea 10 00       	mov    %al,0x10ea0c
+  102857:	0f b6 05 0d ea 10 00 	movzbl 0x10ea0d,%eax
+  10285e:	83 e0 f0             	and    $0xfffffff0,%eax
+  102861:	83 c8 09             	or     $0x9,%eax
+  102864:	a2 0d ea 10 00       	mov    %al,0x10ea0d
+  102869:	0f b6 05 0d ea 10 00 	movzbl 0x10ea0d,%eax
+  102870:	83 c8 10             	or     $0x10,%eax
+  102873:	a2 0d ea 10 00       	mov    %al,0x10ea0d
+  102878:	0f b6 05 0d ea 10 00 	movzbl 0x10ea0d,%eax
+  10287f:	83 e0 9f             	and    $0xffffff9f,%eax
+  102882:	a2 0d ea 10 00       	mov    %al,0x10ea0d
+  102887:	0f b6 05 0d ea 10 00 	movzbl 0x10ea0d,%eax
+  10288e:	83 c8 80             	or     $0xffffff80,%eax
+  102891:	a2 0d ea 10 00       	mov    %al,0x10ea0d
+  102896:	0f b6 05 0e ea 10 00 	movzbl 0x10ea0e,%eax
+  10289d:	83 e0 f0             	and    $0xfffffff0,%eax
+  1028a0:	a2 0e ea 10 00       	mov    %al,0x10ea0e
+  1028a5:	0f b6 05 0e ea 10 00 	movzbl 0x10ea0e,%eax
+  1028ac:	83 e0 ef             	and    $0xffffffef,%eax
+  1028af:	a2 0e ea 10 00       	mov    %al,0x10ea0e
+  1028b4:	0f b6 05 0e ea 10 00 	movzbl 0x10ea0e,%eax
+  1028bb:	83 e0 df             	and    $0xffffffdf,%eax
+  1028be:	a2 0e ea 10 00       	mov    %al,0x10ea0e
+  1028c3:	0f b6 05 0e ea 10 00 	movzbl 0x10ea0e,%eax
+  1028ca:	83 c8 40             	or     $0x40,%eax
+  1028cd:	a2 0e ea 10 00       	mov    %al,0x10ea0e
+  1028d2:	0f b6 05 0e ea 10 00 	movzbl 0x10ea0e,%eax
+  1028d9:	83 e0 7f             	and    $0x7f,%eax
+  1028dc:	a2 0e ea 10 00       	mov    %al,0x10ea0e
+  1028e1:	b8 c0 f8 10 00       	mov    $0x10f8c0,%eax
+  1028e6:	c1 e8 18             	shr    $0x18,%eax
+  1028e9:	a2 0f ea 10 00       	mov    %al,0x10ea0f
+    gdt[SEG_TSS].sd_s = 0;
+  1028ee:	0f b6 05 0d ea 10 00 	movzbl 0x10ea0d,%eax
+  1028f5:	83 e0 ef             	and    $0xffffffef,%eax
+  1028f8:	a2 0d ea 10 00       	mov    %al,0x10ea0d
+
+    // reload all segment registers
+    lgdt(&gdt_pd);
+  1028fd:	c7 04 24 10 ea 10 00 	movl   $0x10ea10,(%esp)
+  102904:	e8 da fe ff ff       	call   1027e3 <lgdt>
+  102909:	66 c7 45 fe 28 00    	movw   $0x28,-0x2(%ebp)
+}
+
+static inline void
+ltr(uint16_t sel) {
+    asm volatile ("ltr %0" :: "r" (sel));
+  10290f:	0f b7 45 fe          	movzwl -0x2(%ebp),%eax
+  102913:	0f 00 d8             	ltr    %ax
+
+    // load the TSS
+    ltr(GD_TSS);
+}
+  102916:	c9                   	leave  
+  102917:	c3                   	ret    
+
+00102918 <pmm_init>:
+
+/* pmm_init - initialize the physical memory management */
+void
+pmm_init(void) {
+  102918:	55                   	push   %ebp
+  102919:	89 e5                	mov    %esp,%ebp
+    gdt_init();
+  10291b:	e8 f8 fe ff ff       	call   102818 <gdt_init>
+}
+  102920:	5d                   	pop    %ebp
+  102921:	c3                   	ret    
+
+00102922 <strlen>:
+ * @s:        the input string
+ *
+ * The strlen() function returns the length of string @s.
+ * */
+size_t
+strlen(const char *s) {
+  102922:	55                   	push   %ebp
+  102923:	89 e5                	mov    %esp,%ebp
+  102925:	83 ec 10             	sub    $0x10,%esp
+    size_t cnt = 0;
+  102928:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
+    while (*s ++ != '\0') {
+  10292f:	eb 04                	jmp    102935 <strlen+0x13>
+        cnt ++;
+  102931:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
+    while (*s ++ != '\0') {
+  102935:	8b 45 08             	mov    0x8(%ebp),%eax
+  102938:	8d 50 01             	lea    0x1(%eax),%edx
+  10293b:	89 55 08             	mov    %edx,0x8(%ebp)
+  10293e:	0f b6 00             	movzbl (%eax),%eax
+  102941:	84 c0                	test   %al,%al
+  102943:	75 ec                	jne    102931 <strlen+0xf>
+    }
+    return cnt;
+  102945:	8b 45 fc             	mov    -0x4(%ebp),%eax
+}
+  102948:	c9                   	leave  
+  102949:	c3                   	ret    
+
+0010294a <strnlen>:
+ * The return value is strlen(s), if that is less than @len, or
+ * @len if there is no '\0' character among the first @len characters
+ * pointed by @s.
+ * */
+size_t
+strnlen(const char *s, size_t len) {
+  10294a:	55                   	push   %ebp
+  10294b:	89 e5                	mov    %esp,%ebp
+  10294d:	83 ec 10             	sub    $0x10,%esp
+    size_t cnt = 0;
+  102950:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
+    while (cnt < len && *s ++ != '\0') {
+  102957:	eb 04                	jmp    10295d <strnlen+0x13>
+        cnt ++;
+  102959:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
+    while (cnt < len && *s ++ != '\0') {
+  10295d:	8b 45 fc             	mov    -0x4(%ebp),%eax
+  102960:	3b 45 0c             	cmp    0xc(%ebp),%eax
+  102963:	73 10                	jae    102975 <strnlen+0x2b>
+  102965:	8b 45 08             	mov    0x8(%ebp),%eax
+  102968:	8d 50 01             	lea    0x1(%eax),%edx
+  10296b:	89 55 08             	mov    %edx,0x8(%ebp)
+  10296e:	0f b6 00             	movzbl (%eax),%eax
+  102971:	84 c0                	test   %al,%al
+  102973:	75 e4                	jne    102959 <strnlen+0xf>
+    }
+    return cnt;
+  102975:	8b 45 fc             	mov    -0x4(%ebp),%eax
+}
+  102978:	c9                   	leave  
+  102979:	c3                   	ret    
+
+0010297a <strcpy>:
+ * To avoid overflows, the size of array pointed by @dst should be long enough to
+ * contain the same string as @src (including the terminating null character), and
+ * should not overlap in memory with @src.
+ * */
+char *
+strcpy(char *dst, const char *src) {
+  10297a:	55                   	push   %ebp
+  10297b:	89 e5                	mov    %esp,%ebp
+  10297d:	57                   	push   %edi
+  10297e:	56                   	push   %esi
+  10297f:	83 ec 20             	sub    $0x20,%esp
+  102982:	8b 45 08             	mov    0x8(%ebp),%eax
+  102985:	89 45 f4             	mov    %eax,-0xc(%ebp)
+  102988:	8b 45 0c             	mov    0xc(%ebp),%eax
+  10298b:	89 45 f0             	mov    %eax,-0x10(%ebp)
+#ifndef __HAVE_ARCH_STRCPY
+#define __HAVE_ARCH_STRCPY
+static inline char *
+__strcpy(char *dst, const char *src) {
+    int d0, d1, d2;
+    asm volatile (
+  10298e:	8b 55 f0             	mov    -0x10(%ebp),%edx
+  102991:	8b 45 f4             	mov    -0xc(%ebp),%eax
+  102994:	89 d1                	mov    %edx,%ecx
+  102996:	89 c2                	mov    %eax,%edx
+  102998:	89 ce                	mov    %ecx,%esi
+  10299a:	89 d7                	mov    %edx,%edi
+  10299c:	ac                   	lods   %ds:(%esi),%al
+  10299d:	aa                   	stos   %al,%es:(%edi)
+  10299e:	84 c0                	test   %al,%al
+  1029a0:	75 fa                	jne    10299c <strcpy+0x22>
+  1029a2:	89 fa                	mov    %edi,%edx
+  1029a4:	89 f1                	mov    %esi,%ecx
+  1029a6:	89 4d ec             	mov    %ecx,-0x14(%ebp)
+  1029a9:	89 55 e8             	mov    %edx,-0x18(%ebp)
+  1029ac:	89 45 e4             	mov    %eax,-0x1c(%ebp)
+            "stosb;"
+            "testb %%al, %%al;"
+            "jne 1b;"
+            : "=&S" (d0), "=&D" (d1), "=&a" (d2)
+            : "0" (src), "1" (dst) : "memory");
+    return dst;
+  1029af:	8b 45 f4             	mov    -0xc(%ebp),%eax
+    char *p = dst;
+    while ((*p ++ = *src ++) != '\0')
+        /* nothing */;
+    return dst;
+#endif /* __HAVE_ARCH_STRCPY */
+}
+  1029b2:	83 c4 20             	add    $0x20,%esp
+  1029b5:	5e                   	pop    %esi
+  1029b6:	5f                   	pop    %edi
+  1029b7:	5d                   	pop    %ebp
+  1029b8:	c3                   	ret    
+
+001029b9 <strncpy>:
+ * @len:    maximum number of characters to be copied from @src
+ *
+ * The return value is @dst
+ * */
+char *
+strncpy(char *dst, const char *src, size_t len) {
+  1029b9:	55                   	push   %ebp
+  1029ba:	89 e5                	mov    %esp,%ebp
+  1029bc:	83 ec 10             	sub    $0x10,%esp
+    char *p = dst;
+  1029bf:	8b 45 08             	mov    0x8(%ebp),%eax
+  1029c2:	89 45 fc             	mov    %eax,-0x4(%ebp)
+    while (len > 0) {
+  1029c5:	eb 21                	jmp    1029e8 <strncpy+0x2f>
+        if ((*p = *src) != '\0') {
+  1029c7:	8b 45 0c             	mov    0xc(%ebp),%eax
+  1029ca:	0f b6 10             	movzbl (%eax),%edx
+  1029cd:	8b 45 fc             	mov    -0x4(%ebp),%eax
+  1029d0:	88 10                	mov    %dl,(%eax)
+  1029d2:	8b 45 fc             	mov    -0x4(%ebp),%eax
+  1029d5:	0f b6 00             	movzbl (%eax),%eax
+  1029d8:	84 c0                	test   %al,%al
+  1029da:	74 04                	je     1029e0 <strncpy+0x27>
+            src ++;
+  1029dc:	83 45 0c 01          	addl   $0x1,0xc(%ebp)
+        }
+        p ++, len --;
+  1029e0:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
+  1029e4:	83 6d 10 01          	subl   $0x1,0x10(%ebp)
+    while (len > 0) {
+  1029e8:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
+  1029ec:	75 d9                	jne    1029c7 <strncpy+0xe>
+    }
+    return dst;
+  1029ee:	8b 45 08             	mov    0x8(%ebp),%eax
+}
+  1029f1:	c9                   	leave  
+  1029f2:	c3                   	ret    
+
+001029f3 <strcmp>:
+ * - A value greater than zero indicates that the first character that does
+ *   not match has a greater value in @s1 than in @s2;
+ * - And a value less than zero indicates the opposite.
+ * */
+int
+strcmp(const char *s1, const char *s2) {
+  1029f3:	55                   	push   %ebp
+  1029f4:	89 e5                	mov    %esp,%ebp
+  1029f6:	57                   	push   %edi
+  1029f7:	56                   	push   %esi
+  1029f8:	83 ec 20             	sub    $0x20,%esp
+  1029fb:	8b 45 08             	mov    0x8(%ebp),%eax
+  1029fe:	89 45 f4             	mov    %eax,-0xc(%ebp)
+  102a01:	8b 45 0c             	mov    0xc(%ebp),%eax
+  102a04:	89 45 f0             	mov    %eax,-0x10(%ebp)
+    asm volatile (
+  102a07:	8b 55 f4             	mov    -0xc(%ebp),%edx
+  102a0a:	8b 45 f0             	mov    -0x10(%ebp),%eax
+  102a0d:	89 d1                	mov    %edx,%ecx
+  102a0f:	89 c2                	mov    %eax,%edx
+  102a11:	89 ce                	mov    %ecx,%esi
+  102a13:	89 d7                	mov    %edx,%edi
+  102a15:	ac                   	lods   %ds:(%esi),%al
+  102a16:	ae                   	scas   %es:(%edi),%al
+  102a17:	75 08                	jne    102a21 <strcmp+0x2e>
+  102a19:	84 c0                	test   %al,%al
+  102a1b:	75 f8                	jne    102a15 <strcmp+0x22>
+  102a1d:	31 c0                	xor    %eax,%eax
+  102a1f:	eb 04                	jmp    102a25 <strcmp+0x32>
+  102a21:	19 c0                	sbb    %eax,%eax
+  102a23:	0c 01                	or     $0x1,%al
+  102a25:	89 fa                	mov    %edi,%edx
+  102a27:	89 f1                	mov    %esi,%ecx
+  102a29:	89 45 ec             	mov    %eax,-0x14(%ebp)
+  102a2c:	89 4d e8             	mov    %ecx,-0x18(%ebp)
+  102a2f:	89 55 e4             	mov    %edx,-0x1c(%ebp)
+    return ret;
+  102a32:	8b 45 ec             	mov    -0x14(%ebp),%eax
+    while (*s1 != '\0' && *s1 == *s2) {
+        s1 ++, s2 ++;
+    }
+    return (int)((unsigned char)*s1 - (unsigned char)*s2);
+#endif /* __HAVE_ARCH_STRCMP */
+}
+  102a35:	83 c4 20             	add    $0x20,%esp
+  102a38:	5e                   	pop    %esi
+  102a39:	5f                   	pop    %edi
+  102a3a:	5d                   	pop    %ebp
+  102a3b:	c3                   	ret    
+
+00102a3c <strncmp>:
+ * they are equal to each other, it continues with the following pairs until
+ * the characters differ, until a terminating null-character is reached, or
+ * until @n characters match in both strings, whichever happens first.
+ * */
+int
+strncmp(const char *s1, const char *s2, size_t n) {
+  102a3c:	55                   	push   %ebp
+  102a3d:	89 e5                	mov    %esp,%ebp
+    while (n > 0 && *s1 != '\0' && *s1 == *s2) {
+  102a3f:	eb 0c                	jmp    102a4d <strncmp+0x11>
+        n --, s1 ++, s2 ++;
+  102a41:	83 6d 10 01          	subl   $0x1,0x10(%ebp)
+  102a45:	83 45 08 01          	addl   $0x1,0x8(%ebp)
+  102a49:	83 45 0c 01          	addl   $0x1,0xc(%ebp)
+    while (n > 0 && *s1 != '\0' && *s1 == *s2) {
+  102a4d:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
+  102a51:	74 1a                	je     102a6d <strncmp+0x31>
+  102a53:	8b 45 08             	mov    0x8(%ebp),%eax
+  102a56:	0f b6 00             	movzbl (%eax),%eax
+  102a59:	84 c0                	test   %al,%al
+  102a5b:	74 10                	je     102a6d <strncmp+0x31>
+  102a5d:	8b 45 08             	mov    0x8(%ebp),%eax
+  102a60:	0f b6 10             	movzbl (%eax),%edx
+  102a63:	8b 45 0c             	mov    0xc(%ebp),%eax
+  102a66:	0f b6 00             	movzbl (%eax),%eax
+  102a69:	38 c2                	cmp    %al,%dl
+  102a6b:	74 d4                	je     102a41 <strncmp+0x5>
+    }
+    return (n == 0) ? 0 : (int)((unsigned char)*s1 - (unsigned char)*s2);
+  102a6d:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
+  102a71:	74 18                	je     102a8b <strncmp+0x4f>
+  102a73:	8b 45 08             	mov    0x8(%ebp),%eax
+  102a76:	0f b6 00             	movzbl (%eax),%eax
+  102a79:	0f b6 d0             	movzbl %al,%edx
+  102a7c:	8b 45 0c             	mov    0xc(%ebp),%eax
+  102a7f:	0f b6 00             	movzbl (%eax),%eax
+  102a82:	0f b6 c0             	movzbl %al,%eax
+  102a85:	29 c2                	sub    %eax,%edx
+  102a87:	89 d0                	mov    %edx,%eax
+  102a89:	eb 05                	jmp    102a90 <strncmp+0x54>
+  102a8b:	b8 00 00 00 00       	mov    $0x0,%eax
+}
+  102a90:	5d                   	pop    %ebp
+  102a91:	c3                   	ret    
+
+00102a92 <strchr>:
+ *
+ * The strchr() function returns a pointer to the first occurrence of
+ * character in @s. If the value is not found, the function returns 'NULL'.
+ * */
+char *
+strchr(const char *s, char c) {
+  102a92:	55                   	push   %ebp
+  102a93:	89 e5                	mov    %esp,%ebp
+  102a95:	83 ec 04             	sub    $0x4,%esp
+  102a98:	8b 45 0c             	mov    0xc(%ebp),%eax
+  102a9b:	88 45 fc             	mov    %al,-0x4(%ebp)
+    while (*s != '\0') {
+  102a9e:	eb 14                	jmp    102ab4 <strchr+0x22>
+        if (*s == c) {
+  102aa0:	8b 45 08             	mov    0x8(%ebp),%eax
+  102aa3:	0f b6 00             	movzbl (%eax),%eax
+  102aa6:	3a 45 fc             	cmp    -0x4(%ebp),%al
+  102aa9:	75 05                	jne    102ab0 <strchr+0x1e>
+            return (char *)s;
+  102aab:	8b 45 08             	mov    0x8(%ebp),%eax
+  102aae:	eb 13                	jmp    102ac3 <strchr+0x31>
+        }
+        s ++;
+  102ab0:	83 45 08 01          	addl   $0x1,0x8(%ebp)
+    while (*s != '\0') {
+  102ab4:	8b 45 08             	mov    0x8(%ebp),%eax
+  102ab7:	0f b6 00             	movzbl (%eax),%eax
+  102aba:	84 c0                	test   %al,%al
+  102abc:	75 e2                	jne    102aa0 <strchr+0xe>
+    }
+    return NULL;
+  102abe:	b8 00 00 00 00       	mov    $0x0,%eax
+}
+  102ac3:	c9                   	leave  
+  102ac4:	c3                   	ret    
+
+00102ac5 <strfind>:
+ * The strfind() function is like strchr() except that if @c is
+ * not found in @s, then it returns a pointer to the null byte at the
+ * end of @s, rather than 'NULL'.
+ * */
+char *
+strfind(const char *s, char c) {
+  102ac5:	55                   	push   %ebp
+  102ac6:	89 e5                	mov    %esp,%ebp
+  102ac8:	83 ec 04             	sub    $0x4,%esp
+  102acb:	8b 45 0c             	mov    0xc(%ebp),%eax
+  102ace:	88 45 fc             	mov    %al,-0x4(%ebp)
+    while (*s != '\0') {
+  102ad1:	eb 11                	jmp    102ae4 <strfind+0x1f>
+        if (*s == c) {
+  102ad3:	8b 45 08             	mov    0x8(%ebp),%eax
+  102ad6:	0f b6 00             	movzbl (%eax),%eax
+  102ad9:	3a 45 fc             	cmp    -0x4(%ebp),%al
+  102adc:	75 02                	jne    102ae0 <strfind+0x1b>
+            break;
+  102ade:	eb 0e                	jmp    102aee <strfind+0x29>
+        }
+        s ++;
+  102ae0:	83 45 08 01          	addl   $0x1,0x8(%ebp)
+    while (*s != '\0') {
+  102ae4:	8b 45 08             	mov    0x8(%ebp),%eax
+  102ae7:	0f b6 00             	movzbl (%eax),%eax
+  102aea:	84 c0                	test   %al,%al
+  102aec:	75 e5                	jne    102ad3 <strfind+0xe>
+    }
+    return (char *)s;
+  102aee:	8b 45 08             	mov    0x8(%ebp),%eax
+}
+  102af1:	c9                   	leave  
+  102af2:	c3                   	ret    
+
+00102af3 <strtol>:
+ * an optional "0x" or "0X" prefix.
+ *
+ * The strtol() function returns the converted integral number as a long int value.
+ * */
+long
+strtol(const char *s, char **endptr, int base) {
+  102af3:	55                   	push   %ebp
+  102af4:	89 e5                	mov    %esp,%ebp
+  102af6:	83 ec 10             	sub    $0x10,%esp
+    int neg = 0;
+  102af9:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
+    long val = 0;
+  102b00:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
+
+    // gobble initial whitespace
+    while (*s == ' ' || *s == '\t') {
+  102b07:	eb 04                	jmp    102b0d <strtol+0x1a>
+        s ++;
+  102b09:	83 45 08 01          	addl   $0x1,0x8(%ebp)
+    while (*s == ' ' || *s == '\t') {
+  102b0d:	8b 45 08             	mov    0x8(%ebp),%eax
+  102b10:	0f b6 00             	movzbl (%eax),%eax
+  102b13:	3c 20                	cmp    $0x20,%al
+  102b15:	74 f2                	je     102b09 <strtol+0x16>
+  102b17:	8b 45 08             	mov    0x8(%ebp),%eax
+  102b1a:	0f b6 00             	movzbl (%eax),%eax
+  102b1d:	3c 09                	cmp    $0x9,%al
+  102b1f:	74 e8                	je     102b09 <strtol+0x16>
+    }
+
+    // plus/minus sign
+    if (*s == '+') {
+  102b21:	8b 45 08             	mov    0x8(%ebp),%eax
+  102b24:	0f b6 00             	movzbl (%eax),%eax
+  102b27:	3c 2b                	cmp    $0x2b,%al
+  102b29:	75 06                	jne    102b31 <strtol+0x3e>
+        s ++;
+  102b2b:	83 45 08 01          	addl   $0x1,0x8(%ebp)
+  102b2f:	eb 15                	jmp    102b46 <strtol+0x53>
+    }
+    else if (*s == '-') {
+  102b31:	8b 45 08             	mov    0x8(%ebp),%eax
+  102b34:	0f b6 00             	movzbl (%eax),%eax
+  102b37:	3c 2d                	cmp    $0x2d,%al
+  102b39:	75 0b                	jne    102b46 <strtol+0x53>
+        s ++, neg = 1;
+  102b3b:	83 45 08 01          	addl   $0x1,0x8(%ebp)
+  102b3f:	c7 45 fc 01 00 00 00 	movl   $0x1,-0x4(%ebp)
+    }
+
+    // hex or octal base prefix
+    if ((base == 0 || base == 16) && (s[0] == '0' && s[1] == 'x')) {
+  102b46:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
+  102b4a:	74 06                	je     102b52 <strtol+0x5f>
+  102b4c:	83 7d 10 10          	cmpl   $0x10,0x10(%ebp)
+  102b50:	75 24                	jne    102b76 <strtol+0x83>
+  102b52:	8b 45 08             	mov    0x8(%ebp),%eax
+  102b55:	0f b6 00             	movzbl (%eax),%eax
+  102b58:	3c 30                	cmp    $0x30,%al
+  102b5a:	75 1a                	jne    102b76 <strtol+0x83>
+  102b5c:	8b 45 08             	mov    0x8(%ebp),%eax
+  102b5f:	83 c0 01             	add    $0x1,%eax
+  102b62:	0f b6 00             	movzbl (%eax),%eax
+  102b65:	3c 78                	cmp    $0x78,%al
+  102b67:	75 0d                	jne    102b76 <strtol+0x83>
+        s += 2, base = 16;
+  102b69:	83 45 08 02          	addl   $0x2,0x8(%ebp)
+  102b6d:	c7 45 10 10 00 00 00 	movl   $0x10,0x10(%ebp)
+  102b74:	eb 2a                	jmp    102ba0 <strtol+0xad>
+    }
+    else if (base == 0 && s[0] == '0') {
+  102b76:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
+  102b7a:	75 17                	jne    102b93 <strtol+0xa0>
+  102b7c:	8b 45 08             	mov    0x8(%ebp),%eax
+  102b7f:	0f b6 00             	movzbl (%eax),%eax
+  102b82:	3c 30                	cmp    $0x30,%al
+  102b84:	75 0d                	jne    102b93 <strtol+0xa0>
+        s ++, base = 8;
+  102b86:	83 45 08 01          	addl   $0x1,0x8(%ebp)
+  102b8a:	c7 45 10 08 00 00 00 	movl   $0x8,0x10(%ebp)
+  102b91:	eb 0d                	jmp    102ba0 <strtol+0xad>
+    }
+    else if (base == 0) {
+  102b93:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
+  102b97:	75 07                	jne    102ba0 <strtol+0xad>
+        base = 10;
+  102b99:	c7 45 10 0a 00 00 00 	movl   $0xa,0x10(%ebp)
+
+    // digits
+    while (1) {
+        int dig;
+
+        if (*s >= '0' && *s <= '9') {
+  102ba0:	8b 45 08             	mov    0x8(%ebp),%eax
+  102ba3:	0f b6 00             	movzbl (%eax),%eax
+  102ba6:	3c 2f                	cmp    $0x2f,%al
+  102ba8:	7e 1b                	jle    102bc5 <strtol+0xd2>
+  102baa:	8b 45 08             	mov    0x8(%ebp),%eax
+  102bad:	0f b6 00             	movzbl (%eax),%eax
+  102bb0:	3c 39                	cmp    $0x39,%al
+  102bb2:	7f 11                	jg     102bc5 <strtol+0xd2>
+            dig = *s - '0';
+  102bb4:	8b 45 08             	mov    0x8(%ebp),%eax
+  102bb7:	0f b6 00             	movzbl (%eax),%eax
+  102bba:	0f be c0             	movsbl %al,%eax
+  102bbd:	83 e8 30             	sub    $0x30,%eax
+  102bc0:	89 45 f4             	mov    %eax,-0xc(%ebp)
+  102bc3:	eb 48                	jmp    102c0d <strtol+0x11a>
+        }
+        else if (*s >= 'a' && *s <= 'z') {
+  102bc5:	8b 45 08             	mov    0x8(%ebp),%eax
+  102bc8:	0f b6 00             	movzbl (%eax),%eax
+  102bcb:	3c 60                	cmp    $0x60,%al
+  102bcd:	7e 1b                	jle    102bea <strtol+0xf7>
+  102bcf:	8b 45 08             	mov    0x8(%ebp),%eax
+  102bd2:	0f b6 00             	movzbl (%eax),%eax
+  102bd5:	3c 7a                	cmp    $0x7a,%al
+  102bd7:	7f 11                	jg     102bea <strtol+0xf7>
+            dig = *s - 'a' + 10;
+  102bd9:	8b 45 08             	mov    0x8(%ebp),%eax
+  102bdc:	0f b6 00             	movzbl (%eax),%eax
+  102bdf:	0f be c0             	movsbl %al,%eax
+  102be2:	83 e8 57             	sub    $0x57,%eax
+  102be5:	89 45 f4             	mov    %eax,-0xc(%ebp)
+  102be8:	eb 23                	jmp    102c0d <strtol+0x11a>
+        }
+        else if (*s >= 'A' && *s <= 'Z') {
+  102bea:	8b 45 08             	mov    0x8(%ebp),%eax
+  102bed:	0f b6 00             	movzbl (%eax),%eax
+  102bf0:	3c 40                	cmp    $0x40,%al
+  102bf2:	7e 3d                	jle    102c31 <strtol+0x13e>
+  102bf4:	8b 45 08             	mov    0x8(%ebp),%eax
+  102bf7:	0f b6 00             	movzbl (%eax),%eax
+  102bfa:	3c 5a                	cmp    $0x5a,%al
+  102bfc:	7f 33                	jg     102c31 <strtol+0x13e>
+            dig = *s - 'A' + 10;
+  102bfe:	8b 45 08             	mov    0x8(%ebp),%eax
+  102c01:	0f b6 00             	movzbl (%eax),%eax
+  102c04:	0f be c0             	movsbl %al,%eax
+  102c07:	83 e8 37             	sub    $0x37,%eax
+  102c0a:	89 45 f4             	mov    %eax,-0xc(%ebp)
+        }
+        else {
+            break;
+        }
+        if (dig >= base) {
+  102c0d:	8b 45 f4             	mov    -0xc(%ebp),%eax
+  102c10:	3b 45 10             	cmp    0x10(%ebp),%eax
+  102c13:	7c 02                	jl     102c17 <strtol+0x124>
+            break;
+  102c15:	eb 1a                	jmp    102c31 <strtol+0x13e>
+        }
+        s ++, val = (val * base) + dig;
+  102c17:	83 45 08 01          	addl   $0x1,0x8(%ebp)
+  102c1b:	8b 45 f8             	mov    -0x8(%ebp),%eax
+  102c1e:	0f af 45 10          	imul   0x10(%ebp),%eax
+  102c22:	89 c2                	mov    %eax,%edx
+  102c24:	8b 45 f4             	mov    -0xc(%ebp),%eax
+  102c27:	01 d0                	add    %edx,%eax
+  102c29:	89 45 f8             	mov    %eax,-0x8(%ebp)
+        // we don't properly detect overflow!
+    }
+  102c2c:	e9 6f ff ff ff       	jmp    102ba0 <strtol+0xad>
+
+    if (endptr) {
+  102c31:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
+  102c35:	74 08                	je     102c3f <strtol+0x14c>
+        *endptr = (char *) s;
+  102c37:	8b 45 0c             	mov    0xc(%ebp),%eax
+  102c3a:	8b 55 08             	mov    0x8(%ebp),%edx
+  102c3d:	89 10                	mov    %edx,(%eax)
+    }
+    return (neg ? -val : val);
+  102c3f:	83 7d fc 00          	cmpl   $0x0,-0x4(%ebp)
+  102c43:	74 07                	je     102c4c <strtol+0x159>
+  102c45:	8b 45 f8             	mov    -0x8(%ebp),%eax
+  102c48:	f7 d8                	neg    %eax
+  102c4a:	eb 03                	jmp    102c4f <strtol+0x15c>
+  102c4c:	8b 45 f8             	mov    -0x8(%ebp),%eax
+}
+  102c4f:	c9                   	leave  
+  102c50:	c3                   	ret    
+
+00102c51 <memset>:
+ * @n:        number of bytes to be set to the value
+ *
+ * The memset() function returns @s.
+ * */
+void *
+memset(void *s, char c, size_t n) {
+  102c51:	55                   	push   %ebp
+  102c52:	89 e5                	mov    %esp,%ebp
+  102c54:	57                   	push   %edi
+  102c55:	83 ec 24             	sub    $0x24,%esp
+  102c58:	8b 45 0c             	mov    0xc(%ebp),%eax
+  102c5b:	88 45 d8             	mov    %al,-0x28(%ebp)
+#ifdef __HAVE_ARCH_MEMSET
+    return __memset(s, c, n);
+  102c5e:	0f be 45 d8          	movsbl -0x28(%ebp),%eax
+  102c62:	8b 55 08             	mov    0x8(%ebp),%edx
+  102c65:	89 55 f8             	mov    %edx,-0x8(%ebp)
+  102c68:	88 45 f7             	mov    %al,-0x9(%ebp)
+  102c6b:	8b 45 10             	mov    0x10(%ebp),%eax
+  102c6e:	89 45 f0             	mov    %eax,-0x10(%ebp)
+#ifndef __HAVE_ARCH_MEMSET
+#define __HAVE_ARCH_MEMSET
+static inline void *
+__memset(void *s, char c, size_t n) {
+    int d0, d1;
+    asm volatile (
+  102c71:	8b 4d f0             	mov    -0x10(%ebp),%ecx
+  102c74:	0f b6 45 f7          	movzbl -0x9(%ebp),%eax
+  102c78:	8b 55 f8             	mov    -0x8(%ebp),%edx
+  102c7b:	89 d7                	mov    %edx,%edi
+  102c7d:	f3 aa                	rep stos %al,%es:(%edi)
+  102c7f:	89 fa                	mov    %edi,%edx
+  102c81:	89 4d ec             	mov    %ecx,-0x14(%ebp)
+  102c84:	89 55 e8             	mov    %edx,-0x18(%ebp)
+            "rep; stosb;"
+            : "=&c" (d0), "=&D" (d1)
+            : "0" (n), "a" (c), "1" (s)
+            : "memory");
+    return s;
+  102c87:	8b 45 f8             	mov    -0x8(%ebp),%eax
+    while (n -- > 0) {
+        *p ++ = c;
+    }
+    return s;
+#endif /* __HAVE_ARCH_MEMSET */
+}
+  102c8a:	83 c4 24             	add    $0x24,%esp
+  102c8d:	5f                   	pop    %edi
+  102c8e:	5d                   	pop    %ebp
+  102c8f:	c3                   	ret    
+
+00102c90 <memmove>:
+ * @n:        number of bytes to copy
+ *
+ * The memmove() function returns @dst.
+ * */
+void *
+memmove(void *dst, const void *src, size_t n) {
+  102c90:	55                   	push   %ebp
+  102c91:	89 e5                	mov    %esp,%ebp
+  102c93:	57                   	push   %edi
+  102c94:	56                   	push   %esi
+  102c95:	53                   	push   %ebx
+  102c96:	83 ec 30             	sub    $0x30,%esp
+  102c99:	8b 45 08             	mov    0x8(%ebp),%eax
+  102c9c:	89 45 f0             	mov    %eax,-0x10(%ebp)
+  102c9f:	8b 45 0c             	mov    0xc(%ebp),%eax
+  102ca2:	89 45 ec             	mov    %eax,-0x14(%ebp)
+  102ca5:	8b 45 10             	mov    0x10(%ebp),%eax
+  102ca8:	89 45 e8             	mov    %eax,-0x18(%ebp)
+
+#ifndef __HAVE_ARCH_MEMMOVE
+#define __HAVE_ARCH_MEMMOVE
+static inline void *
+__memmove(void *dst, const void *src, size_t n) {
+    if (dst < src) {
+  102cab:	8b 45 f0             	mov    -0x10(%ebp),%eax
+  102cae:	3b 45 ec             	cmp    -0x14(%ebp),%eax
+  102cb1:	73 42                	jae    102cf5 <memmove+0x65>
+  102cb3:	8b 45 f0             	mov    -0x10(%ebp),%eax
+  102cb6:	89 45 e4             	mov    %eax,-0x1c(%ebp)
+  102cb9:	8b 45 ec             	mov    -0x14(%ebp),%eax
+  102cbc:	89 45 e0             	mov    %eax,-0x20(%ebp)
+  102cbf:	8b 45 e8             	mov    -0x18(%ebp),%eax
+  102cc2:	89 45 dc             	mov    %eax,-0x24(%ebp)
+            "andl $3, %%ecx;"
+            "jz 1f;"
+            "rep; movsb;"
+            "1:"
+            : "=&c" (d0), "=&D" (d1), "=&S" (d2)
+            : "0" (n / 4), "g" (n), "1" (dst), "2" (src)
+  102cc5:	8b 45 dc             	mov    -0x24(%ebp),%eax
+  102cc8:	c1 e8 02             	shr    $0x2,%eax
+  102ccb:	89 c1                	mov    %eax,%ecx
+    asm volatile (
+  102ccd:	8b 55 e4             	mov    -0x1c(%ebp),%edx
+  102cd0:	8b 45 e0             	mov    -0x20(%ebp),%eax
+  102cd3:	89 d7                	mov    %edx,%edi
+  102cd5:	89 c6                	mov    %eax,%esi
+  102cd7:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
+  102cd9:	8b 4d dc             	mov    -0x24(%ebp),%ecx
+  102cdc:	83 e1 03             	and    $0x3,%ecx
+  102cdf:	74 02                	je     102ce3 <memmove+0x53>
+  102ce1:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
+  102ce3:	89 f0                	mov    %esi,%eax
+  102ce5:	89 fa                	mov    %edi,%edx
+  102ce7:	89 4d d8             	mov    %ecx,-0x28(%ebp)
+  102cea:	89 55 d4             	mov    %edx,-0x2c(%ebp)
+  102ced:	89 45 d0             	mov    %eax,-0x30(%ebp)
+            : "memory");
+    return dst;
+  102cf0:	8b 45 e4             	mov    -0x1c(%ebp),%eax
+  102cf3:	eb 36                	jmp    102d2b <memmove+0x9b>
+            : "0" (n), "1" (n - 1 + src), "2" (n - 1 + dst)
+  102cf5:	8b 45 e8             	mov    -0x18(%ebp),%eax
+  102cf8:	8d 50 ff             	lea    -0x1(%eax),%edx
+  102cfb:	8b 45 ec             	mov    -0x14(%ebp),%eax
+  102cfe:	01 c2                	add    %eax,%edx
+  102d00:	8b 45 e8             	mov    -0x18(%ebp),%eax
+  102d03:	8d 48 ff             	lea    -0x1(%eax),%ecx
+  102d06:	8b 45 f0             	mov    -0x10(%ebp),%eax
+  102d09:	8d 1c 01             	lea    (%ecx,%eax,1),%ebx
+    asm volatile (
+  102d0c:	8b 45 e8             	mov    -0x18(%ebp),%eax
+  102d0f:	89 c1                	mov    %eax,%ecx
+  102d11:	89 d8                	mov    %ebx,%eax
+  102d13:	89 d6                	mov    %edx,%esi
+  102d15:	89 c7                	mov    %eax,%edi
+  102d17:	fd                   	std    
+  102d18:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
+  102d1a:	fc                   	cld    
+  102d1b:	89 f8                	mov    %edi,%eax
+  102d1d:	89 f2                	mov    %esi,%edx
+  102d1f:	89 4d cc             	mov    %ecx,-0x34(%ebp)
+  102d22:	89 55 c8             	mov    %edx,-0x38(%ebp)
+  102d25:	89 45 c4             	mov    %eax,-0x3c(%ebp)
+    return dst;
+  102d28:	8b 45 f0             	mov    -0x10(%ebp),%eax
+            *d ++ = *s ++;
+        }
+    }
+    return dst;
+#endif /* __HAVE_ARCH_MEMMOVE */
+}
+  102d2b:	83 c4 30             	add    $0x30,%esp
+  102d2e:	5b                   	pop    %ebx
+  102d2f:	5e                   	pop    %esi
+  102d30:	5f                   	pop    %edi
+  102d31:	5d                   	pop    %ebp
+  102d32:	c3                   	ret    
+
+00102d33 <memcpy>:
+ * it always copies exactly @n bytes. To avoid overflows, the size of arrays pointed
+ * by both @src and @dst, should be at least @n bytes, and should not overlap
+ * (for overlapping memory area, memmove is a safer approach).
+ * */
+void *
+memcpy(void *dst, const void *src, size_t n) {
+  102d33:	55                   	push   %ebp
+  102d34:	89 e5                	mov    %esp,%ebp
+  102d36:	57                   	push   %edi
+  102d37:	56                   	push   %esi
+  102d38:	83 ec 20             	sub    $0x20,%esp
+  102d3b:	8b 45 08             	mov    0x8(%ebp),%eax
+  102d3e:	89 45 f4             	mov    %eax,-0xc(%ebp)
+  102d41:	8b 45 0c             	mov    0xc(%ebp),%eax
+  102d44:	89 45 f0             	mov    %eax,-0x10(%ebp)
+  102d47:	8b 45 10             	mov    0x10(%ebp),%eax
+  102d4a:	89 45 ec             	mov    %eax,-0x14(%ebp)
+            : "0" (n / 4), "g" (n), "1" (dst), "2" (src)
+  102d4d:	8b 45 ec             	mov    -0x14(%ebp),%eax
+  102d50:	c1 e8 02             	shr    $0x2,%eax
+  102d53:	89 c1                	mov    %eax,%ecx
+    asm volatile (
+  102d55:	8b 55 f4             	mov    -0xc(%ebp),%edx
+  102d58:	8b 45 f0             	mov    -0x10(%ebp),%eax
+  102d5b:	89 d7                	mov    %edx,%edi
+  102d5d:	89 c6                	mov    %eax,%esi
+  102d5f:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
+  102d61:	8b 4d ec             	mov    -0x14(%ebp),%ecx
+  102d64:	83 e1 03             	and    $0x3,%ecx
+  102d67:	74 02                	je     102d6b <memcpy+0x38>
+  102d69:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
+  102d6b:	89 f0                	mov    %esi,%eax
+  102d6d:	89 fa                	mov    %edi,%edx
+  102d6f:	89 4d e8             	mov    %ecx,-0x18(%ebp)
+  102d72:	89 55 e4             	mov    %edx,-0x1c(%ebp)
+  102d75:	89 45 e0             	mov    %eax,-0x20(%ebp)
+    return dst;
+  102d78:	8b 45 f4             	mov    -0xc(%ebp),%eax
+    while (n -- > 0) {
+        *d ++ = *s ++;
+    }
+    return dst;
+#endif /* __HAVE_ARCH_MEMCPY */
+}
+  102d7b:	83 c4 20             	add    $0x20,%esp
+  102d7e:	5e                   	pop    %esi
+  102d7f:	5f                   	pop    %edi
+  102d80:	5d                   	pop    %ebp
+  102d81:	c3                   	ret    
+
+00102d82 <memcmp>:
+ *   match in both memory blocks has a greater value in @v1 than in @v2
+ *   as if evaluated as unsigned char values;
+ * - And a value less than zero indicates the opposite.
+ * */
+int
+memcmp(const void *v1, const void *v2, size_t n) {
+  102d82:	55                   	push   %ebp
+  102d83:	89 e5                	mov    %esp,%ebp
+  102d85:	83 ec 10             	sub    $0x10,%esp
+    const char *s1 = (const char *)v1;
+  102d88:	8b 45 08             	mov    0x8(%ebp),%eax
+  102d8b:	89 45 fc             	mov    %eax,-0x4(%ebp)
+    const char *s2 = (const char *)v2;
+  102d8e:	8b 45 0c             	mov    0xc(%ebp),%eax
+  102d91:	89 45 f8             	mov    %eax,-0x8(%ebp)
+    while (n -- > 0) {
+  102d94:	eb 30                	jmp    102dc6 <memcmp+0x44>
+        if (*s1 != *s2) {
+  102d96:	8b 45 fc             	mov    -0x4(%ebp),%eax
+  102d99:	0f b6 10             	movzbl (%eax),%edx
+  102d9c:	8b 45 f8             	mov    -0x8(%ebp),%eax
+  102d9f:	0f b6 00             	movzbl (%eax),%eax
+  102da2:	38 c2                	cmp    %al,%dl
+  102da4:	74 18                	je     102dbe <memcmp+0x3c>
+            return (int)((unsigned char)*s1 - (unsigned char)*s2);
+  102da6:	8b 45 fc             	mov    -0x4(%ebp),%eax
+  102da9:	0f b6 00             	movzbl (%eax),%eax
+  102dac:	0f b6 d0             	movzbl %al,%edx
+  102daf:	8b 45 f8             	mov    -0x8(%ebp),%eax
+  102db2:	0f b6 00             	movzbl (%eax),%eax
+  102db5:	0f b6 c0             	movzbl %al,%eax
+  102db8:	29 c2                	sub    %eax,%edx
+  102dba:	89 d0                	mov    %edx,%eax
+  102dbc:	eb 1a                	jmp    102dd8 <memcmp+0x56>
+        }
+        s1 ++, s2 ++;
+  102dbe:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
+  102dc2:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
+    while (n -- > 0) {
+  102dc6:	8b 45 10             	mov    0x10(%ebp),%eax
+  102dc9:	8d 50 ff             	lea    -0x1(%eax),%edx
+  102dcc:	89 55 10             	mov    %edx,0x10(%ebp)
+  102dcf:	85 c0                	test   %eax,%eax
+  102dd1:	75 c3                	jne    102d96 <memcmp+0x14>
+    }
+    return 0;
+  102dd3:	b8 00 00 00 00       	mov    $0x0,%eax
+}
+  102dd8:	c9                   	leave  
+  102dd9:	c3                   	ret    
+
+00102dda <printnum>:
+ * @width:         maximum number of digits, if the actual width is less than @width, use @padc instead
+ * @padc:        character that padded on the left if the actual width is less than @width
+ * */
+static void
+printnum(void (*putch)(int, void*), void *putdat,
+        unsigned long long num, unsigned base, int width, int padc) {
+  102dda:	55                   	push   %ebp
+  102ddb:	89 e5                	mov    %esp,%ebp
+  102ddd:	83 ec 58             	sub    $0x58,%esp
+  102de0:	8b 45 10             	mov    0x10(%ebp),%eax
+  102de3:	89 45 d0             	mov    %eax,-0x30(%ebp)
+  102de6:	8b 45 14             	mov    0x14(%ebp),%eax
+  102de9:	89 45 d4             	mov    %eax,-0x2c(%ebp)
+    unsigned long long result = num;
+  102dec:	8b 45 d0             	mov    -0x30(%ebp),%eax
+  102def:	8b 55 d4             	mov    -0x2c(%ebp),%edx
+  102df2:	89 45 e8             	mov    %eax,-0x18(%ebp)
+  102df5:	89 55 ec             	mov    %edx,-0x14(%ebp)
+    unsigned mod = do_div(result, base);
+  102df8:	8b 45 18             	mov    0x18(%ebp),%eax
+  102dfb:	89 45 e4             	mov    %eax,-0x1c(%ebp)
+  102dfe:	8b 45 e8             	mov    -0x18(%ebp),%eax
+  102e01:	8b 55 ec             	mov    -0x14(%ebp),%edx
+  102e04:	89 45 e0             	mov    %eax,-0x20(%ebp)
+  102e07:	89 55 f0             	mov    %edx,-0x10(%ebp)
+  102e0a:	8b 45 f0             	mov    -0x10(%ebp),%eax
+  102e0d:	89 45 f4             	mov    %eax,-0xc(%ebp)
+  102e10:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
+  102e14:	74 1c                	je     102e32 <printnum+0x58>
+  102e16:	8b 45 f0             	mov    -0x10(%ebp),%eax
+  102e19:	ba 00 00 00 00       	mov    $0x0,%edx
+  102e1e:	f7 75 e4             	divl   -0x1c(%ebp)
+  102e21:	89 55 f4             	mov    %edx,-0xc(%ebp)
+  102e24:	8b 45 f0             	mov    -0x10(%ebp),%eax
+  102e27:	ba 00 00 00 00       	mov    $0x0,%edx
+  102e2c:	f7 75 e4             	divl   -0x1c(%ebp)
+  102e2f:	89 45 f0             	mov    %eax,-0x10(%ebp)
+  102e32:	8b 45 e0             	mov    -0x20(%ebp),%eax
+  102e35:	8b 55 f4             	mov    -0xc(%ebp),%edx
+  102e38:	f7 75 e4             	divl   -0x1c(%ebp)
+  102e3b:	89 45 e0             	mov    %eax,-0x20(%ebp)
+  102e3e:	89 55 dc             	mov    %edx,-0x24(%ebp)
+  102e41:	8b 45 e0             	mov    -0x20(%ebp),%eax
+  102e44:	8b 55 f0             	mov    -0x10(%ebp),%edx
+  102e47:	89 45 e8             	mov    %eax,-0x18(%ebp)
+  102e4a:	89 55 ec             	mov    %edx,-0x14(%ebp)
+  102e4d:	8b 45 dc             	mov    -0x24(%ebp),%eax
+  102e50:	89 45 d8             	mov    %eax,-0x28(%ebp)
+
+    // first recursively print all preceding (more significant) digits
+    if (num >= base) {
+  102e53:	8b 45 18             	mov    0x18(%ebp),%eax
+  102e56:	ba 00 00 00 00       	mov    $0x0,%edx
+  102e5b:	3b 55 d4             	cmp    -0x2c(%ebp),%edx
+  102e5e:	77 56                	ja     102eb6 <printnum+0xdc>
+  102e60:	3b 55 d4             	cmp    -0x2c(%ebp),%edx
+  102e63:	72 05                	jb     102e6a <printnum+0x90>
+  102e65:	3b 45 d0             	cmp    -0x30(%ebp),%eax
+  102e68:	77 4c                	ja     102eb6 <printnum+0xdc>
+        printnum(putch, putdat, result, base, width - 1, padc);
+  102e6a:	8b 45 1c             	mov    0x1c(%ebp),%eax
+  102e6d:	8d 50 ff             	lea    -0x1(%eax),%edx
+  102e70:	8b 45 20             	mov    0x20(%ebp),%eax
+  102e73:	89 44 24 18          	mov    %eax,0x18(%esp)
+  102e77:	89 54 24 14          	mov    %edx,0x14(%esp)
+  102e7b:	8b 45 18             	mov    0x18(%ebp),%eax
+  102e7e:	89 44 24 10          	mov    %eax,0x10(%esp)
+  102e82:	8b 45 e8             	mov    -0x18(%ebp),%eax
+  102e85:	8b 55 ec             	mov    -0x14(%ebp),%edx
+  102e88:	89 44 24 08          	mov    %eax,0x8(%esp)
+  102e8c:	89 54 24 0c          	mov    %edx,0xc(%esp)
+  102e90:	8b 45 0c             	mov    0xc(%ebp),%eax
+  102e93:	89 44 24 04          	mov    %eax,0x4(%esp)
+  102e97:	8b 45 08             	mov    0x8(%ebp),%eax
+  102e9a:	89 04 24             	mov    %eax,(%esp)
+  102e9d:	e8 38 ff ff ff       	call   102dda <printnum>
+  102ea2:	eb 1c                	jmp    102ec0 <printnum+0xe6>
+    } else {
+        // print any needed pad characters before first digit
+        while (-- width > 0)
+            putch(padc, putdat);
+  102ea4:	8b 45 0c             	mov    0xc(%ebp),%eax
+  102ea7:	89 44 24 04          	mov    %eax,0x4(%esp)
+  102eab:	8b 45 20             	mov    0x20(%ebp),%eax
+  102eae:	89 04 24             	mov    %eax,(%esp)
+  102eb1:	8b 45 08             	mov    0x8(%ebp),%eax
+  102eb4:	ff d0                	call   *%eax
+        while (-- width > 0)
+  102eb6:	83 6d 1c 01          	subl   $0x1,0x1c(%ebp)
+  102eba:	83 7d 1c 00          	cmpl   $0x0,0x1c(%ebp)
+  102ebe:	7f e4                	jg     102ea4 <printnum+0xca>
+    }
+    // then print this (the least significant) digit
+    putch("0123456789abcdef"[mod], putdat);
+  102ec0:	8b 45 d8             	mov    -0x28(%ebp),%eax
+  102ec3:	05 10 3c 10 00       	add    $0x103c10,%eax
+  102ec8:	0f b6 00             	movzbl (%eax),%eax
+  102ecb:	0f be c0             	movsbl %al,%eax
+  102ece:	8b 55 0c             	mov    0xc(%ebp),%edx
+  102ed1:	89 54 24 04          	mov    %edx,0x4(%esp)
+  102ed5:	89 04 24             	mov    %eax,(%esp)
+  102ed8:	8b 45 08             	mov    0x8(%ebp),%eax
+  102edb:	ff d0                	call   *%eax
+}
+  102edd:	c9                   	leave  
+  102ede:	c3                   	ret    
+
+00102edf <getuint>:
+ * getuint - get an unsigned int of various possible sizes from a varargs list
+ * @ap:            a varargs list pointer
+ * @lflag:        determines the size of the vararg that @ap points to
+ * */
+static unsigned long long
+getuint(va_list *ap, int lflag) {
+  102edf:	55                   	push   %ebp
+  102ee0:	89 e5                	mov    %esp,%ebp
+    if (lflag >= 2) {
+  102ee2:	83 7d 0c 01          	cmpl   $0x1,0xc(%ebp)
+  102ee6:	7e 14                	jle    102efc <getuint+0x1d>
+        return va_arg(*ap, unsigned long long);
+  102ee8:	8b 45 08             	mov    0x8(%ebp),%eax
+  102eeb:	8b 00                	mov    (%eax),%eax
+  102eed:	8d 48 08             	lea    0x8(%eax),%ecx
+  102ef0:	8b 55 08             	mov    0x8(%ebp),%edx
+  102ef3:	89 0a                	mov    %ecx,(%edx)
+  102ef5:	8b 50 04             	mov    0x4(%eax),%edx
+  102ef8:	8b 00                	mov    (%eax),%eax
+  102efa:	eb 30                	jmp    102f2c <getuint+0x4d>
+    }
+    else if (lflag) {
+  102efc:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
+  102f00:	74 16                	je     102f18 <getuint+0x39>
+        return va_arg(*ap, unsigned long);
+  102f02:	8b 45 08             	mov    0x8(%ebp),%eax
+  102f05:	8b 00                	mov    (%eax),%eax
+  102f07:	8d 48 04             	lea    0x4(%eax),%ecx
+  102f0a:	8b 55 08             	mov    0x8(%ebp),%edx
+  102f0d:	89 0a                	mov    %ecx,(%edx)
+  102f0f:	8b 00                	mov    (%eax),%eax
+  102f11:	ba 00 00 00 00       	mov    $0x0,%edx
+  102f16:	eb 14                	jmp    102f2c <getuint+0x4d>
+    }
+    else {
+        return va_arg(*ap, unsigned int);
+  102f18:	8b 45 08             	mov    0x8(%ebp),%eax
+  102f1b:	8b 00                	mov    (%eax),%eax
+  102f1d:	8d 48 04             	lea    0x4(%eax),%ecx
+  102f20:	8b 55 08             	mov    0x8(%ebp),%edx
+  102f23:	89 0a                	mov    %ecx,(%edx)
+  102f25:	8b 00                	mov    (%eax),%eax
+  102f27:	ba 00 00 00 00       	mov    $0x0,%edx
+    }
+}
+  102f2c:	5d                   	pop    %ebp
+  102f2d:	c3                   	ret    
+
+00102f2e <getint>:
+ * getint - same as getuint but signed, we can't use getuint because of sign extension
+ * @ap:            a varargs list pointer
+ * @lflag:        determines the size of the vararg that @ap points to
+ * */
+static long long
+getint(va_list *ap, int lflag) {
+  102f2e:	55                   	push   %ebp
+  102f2f:	89 e5                	mov    %esp,%ebp
+    if (lflag >= 2) {
+  102f31:	83 7d 0c 01          	cmpl   $0x1,0xc(%ebp)
+  102f35:	7e 14                	jle    102f4b <getint+0x1d>
+        return va_arg(*ap, long long);
+  102f37:	8b 45 08             	mov    0x8(%ebp),%eax
+  102f3a:	8b 00                	mov    (%eax),%eax
+  102f3c:	8d 48 08             	lea    0x8(%eax),%ecx
+  102f3f:	8b 55 08             	mov    0x8(%ebp),%edx
+  102f42:	89 0a                	mov    %ecx,(%edx)
+  102f44:	8b 50 04             	mov    0x4(%eax),%edx
+  102f47:	8b 00                	mov    (%eax),%eax
+  102f49:	eb 28                	jmp    102f73 <getint+0x45>
+    }
+    else if (lflag) {
+  102f4b:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
+  102f4f:	74 12                	je     102f63 <getint+0x35>
+        return va_arg(*ap, long);
+  102f51:	8b 45 08             	mov    0x8(%ebp),%eax
+  102f54:	8b 00                	mov    (%eax),%eax
+  102f56:	8d 48 04             	lea    0x4(%eax),%ecx
+  102f59:	8b 55 08             	mov    0x8(%ebp),%edx
+  102f5c:	89 0a                	mov    %ecx,(%edx)
+  102f5e:	8b 00                	mov    (%eax),%eax
+  102f60:	99                   	cltd   
+  102f61:	eb 10                	jmp    102f73 <getint+0x45>
+    }
+    else {
+        return va_arg(*ap, int);
+  102f63:	8b 45 08             	mov    0x8(%ebp),%eax
+  102f66:	8b 00                	mov    (%eax),%eax
+  102f68:	8d 48 04             	lea    0x4(%eax),%ecx
+  102f6b:	8b 55 08             	mov    0x8(%ebp),%edx
+  102f6e:	89 0a                	mov    %ecx,(%edx)
+  102f70:	8b 00                	mov    (%eax),%eax
+  102f72:	99                   	cltd   
+    }
+}
+  102f73:	5d                   	pop    %ebp
+  102f74:	c3                   	ret    
+
+00102f75 <printfmt>:
+ * @putch:        specified putch function, print a single character
+ * @putdat:        used by @putch function
+ * @fmt:        the format string to use
+ * */
+void
+printfmt(void (*putch)(int, void*), void *putdat, const char *fmt, ...) {
+  102f75:	55                   	push   %ebp
+  102f76:	89 e5                	mov    %esp,%ebp
+  102f78:	83 ec 28             	sub    $0x28,%esp
+    va_list ap;
+
+    va_start(ap, fmt);
+  102f7b:	8d 45 14             	lea    0x14(%ebp),%eax
+  102f7e:	89 45 f4             	mov    %eax,-0xc(%ebp)
+    vprintfmt(putch, putdat, fmt, ap);
+  102f81:	8b 45 f4             	mov    -0xc(%ebp),%eax
+  102f84:	89 44 24 0c          	mov    %eax,0xc(%esp)
+  102f88:	8b 45 10             	mov    0x10(%ebp),%eax
+  102f8b:	89 44 24 08          	mov    %eax,0x8(%esp)
+  102f8f:	8b 45 0c             	mov    0xc(%ebp),%eax
+  102f92:	89 44 24 04          	mov    %eax,0x4(%esp)
+  102f96:	8b 45 08             	mov    0x8(%ebp),%eax
+  102f99:	89 04 24             	mov    %eax,(%esp)
+  102f9c:	e8 02 00 00 00       	call   102fa3 <vprintfmt>
+    va_end(ap);
+}
+  102fa1:	c9                   	leave  
+  102fa2:	c3                   	ret    
+
+00102fa3 <vprintfmt>:
+ *
+ * Call this function if you are already dealing with a va_list.
+ * Or you probably want printfmt() instead.
+ * */
+void
+vprintfmt(void (*putch)(int, void*), void *putdat, const char *fmt, va_list ap) {
+  102fa3:	55                   	push   %ebp
+  102fa4:	89 e5                	mov    %esp,%ebp
+  102fa6:	56                   	push   %esi
+  102fa7:	53                   	push   %ebx
+  102fa8:	83 ec 40             	sub    $0x40,%esp
+    register int ch, err;
+    unsigned long long num;
+    int base, width, precision, lflag, altflag;
+
+    while (1) {
+        while ((ch = *(unsigned char *)fmt ++) != '%') {
+  102fab:	eb 18                	jmp    102fc5 <vprintfmt+0x22>
+            if (ch == '\0') {
+  102fad:	85 db                	test   %ebx,%ebx
+  102faf:	75 05                	jne    102fb6 <vprintfmt+0x13>
+                return;
+  102fb1:	e9 d1 03 00 00       	jmp    103387 <vprintfmt+0x3e4>
+            }
+            putch(ch, putdat);
+  102fb6:	8b 45 0c             	mov    0xc(%ebp),%eax
+  102fb9:	89 44 24 04          	mov    %eax,0x4(%esp)
+  102fbd:	89 1c 24             	mov    %ebx,(%esp)
+  102fc0:	8b 45 08             	mov    0x8(%ebp),%eax
+  102fc3:	ff d0                	call   *%eax
+        while ((ch = *(unsigned char *)fmt ++) != '%') {
+  102fc5:	8b 45 10             	mov    0x10(%ebp),%eax
+  102fc8:	8d 50 01             	lea    0x1(%eax),%edx
+  102fcb:	89 55 10             	mov    %edx,0x10(%ebp)
+  102fce:	0f b6 00             	movzbl (%eax),%eax
+  102fd1:	0f b6 d8             	movzbl %al,%ebx
+  102fd4:	83 fb 25             	cmp    $0x25,%ebx
+  102fd7:	75 d4                	jne    102fad <vprintfmt+0xa>
+        }
+
+        // Process a %-escape sequence
+        char padc = ' ';
+  102fd9:	c6 45 db 20          	movb   $0x20,-0x25(%ebp)
+        width = precision = -1;
+  102fdd:	c7 45 e4 ff ff ff ff 	movl   $0xffffffff,-0x1c(%ebp)
+  102fe4:	8b 45 e4             	mov    -0x1c(%ebp),%eax
+  102fe7:	89 45 e8             	mov    %eax,-0x18(%ebp)
+        lflag = altflag = 0;
+  102fea:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%ebp)
+  102ff1:	8b 45 dc             	mov    -0x24(%ebp),%eax
+  102ff4:	89 45 e0             	mov    %eax,-0x20(%ebp)
+
+    reswitch:
+        switch (ch = *(unsigned char *)fmt ++) {
+  102ff7:	8b 45 10             	mov    0x10(%ebp),%eax
+  102ffa:	8d 50 01             	lea    0x1(%eax),%edx
+  102ffd:	89 55 10             	mov    %edx,0x10(%ebp)
+  103000:	0f b6 00             	movzbl (%eax),%eax
+  103003:	0f b6 d8             	movzbl %al,%ebx
+  103006:	8d 43 dd             	lea    -0x23(%ebx),%eax
+  103009:	83 f8 55             	cmp    $0x55,%eax
+  10300c:	0f 87 44 03 00 00    	ja     103356 <vprintfmt+0x3b3>
+  103012:	8b 04 85 34 3c 10 00 	mov    0x103c34(,%eax,4),%eax
+  103019:	ff e0                	jmp    *%eax
+
+        // flag to pad on the right
+        case '-':
+            padc = '-';
+  10301b:	c6 45 db 2d          	movb   $0x2d,-0x25(%ebp)
+            goto reswitch;
+  10301f:	eb d6                	jmp    102ff7 <vprintfmt+0x54>
+
+        // flag to pad with 0's instead of spaces
+        case '0':
+            padc = '0';
+  103021:	c6 45 db 30          	movb   $0x30,-0x25(%ebp)
+            goto reswitch;
+  103025:	eb d0                	jmp    102ff7 <vprintfmt+0x54>
+
+        // width field
+        case '1' ... '9':
+            for (precision = 0; ; ++ fmt) {
+  103027:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
+                precision = precision * 10 + ch - '0';
+  10302e:	8b 55 e4             	mov    -0x1c(%ebp),%edx
+  103031:	89 d0                	mov    %edx,%eax
+  103033:	c1 e0 02             	shl    $0x2,%eax
+  103036:	01 d0                	add    %edx,%eax
+  103038:	01 c0                	add    %eax,%eax
+  10303a:	01 d8                	add    %ebx,%eax
+  10303c:	83 e8 30             	sub    $0x30,%eax
+  10303f:	89 45 e4             	mov    %eax,-0x1c(%ebp)
+                ch = *fmt;
+  103042:	8b 45 10             	mov    0x10(%ebp),%eax
+  103045:	0f b6 00             	movzbl (%eax),%eax
+  103048:	0f be d8             	movsbl %al,%ebx
+                if (ch < '0' || ch > '9') {
+  10304b:	83 fb 2f             	cmp    $0x2f,%ebx
+  10304e:	7e 0b                	jle    10305b <vprintfmt+0xb8>
+  103050:	83 fb 39             	cmp    $0x39,%ebx
+  103053:	7f 06                	jg     10305b <vprintfmt+0xb8>
+            for (precision = 0; ; ++ fmt) {
+  103055:	83 45 10 01          	addl   $0x1,0x10(%ebp)
+                    break;
+                }
+            }
+  103059:	eb d3                	jmp    10302e <vprintfmt+0x8b>
+            goto process_precision;
+  10305b:	eb 33                	jmp    103090 <vprintfmt+0xed>
+
+        case '*':
+            precision = va_arg(ap, int);
+  10305d:	8b 45 14             	mov    0x14(%ebp),%eax
+  103060:	8d 50 04             	lea    0x4(%eax),%edx
+  103063:	89 55 14             	mov    %edx,0x14(%ebp)
+  103066:	8b 00                	mov    (%eax),%eax
+  103068:	89 45 e4             	mov    %eax,-0x1c(%ebp)
+            goto process_precision;
+  10306b:	eb 23                	jmp    103090 <vprintfmt+0xed>
+
+        case '.':
+            if (width < 0)
+  10306d:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
+  103071:	79 0c                	jns    10307f <vprintfmt+0xdc>
+                width = 0;
+  103073:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
+            goto reswitch;
+  10307a:	e9 78 ff ff ff       	jmp    102ff7 <vprintfmt+0x54>
+  10307f:	e9 73 ff ff ff       	jmp    102ff7 <vprintfmt+0x54>
+
+        case '#':
+            altflag = 1;
+  103084:	c7 45 dc 01 00 00 00 	movl   $0x1,-0x24(%ebp)
+            goto reswitch;
+  10308b:	e9 67 ff ff ff       	jmp    102ff7 <vprintfmt+0x54>
+
+        process_precision:
+            if (width < 0)
+  103090:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
+  103094:	79 12                	jns    1030a8 <vprintfmt+0x105>
+                width = precision, precision = -1;
+  103096:	8b 45 e4             	mov    -0x1c(%ebp),%eax
+  103099:	89 45 e8             	mov    %eax,-0x18(%ebp)
+  10309c:	c7 45 e4 ff ff ff ff 	movl   $0xffffffff,-0x1c(%ebp)
+            goto reswitch;
+  1030a3:	e9 4f ff ff ff       	jmp    102ff7 <vprintfmt+0x54>
+  1030a8:	e9 4a ff ff ff       	jmp    102ff7 <vprintfmt+0x54>
+
+        // long flag (doubled for long long)
+        case 'l':
+            lflag ++;
+  1030ad:	83 45 e0 01          	addl   $0x1,-0x20(%ebp)
+            goto reswitch;
+  1030b1:	e9 41 ff ff ff       	jmp    102ff7 <vprintfmt+0x54>
+
+        // character
+        case 'c':
+            putch(va_arg(ap, int), putdat);
+  1030b6:	8b 45 14             	mov    0x14(%ebp),%eax
+  1030b9:	8d 50 04             	lea    0x4(%eax),%edx
+  1030bc:	89 55 14             	mov    %edx,0x14(%ebp)
+  1030bf:	8b 00                	mov    (%eax),%eax
+  1030c1:	8b 55 0c             	mov    0xc(%ebp),%edx
+  1030c4:	89 54 24 04          	mov    %edx,0x4(%esp)
+  1030c8:	89 04 24             	mov    %eax,(%esp)
+  1030cb:	8b 45 08             	mov    0x8(%ebp),%eax
+  1030ce:	ff d0                	call   *%eax
+            break;
+  1030d0:	e9 ac 02 00 00       	jmp    103381 <vprintfmt+0x3de>
+
+        // error message
+        case 'e':
+            err = va_arg(ap, int);
+  1030d5:	8b 45 14             	mov    0x14(%ebp),%eax
+  1030d8:	8d 50 04             	lea    0x4(%eax),%edx
+  1030db:	89 55 14             	mov    %edx,0x14(%ebp)
+  1030de:	8b 18                	mov    (%eax),%ebx
+            if (err < 0) {
+  1030e0:	85 db                	test   %ebx,%ebx
+  1030e2:	79 02                	jns    1030e6 <vprintfmt+0x143>
+                err = -err;
+  1030e4:	f7 db                	neg    %ebx
+            }
+            if (err > MAXERROR || (p = error_string[err]) == NULL) {
+  1030e6:	83 fb 06             	cmp    $0x6,%ebx
+  1030e9:	7f 0b                	jg     1030f6 <vprintfmt+0x153>
+  1030eb:	8b 34 9d f4 3b 10 00 	mov    0x103bf4(,%ebx,4),%esi
+  1030f2:	85 f6                	test   %esi,%esi
+  1030f4:	75 23                	jne    103119 <vprintfmt+0x176>
+                printfmt(putch, putdat, "error %d", err);
+  1030f6:	89 5c 24 0c          	mov    %ebx,0xc(%esp)
+  1030fa:	c7 44 24 08 21 3c 10 	movl   $0x103c21,0x8(%esp)
+  103101:	00 
+  103102:	8b 45 0c             	mov    0xc(%ebp),%eax
+  103105:	89 44 24 04          	mov    %eax,0x4(%esp)
+  103109:	8b 45 08             	mov    0x8(%ebp),%eax
+  10310c:	89 04 24             	mov    %eax,(%esp)
+  10310f:	e8 61 fe ff ff       	call   102f75 <printfmt>
+            }
+            else {
+                printfmt(putch, putdat, "%s", p);
+            }
+            break;
+  103114:	e9 68 02 00 00       	jmp    103381 <vprintfmt+0x3de>
+                printfmt(putch, putdat, "%s", p);
+  103119:	89 74 24 0c          	mov    %esi,0xc(%esp)
+  10311d:	c7 44 24 08 2a 3c 10 	movl   $0x103c2a,0x8(%esp)
+  103124:	00 
+  103125:	8b 45 0c             	mov    0xc(%ebp),%eax
+  103128:	89 44 24 04          	mov    %eax,0x4(%esp)
+  10312c:	8b 45 08             	mov    0x8(%ebp),%eax
+  10312f:	89 04 24             	mov    %eax,(%esp)
+  103132:	e8 3e fe ff ff       	call   102f75 <printfmt>
+            break;
+  103137:	e9 45 02 00 00       	jmp    103381 <vprintfmt+0x3de>
+
+        // string
+        case 's':
+            if ((p = va_arg(ap, char *)) == NULL) {
+  10313c:	8b 45 14             	mov    0x14(%ebp),%eax
+  10313f:	8d 50 04             	lea    0x4(%eax),%edx
+  103142:	89 55 14             	mov    %edx,0x14(%ebp)
+  103145:	8b 30                	mov    (%eax),%esi
+  103147:	85 f6                	test   %esi,%esi
+  103149:	75 05                	jne    103150 <vprintfmt+0x1ad>
+                p = "(null)";
+  10314b:	be 2d 3c 10 00       	mov    $0x103c2d,%esi
+            }
+            if (width > 0 && padc != '-') {
+  103150:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
+  103154:	7e 3e                	jle    103194 <vprintfmt+0x1f1>
+  103156:	80 7d db 2d          	cmpb   $0x2d,-0x25(%ebp)
+  10315a:	74 38                	je     103194 <vprintfmt+0x1f1>
+                for (width -= strnlen(p, precision); width > 0; width --) {
+  10315c:	8b 5d e8             	mov    -0x18(%ebp),%ebx
+  10315f:	8b 45 e4             	mov    -0x1c(%ebp),%eax
+  103162:	89 44 24 04          	mov    %eax,0x4(%esp)
+  103166:	89 34 24             	mov    %esi,(%esp)
+  103169:	e8 dc f7 ff ff       	call   10294a <strnlen>
+  10316e:	29 c3                	sub    %eax,%ebx
+  103170:	89 d8                	mov    %ebx,%eax
+  103172:	89 45 e8             	mov    %eax,-0x18(%ebp)
+  103175:	eb 17                	jmp    10318e <vprintfmt+0x1eb>
+                    putch(padc, putdat);
+  103177:	0f be 45 db          	movsbl -0x25(%ebp),%eax
+  10317b:	8b 55 0c             	mov    0xc(%ebp),%edx
+  10317e:	89 54 24 04          	mov    %edx,0x4(%esp)
+  103182:	89 04 24             	mov    %eax,(%esp)
+  103185:	8b 45 08             	mov    0x8(%ebp),%eax
+  103188:	ff d0                	call   *%eax
+                for (width -= strnlen(p, precision); width > 0; width --) {
+  10318a:	83 6d e8 01          	subl   $0x1,-0x18(%ebp)
+  10318e:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
+  103192:	7f e3                	jg     103177 <vprintfmt+0x1d4>
+                }
+            }
+            for (; (ch = *p ++) != '\0' && (precision < 0 || -- precision >= 0); width --) {
+  103194:	eb 38                	jmp    1031ce <vprintfmt+0x22b>
+                if (altflag && (ch < ' ' || ch > '~')) {
+  103196:	83 7d dc 00          	cmpl   $0x0,-0x24(%ebp)
+  10319a:	74 1f                	je     1031bb <vprintfmt+0x218>
+  10319c:	83 fb 1f             	cmp    $0x1f,%ebx
+  10319f:	7e 05                	jle    1031a6 <vprintfmt+0x203>
+  1031a1:	83 fb 7e             	cmp    $0x7e,%ebx
+  1031a4:	7e 15                	jle    1031bb <vprintfmt+0x218>
+                    putch('?', putdat);
+  1031a6:	8b 45 0c             	mov    0xc(%ebp),%eax
+  1031a9:	89 44 24 04          	mov    %eax,0x4(%esp)
+  1031ad:	c7 04 24 3f 00 00 00 	movl   $0x3f,(%esp)
+  1031b4:	8b 45 08             	mov    0x8(%ebp),%eax
+  1031b7:	ff d0                	call   *%eax
+  1031b9:	eb 0f                	jmp    1031ca <vprintfmt+0x227>
+                }
+                else {
+                    putch(ch, putdat);
+  1031bb:	8b 45 0c             	mov    0xc(%ebp),%eax
+  1031be:	89 44 24 04          	mov    %eax,0x4(%esp)
+  1031c2:	89 1c 24             	mov    %ebx,(%esp)
+  1031c5:	8b 45 08             	mov    0x8(%ebp),%eax
+  1031c8:	ff d0                	call   *%eax
+            for (; (ch = *p ++) != '\0' && (precision < 0 || -- precision >= 0); width --) {
+  1031ca:	83 6d e8 01          	subl   $0x1,-0x18(%ebp)
+  1031ce:	89 f0                	mov    %esi,%eax
+  1031d0:	8d 70 01             	lea    0x1(%eax),%esi
+  1031d3:	0f b6 00             	movzbl (%eax),%eax
+  1031d6:	0f be d8             	movsbl %al,%ebx
+  1031d9:	85 db                	test   %ebx,%ebx
+  1031db:	74 10                	je     1031ed <vprintfmt+0x24a>
+  1031dd:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
+  1031e1:	78 b3                	js     103196 <vprintfmt+0x1f3>
+  1031e3:	83 6d e4 01          	subl   $0x1,-0x1c(%ebp)
+  1031e7:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
+  1031eb:	79 a9                	jns    103196 <vprintfmt+0x1f3>
+                }
+            }
+            for (; width > 0; width --) {
+  1031ed:	eb 17                	jmp    103206 <vprintfmt+0x263>
+                putch(' ', putdat);
+  1031ef:	8b 45 0c             	mov    0xc(%ebp),%eax
+  1031f2:	89 44 24 04          	mov    %eax,0x4(%esp)
+  1031f6:	c7 04 24 20 00 00 00 	movl   $0x20,(%esp)
+  1031fd:	8b 45 08             	mov    0x8(%ebp),%eax
+  103200:	ff d0                	call   *%eax
+            for (; width > 0; width --) {
+  103202:	83 6d e8 01          	subl   $0x1,-0x18(%ebp)
+  103206:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
+  10320a:	7f e3                	jg     1031ef <vprintfmt+0x24c>
+            }
+            break;
+  10320c:	e9 70 01 00 00       	jmp    103381 <vprintfmt+0x3de>
+
+        // (signed) decimal
+        case 'd':
+            num = getint(&ap, lflag);
+  103211:	8b 45 e0             	mov    -0x20(%ebp),%eax
+  103214:	89 44 24 04          	mov    %eax,0x4(%esp)
+  103218:	8d 45 14             	lea    0x14(%ebp),%eax
+  10321b:	89 04 24             	mov    %eax,(%esp)
+  10321e:	e8 0b fd ff ff       	call   102f2e <getint>
+  103223:	89 45 f0             	mov    %eax,-0x10(%ebp)
+  103226:	89 55 f4             	mov    %edx,-0xc(%ebp)
+            if ((long long)num < 0) {
+  103229:	8b 45 f0             	mov    -0x10(%ebp),%eax
+  10322c:	8b 55 f4             	mov    -0xc(%ebp),%edx
+  10322f:	85 d2                	test   %edx,%edx
+  103231:	79 26                	jns    103259 <vprintfmt+0x2b6>
+                putch('-', putdat);
+  103233:	8b 45 0c             	mov    0xc(%ebp),%eax
+  103236:	89 44 24 04          	mov    %eax,0x4(%esp)
+  10323a:	c7 04 24 2d 00 00 00 	movl   $0x2d,(%esp)
+  103241:	8b 45 08             	mov    0x8(%ebp),%eax
+  103244:	ff d0                	call   *%eax
+                num = -(long long)num;
+  103246:	8b 45 f0             	mov    -0x10(%ebp),%eax
+  103249:	8b 55 f4             	mov    -0xc(%ebp),%edx
+  10324c:	f7 d8                	neg    %eax
+  10324e:	83 d2 00             	adc    $0x0,%edx
+  103251:	f7 da                	neg    %edx
+  103253:	89 45 f0             	mov    %eax,-0x10(%ebp)
+  103256:	89 55 f4             	mov    %edx,-0xc(%ebp)
+            }
+            base = 10;
+  103259:	c7 45 ec 0a 00 00 00 	movl   $0xa,-0x14(%ebp)
+            goto number;
+  103260:	e9 a8 00 00 00       	jmp    10330d <vprintfmt+0x36a>
+
+        // unsigned decimal
+        case 'u':
+            num = getuint(&ap, lflag);
+  103265:	8b 45 e0             	mov    -0x20(%ebp),%eax
+  103268:	89 44 24 04          	mov    %eax,0x4(%esp)
+  10326c:	8d 45 14             	lea    0x14(%ebp),%eax
+  10326f:	89 04 24             	mov    %eax,(%esp)
+  103272:	e8 68 fc ff ff       	call   102edf <getuint>
+  103277:	89 45 f0             	mov    %eax,-0x10(%ebp)
+  10327a:	89 55 f4             	mov    %edx,-0xc(%ebp)
+            base = 10;
+  10327d:	c7 45 ec 0a 00 00 00 	movl   $0xa,-0x14(%ebp)
+            goto number;
+  103284:	e9 84 00 00 00       	jmp    10330d <vprintfmt+0x36a>
+
+        // (unsigned) octal
+        case 'o':
+            num = getuint(&ap, lflag);
+  103289:	8b 45 e0             	mov    -0x20(%ebp),%eax
+  10328c:	89 44 24 04          	mov    %eax,0x4(%esp)
+  103290:	8d 45 14             	lea    0x14(%ebp),%eax
+  103293:	89 04 24             	mov    %eax,(%esp)
+  103296:	e8 44 fc ff ff       	call   102edf <getuint>
+  10329b:	89 45 f0             	mov    %eax,-0x10(%ebp)
+  10329e:	89 55 f4             	mov    %edx,-0xc(%ebp)
+            base = 8;
+  1032a1:	c7 45 ec 08 00 00 00 	movl   $0x8,-0x14(%ebp)
+            goto number;
+  1032a8:	eb 63                	jmp    10330d <vprintfmt+0x36a>
+
+        // pointer
+        case 'p':
+            putch('0', putdat);
+  1032aa:	8b 45 0c             	mov    0xc(%ebp),%eax
+  1032ad:	89 44 24 04          	mov    %eax,0x4(%esp)
+  1032b1:	c7 04 24 30 00 00 00 	movl   $0x30,(%esp)
+  1032b8:	8b 45 08             	mov    0x8(%ebp),%eax
+  1032bb:	ff d0                	call   *%eax
+            putch('x', putdat);
+  1032bd:	8b 45 0c             	mov    0xc(%ebp),%eax
+  1032c0:	89 44 24 04          	mov    %eax,0x4(%esp)
+  1032c4:	c7 04 24 78 00 00 00 	movl   $0x78,(%esp)
+  1032cb:	8b 45 08             	mov    0x8(%ebp),%eax
+  1032ce:	ff d0                	call   *%eax
+            num = (unsigned long long)(uintptr_t)va_arg(ap, void *);
+  1032d0:	8b 45 14             	mov    0x14(%ebp),%eax
+  1032d3:	8d 50 04             	lea    0x4(%eax),%edx
+  1032d6:	89 55 14             	mov    %edx,0x14(%ebp)
+  1032d9:	8b 00                	mov    (%eax),%eax
+  1032db:	89 45 f0             	mov    %eax,-0x10(%ebp)
+  1032de:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
+            base = 16;
+  1032e5:	c7 45 ec 10 00 00 00 	movl   $0x10,-0x14(%ebp)
+            goto number;
+  1032ec:	eb 1f                	jmp    10330d <vprintfmt+0x36a>
+
+        // (unsigned) hexadecimal
+        case 'x':
+            num = getuint(&ap, lflag);
+  1032ee:	8b 45 e0             	mov    -0x20(%ebp),%eax
+  1032f1:	89 44 24 04          	mov    %eax,0x4(%esp)
+  1032f5:	8d 45 14             	lea    0x14(%ebp),%eax
+  1032f8:	89 04 24             	mov    %eax,(%esp)
+  1032fb:	e8 df fb ff ff       	call   102edf <getuint>
+  103300:	89 45 f0             	mov    %eax,-0x10(%ebp)
+  103303:	89 55 f4             	mov    %edx,-0xc(%ebp)
+            base = 16;
+  103306:	c7 45 ec 10 00 00 00 	movl   $0x10,-0x14(%ebp)
+        number:
+            printnum(putch, putdat, num, base, width, padc);
+  10330d:	0f be 55 db          	movsbl -0x25(%ebp),%edx
+  103311:	8b 45 ec             	mov    -0x14(%ebp),%eax
+  103314:	89 54 24 18          	mov    %edx,0x18(%esp)
+  103318:	8b 55 e8             	mov    -0x18(%ebp),%edx
+  10331b:	89 54 24 14          	mov    %edx,0x14(%esp)
+  10331f:	89 44 24 10          	mov    %eax,0x10(%esp)
+  103323:	8b 45 f0             	mov    -0x10(%ebp),%eax
+  103326:	8b 55 f4             	mov    -0xc(%ebp),%edx
+  103329:	89 44 24 08          	mov    %eax,0x8(%esp)
+  10332d:	89 54 24 0c          	mov    %edx,0xc(%esp)
+  103331:	8b 45 0c             	mov    0xc(%ebp),%eax
+  103334:	89 44 24 04          	mov    %eax,0x4(%esp)
+  103338:	8b 45 08             	mov    0x8(%ebp),%eax
+  10333b:	89 04 24             	mov    %eax,(%esp)
+  10333e:	e8 97 fa ff ff       	call   102dda <printnum>
+            break;
+  103343:	eb 3c                	jmp    103381 <vprintfmt+0x3de>
+
+        // escaped '%' character
+        case '%':
+            putch(ch, putdat);
+  103345:	8b 45 0c             	mov    0xc(%ebp),%eax
+  103348:	89 44 24 04          	mov    %eax,0x4(%esp)
+  10334c:	89 1c 24             	mov    %ebx,(%esp)
+  10334f:	8b 45 08             	mov    0x8(%ebp),%eax
+  103352:	ff d0                	call   *%eax
+            break;
+  103354:	eb 2b                	jmp    103381 <vprintfmt+0x3de>
+
+        // unrecognized escape sequence - just print it literally
+        default:
+            putch('%', putdat);
+  103356:	8b 45 0c             	mov    0xc(%ebp),%eax
+  103359:	89 44 24 04          	mov    %eax,0x4(%esp)
+  10335d:	c7 04 24 25 00 00 00 	movl   $0x25,(%esp)
+  103364:	8b 45 08             	mov    0x8(%ebp),%eax
+  103367:	ff d0                	call   *%eax
+            for (fmt --; fmt[-1] != '%'; fmt --)
+  103369:	83 6d 10 01          	subl   $0x1,0x10(%ebp)
+  10336d:	eb 04                	jmp    103373 <vprintfmt+0x3d0>
+  10336f:	83 6d 10 01          	subl   $0x1,0x10(%ebp)
+  103373:	8b 45 10             	mov    0x10(%ebp),%eax
+  103376:	83 e8 01             	sub    $0x1,%eax
+  103379:	0f b6 00             	movzbl (%eax),%eax
+  10337c:	3c 25                	cmp    $0x25,%al
+  10337e:	75 ef                	jne    10336f <vprintfmt+0x3cc>
+                /* do nothing */;
+            break;
+  103380:	90                   	nop
+        }
+    }
+  103381:	90                   	nop
+        while ((ch = *(unsigned char *)fmt ++) != '%') {
+  103382:	e9 3e fc ff ff       	jmp    102fc5 <vprintfmt+0x22>
+}
+  103387:	83 c4 40             	add    $0x40,%esp
+  10338a:	5b                   	pop    %ebx
+  10338b:	5e                   	pop    %esi
+  10338c:	5d                   	pop    %ebp
+  10338d:	c3                   	ret    
+
+0010338e <sprintputch>:
+ * sprintputch - 'print' a single character in a buffer
+ * @ch:            the character will be printed
+ * @b:            the buffer to place the character @ch
+ * */
+static void
+sprintputch(int ch, struct sprintbuf *b) {
+  10338e:	55                   	push   %ebp
+  10338f:	89 e5                	mov    %esp,%ebp
+    b->cnt ++;
+  103391:	8b 45 0c             	mov    0xc(%ebp),%eax
+  103394:	8b 40 08             	mov    0x8(%eax),%eax
+  103397:	8d 50 01             	lea    0x1(%eax),%edx
+  10339a:	8b 45 0c             	mov    0xc(%ebp),%eax
+  10339d:	89 50 08             	mov    %edx,0x8(%eax)
+    if (b->buf < b->ebuf) {
+  1033a0:	8b 45 0c             	mov    0xc(%ebp),%eax
+  1033a3:	8b 10                	mov    (%eax),%edx
+  1033a5:	8b 45 0c             	mov    0xc(%ebp),%eax
+  1033a8:	8b 40 04             	mov    0x4(%eax),%eax
+  1033ab:	39 c2                	cmp    %eax,%edx
+  1033ad:	73 12                	jae    1033c1 <sprintputch+0x33>
+        *b->buf ++ = ch;
+  1033af:	8b 45 0c             	mov    0xc(%ebp),%eax
+  1033b2:	8b 00                	mov    (%eax),%eax
+  1033b4:	8d 48 01             	lea    0x1(%eax),%ecx
+  1033b7:	8b 55 0c             	mov    0xc(%ebp),%edx
+  1033ba:	89 0a                	mov    %ecx,(%edx)
+  1033bc:	8b 55 08             	mov    0x8(%ebp),%edx
+  1033bf:	88 10                	mov    %dl,(%eax)
+    }
+}
+  1033c1:	5d                   	pop    %ebp
+  1033c2:	c3                   	ret    
+
+001033c3 <snprintf>:
+ * @str:        the buffer to place the result into
+ * @size:        the size of buffer, including the trailing null space
+ * @fmt:        the format string to use
+ * */
+int
+snprintf(char *str, size_t size, const char *fmt, ...) {
+  1033c3:	55                   	push   %ebp
+  1033c4:	89 e5                	mov    %esp,%ebp
+  1033c6:	83 ec 28             	sub    $0x28,%esp
+    va_list ap;
+    int cnt;
+    va_start(ap, fmt);
+  1033c9:	8d 45 14             	lea    0x14(%ebp),%eax
+  1033cc:	89 45 f0             	mov    %eax,-0x10(%ebp)
+    cnt = vsnprintf(str, size, fmt, ap);
+  1033cf:	8b 45 f0             	mov    -0x10(%ebp),%eax
+  1033d2:	89 44 24 0c          	mov    %eax,0xc(%esp)
+  1033d6:	8b 45 10             	mov    0x10(%ebp),%eax
+  1033d9:	89 44 24 08          	mov    %eax,0x8(%esp)
+  1033dd:	8b 45 0c             	mov    0xc(%ebp),%eax
+  1033e0:	89 44 24 04          	mov    %eax,0x4(%esp)
+  1033e4:	8b 45 08             	mov    0x8(%ebp),%eax
+  1033e7:	89 04 24             	mov    %eax,(%esp)
+  1033ea:	e8 08 00 00 00       	call   1033f7 <vsnprintf>
+  1033ef:	89 45 f4             	mov    %eax,-0xc(%ebp)
+    va_end(ap);
+    return cnt;
+  1033f2:	8b 45 f4             	mov    -0xc(%ebp),%eax
+}
+  1033f5:	c9                   	leave  
+  1033f6:	c3                   	ret    
+
+001033f7 <vsnprintf>:
+ *
+ * Call this function if you are already dealing with a va_list.
+ * Or you probably want snprintf() instead.
+ * */
+int
+vsnprintf(char *str, size_t size, const char *fmt, va_list ap) {
+  1033f7:	55                   	push   %ebp
+  1033f8:	89 e5                	mov    %esp,%ebp
+  1033fa:	83 ec 28             	sub    $0x28,%esp
+    struct sprintbuf b = {str, str + size - 1, 0};
+  1033fd:	8b 45 08             	mov    0x8(%ebp),%eax
+  103400:	89 45 ec             	mov    %eax,-0x14(%ebp)
+  103403:	8b 45 0c             	mov    0xc(%ebp),%eax
+  103406:	8d 50 ff             	lea    -0x1(%eax),%edx
+  103409:	8b 45 08             	mov    0x8(%ebp),%eax
+  10340c:	01 d0                	add    %edx,%eax
+  10340e:	89 45 f0             	mov    %eax,-0x10(%ebp)
+  103411:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
+    if (str == NULL || b.buf > b.ebuf) {
+  103418:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
+  10341c:	74 0a                	je     103428 <vsnprintf+0x31>
+  10341e:	8b 55 ec             	mov    -0x14(%ebp),%edx
+  103421:	8b 45 f0             	mov    -0x10(%ebp),%eax
+  103424:	39 c2                	cmp    %eax,%edx
+  103426:	76 07                	jbe    10342f <vsnprintf+0x38>
+        return -E_INVAL;
+  103428:	b8 fd ff ff ff       	mov    $0xfffffffd,%eax
+  10342d:	eb 2a                	jmp    103459 <vsnprintf+0x62>
+    }
+    // print the string to the buffer
+    vprintfmt((void*)sprintputch, &b, fmt, ap);
+  10342f:	8b 45 14             	mov    0x14(%ebp),%eax
+  103432:	89 44 24 0c          	mov    %eax,0xc(%esp)
+  103436:	8b 45 10             	mov    0x10(%ebp),%eax
+  103439:	89 44 24 08          	mov    %eax,0x8(%esp)
+  10343d:	8d 45 ec             	lea    -0x14(%ebp),%eax
+  103440:	89 44 24 04          	mov    %eax,0x4(%esp)
+  103444:	c7 04 24 8e 33 10 00 	movl   $0x10338e,(%esp)
+  10344b:	e8 53 fb ff ff       	call   102fa3 <vprintfmt>
+    // null terminate the buffer
+    *b.buf = '\0';
+  103450:	8b 45 ec             	mov    -0x14(%ebp),%eax
+  103453:	c6 00 00             	movb   $0x0,(%eax)
+    return b.cnt;
+  103456:	8b 45 f4             	mov    -0xc(%ebp),%eax
+}
+  103459:	c9                   	leave  
+  10345a:	c3                   	ret    
diff -urN lab2/obj/kernel.sym lab1/obj/kernel.sym
--- lab2/obj/kernel.sym	1970-01-01 08:00:00.000000000 +0800
+++ lab1/obj/kernel.sym	2019-03-09 17:54:32.451021390 +0800
@@ -0,0 +1,402 @@
+00100000 .text
+00103460 .rodata
+00103d8c .stab
+0010b509 .stabstr
+0010e000 .data
+0010ea20 .bss
+00000000 .comment
+00000000 init.c
+00100100 lab1_print_cur_status
+0010ea20 round.1132
+001001c6 lab1_switch_to_user
+001001cb lab1_switch_to_kernel
+001001d0 lab1_switch_test
+00000000 stdio.c
+00100209 cputch
+00000000 readline.c
+0010ea40 buf
+00000000 panic.c
+0010ee40 is_panic
+00000000 kdebug.c
+00100480 stab_binsearch
+00100a4c read_eip
+00000000 kmonitor.c
+0010e000 commands
+00100b34 parse
+00100bee runcmd
+00000000 clock.c
+00000000 console.c
+00100de4 delay
+0010ee60 crt_buf
+0010ee64 crt_pos
+0010ee66 addr_6845
+00100e2c cga_init
+0010ee68 serial_exists
+00100f12 serial_init
+00100ff5 lpt_putc_sub
+0010106e lpt_putc
+001010ad cga_putc
+00101281 serial_putc_sub
+001012da serial_putc
+0010ee80 cons
+00101319 cons_intr
+00101364 serial_proc_data
+0010e040 shiftcode
+0010e140 togglecode
+0010e240 normalmap
+0010e340 shiftmap
+0010e440 ctlmap
+0010e540 charcode
+001013d8 kbd_proc_data
+0010f088 shift.1249
+00101561 kbd_intr
+00101575 kbd_init
+00000000 picirq.c
+0010e550 irq_mask
+0010f08c did_init
+0010163f pic_setmask
+00000000 intr.c
+00000000 trap.c
+0010180c print_ticks
+0010f0c0 idt
+0010e560 idt_pd
+00101949 trapname
+00103b40 excnames.1230
+0010e580 IA32flags
+00101c0c trap_dispatch
+00000000 pmm.c
+0010f8c0 ts
+0010e9e0 gdt
+0010ea10 gdt_pd
+001027e3 lgdt
+00102818 gdt_init
+00000000 string.c
+00000000 printfmt.c
+00103bf4 error_string
+00102dda printnum
+00102edf getuint
+00102f2e getint
+0010338e sprintputch
+00102719 vector242
+00102170 vector119
+00100913 print_kerninfo
+00102050 vector87
+00102047 vector86
+00102785 vector251
+0010297a strcpy
+00102074 vector91
+00101e6a vector33
+00102359 vector162
+001025bd vector213
+0010210d vector108
+00101ec4 vector43
+00100d6f mon_backtrace
+0010237d vector165
+0010246d vector185
+0010214c vector115
+0010218b vector122
+00102311 vector156
+0010273d vector245
+0010249d vector189
+00101d8e vector7
+00101f66 vector61
+00101e19 vector24
+00102128 vector111
+00102521 vector200
+00101f9c vector67
+00102239 vector138
+00101fdb vector74
+00102c90 memmove
+00101f42 vector57
+001033c3 snprintf
+00101990 print_trapframe
+001025c9 vector214
+00102fa3 vprintfmt
+001020bc vector99
+001027c1 __alltraps
+001015e3 cons_getc
+0010225d vector141
+00100476 is_kernel_panic
+001023d1 vector172
+00100a5d print_stackframe
+0010270d vector241
+0010279d vector253
+00101d6a vector3
+00101d61 vector2
+00102665 vector227
+00102599 vector210
+00102641 vector224
+00101eb2 vector41
+0010025c cprintf
+00101dfe vector21
+0010240d vector177
+00102167 vector118
+00101fb7 vector70
+00101fae vector69
+001026dd vector237
+00101f81 vector64
+00101e34 vector27
+001021f1 vector132
+00102479 vector186
+001025ed vector217
+00102d33 memcpy
+00101d58 vector1
+00102419 vector178
+00101e97 vector38
+001026e9 vector238
+001002fd readline
+001021fd vector133
+00101fd2 vector73
+00102281 vector144
+00100000 kern_init
+001027a9 vector254
+001020ce vector101
+001025a5 vector211
+001023e9 vector174
+00102725 vector243
+001021c1 vector128
+0010201a vector81
+00101dbc vector13
+001033f7 vsnprintf
+00101f0c vector51
+00101dd3 vector16
+0010ea16 edata
+0010158e cons_init
+00102701 vector240
+00101f27 vector54
+00101dec vector19
+0010b508 __STAB_END__
+0010207d vector92
+00102731 vector244
+00102251 vector140
+00101ed6 vector45
+00102008 vector79
+0010267d vector229
+00102329 vector158
+00101697 pic_enable
+00101ea0 vector39
+001023a1 vector168
+00101e7c vector35
+0010213a vector113
+0010b509 __STABSTR_BEGIN__
+001021a6 vector125
+001003b3 __panic
+001025e1 vector216
+00101f78 vector63
+00101e2b vector26
+001013bb serial_intr
+001024cd vector193
+001024f1 vector196
+001000c1 grade_backtrace0
+0010258d vector209
+00101d73 vector4
+001023b9 vector170
+00102221 vector136
+00101da7 vector10
+00102569 vector206
+0010f940 stack0
+001027b5 vector255
+0010243d vector181
+00101f54 vector59
+001000db grade_backtrace
+0010203e vector85
+00102035 vector84
+00102455 vector183
+00102335 vector159
+001025b1 vector212
+00101ee8 vector47
+00102af3 strtol
+00102671 vector228
+00101ebb vector42
+00102143 vector114
+0010294a strnlen
+001023f5 vector175
+00102275 vector143
+001021d9 vector130
+00102749 vector246
+00101d9e vector9
+00102269 vector142
+001020c5 vector100
+0010252d vector201
+00101828 idt_init
+001009a9 print_debuginfo
+00101f5d vector60
+00101e10 vector23
+001026d1 vector236
+00102695 vector231
+00101f93 vector66
+00101e46 vector29
+00102215 vector135
+00100ca0 kmonitor
+00101ff6 vector77
+00102431 vector180
+00100d81 clock_init
+00102581 vector208
+001020b3 vector98
+001020aa vector97
+00102401 vector176
+001024d9 vector194
+00101e61 vector32
+0010fd40 end
+00102515 vector199
+001021e5 vector131
+00102791 vector252
+00101d4f vector0
+00102ac5 strfind
+001015ba cons_putc
+0010345b etext
+0010228d vector145
+00102104 vector107
+00101ea9 vector40
+00101800 intr_enable
+001020d7 vector102
+00101f39 vector56
+00101fa5 vector68
+00101d85 vector6
+001021cd vector129
+001024fd vector197
+001022e1 vector152
+0010e5e0 __vectors
+00102689 vector230
+00102a3c strncmp
+00101e8e vector37
+0010255d vector205
+0010234d vector161
+001029b9 strncpy
+00101fc0 vector71
+00102341 vector160
+001025d5 vector215
+0010231d vector157
+00101806 intr_disable
+00101b55 print_regs
+00102131 vector112
+00100070 grade_backtrace2
+00102449 vector182
+00101db5 vector12
+00102d82 memcmp
+00102116 vector109
+00101df5 vector20
+00101f1e vector53
+00101de3 vector18
+00102098 vector95
+00102659 vector226
+00101efa vector49
+00101ecd vector44
+00101fff vector78
+001023dd vector173
+0010f0a0 cur_tick
+0010215e vector117
+0010197a trap_in_kernel
+00102023 vector82
+00102629 vector222
+00101d97 vector8
+001022bd vector149
+00100282 cputchar
+00102c51 memset
+001026a1 vector232
+001020fb vector106
+00102611 vector220
+0010206b vector90
+00102365 vector163
+001026b9 vector234
+00101f6f vector62
+00101e22 vector25
+00102509 vector198
+00102179 vector120
+001002e4 getchar
+00101f03 vector50
+00101dca vector15
+00102f75 printfmt
+001022d5 vector151
+0010202c vector83
+00102062 vector89
+00102059 vector88
+00101d3c trap
+00102425 vector179
+00101e73 vector34
+0010d50e __STABSTR_END__
+00101edf vector46
+001029f3 strcmp
+00102209 vector134
+00102635 vector223
+001025f9 vector218
+001005d6 debuginfo_eip
+001016c5 pic_init
+0010264d vector225
+00102485 vector187
+00102918 pmm_init
+00101e4f vector30
+001021b8 vector127
+0010f928 ticks
+001024c1 vector192
+00102389 vector166
+00101fed vector76
+00101fe4 vector75
+001024e5 vector195
+001022c9 vector150
+00101f4b vector58
+00102761 vector248
+00102194 vector123
+001020a1 vector96
+00101e58 vector31
+00102545 vector203
+00102245 vector139
+001022ed vector153
+00102371 vector164
+00102182 vector121
+00101d7c vector5
+00102395 vector167
+00102305 vector155
+0010276d vector249
+00102779 vector250
+0010219d vector124
+0010211f vector110
+00102551 vector204
+001027d8 __trapret
+00100229 vcprintf
+0010222d vector137
+00100430 __warn
+00102755 vector247
+00101e07 vector22
+00102539 vector202
+00101fc9 vector72
+00101f30 vector55
+00100295 cputs
+001021af vector126
+00101f8a vector65
+00101e3d vector28
+001023ad vector169
+001026ad vector233
+001022a5 vector147
+001020e9 vector104
+00102155 vector116
+00103d8c __STAB_BEGIN__
+00101f15 vector52
+00101ddc vector17
+00102461 vector184
+00102922 strlen
+00102575 vector207
+001024a9 vector190
+001026f5 vector239
+0010208f vector94
+00102086 vector93
+00102491 vector188
+00102a92 strchr
+00101ef1 vector48
+00100094 grade_backtrace1
+00102605 vector219
+001022b1 vector148
+0010261d vector221
+00102011 vector80
+001023c5 vector171
+001022f9 vector154
+00101e85 vector36
+001026c5 vector235
+001020f2 vector105
+00100d5d mon_kerninfo
+00102299 vector146
+001024b5 vector191
+001020e0 vector103
+00100d00 mon_help
+00101dae vector11
+00101dc3 vector14
diff -urN lab2/obj/libs/printfmt.d lab1/obj/libs/printfmt.d
--- lab2/obj/libs/printfmt.d	1970-01-01 08:00:00.000000000 +0800
+++ lab1/obj/libs/printfmt.d	2019-03-09 17:45:38.729423001 +0800
@@ -0,0 +1,2 @@
+obj/libs/printfmt.o obj/libs/printfmt.d: libs/printfmt.c libs/defs.h \
+ libs/x86.h libs/error.h libs/stdio.h libs/stdarg.h libs/string.h
Binary files lab2/obj/libs/printfmt.o and lab1/obj/libs/printfmt.o differ
diff -urN lab2/obj/libs/string.d lab1/obj/libs/string.d
--- lab2/obj/libs/string.d	1970-01-01 08:00:00.000000000 +0800
+++ lab1/obj/libs/string.d	2019-03-09 17:45:38.737423026 +0800
@@ -0,0 +1,2 @@
+obj/libs/string.o obj/libs/string.d: libs/string.c libs/string.h \
+ libs/defs.h libs/x86.h
Binary files lab2/obj/libs/string.o and lab1/obj/libs/string.o differ
diff -urN lab2/obj/sign/tools/sign.d lab1/obj/sign/tools/sign.d
--- lab2/obj/sign/tools/sign.d	1970-01-01 08:00:00.000000000 +0800
+++ lab1/obj/sign/tools/sign.d	2019-03-09 17:45:38.633422712 +0800
@@ -0,0 +1 @@
+obj/sign/tools/sign.o obj/sign/tools/sign.d: tools/sign.c
Binary files lab2/obj/sign/tools/sign.o and lab1/obj/sign/tools/sign.o differ
diff -urN lab2/report.md lab1/report.md
--- lab2/report.md	1970-01-01 08:00:00.000000000 +0800
+++ lab1/report.md	2019-03-19 20:31:39.928389845 +0800
@@ -0,0 +1,548 @@
+# Lab1
+
+石景宜 2016011395
+
+## 知识点
+
+与本实验有关课上知识点：
+
+- 系统启动
+- x86的中断和异常机制
+- 用中断实现系统调用
+- 中断描述符表
+
+本实验中其他重要知识点：
+
+- 硬盘驱动程序
+- ELF文件格式
+- `objdump`,`gdb`的使用
+
+## 练习一
+
+> 1.1操作系统镜像文件 ucore.img 是如何一步一步生成的?(需要比较详细地解释 Makefile中每一条相关命令和命令参数的含义,以及说明命令导致的结果)
+
+```makefile
+# create ucore.img
+UCOREIMG	:= $(call totarget,ucore.img)
+
+$(UCOREIMG): $(kernel) $(bootblock)
+	$(V)dd if=/dev/zero of=$@ count=10000
+	$(V)dd if=$(bootblock) of=$@ conv=notrunc
+	$(V)dd if=$(kernel) of=$@ seek=1 conv=notrunc
+
+$(call create_target,ucore.img)
+```
+
+表明`ucore.img`的生成需要`bootblock`,`kernel`两个文件,生成的命令语句如下：
+
+- `dd if=/dev/zero of=bin/ucore.img count=10000`：其中`/dev/zero`为linux系统中提供无限个0的文件，此句代表用10000个初始为0的,大小为默认大小512字节的块填充`ucore.img`
+- `dd if=bin/bootblock of=bin/ucore.img conv=notrunc`：将`bootblock`块拷贝到`ucore.img`的第一个块
+- `dd if=bin/kernel of=bin/ucore.img seek=1 conv=notrunc`：将`kernel`块拷贝到`ucore.img`中第一个块之后
+
+这三条命令导致最终生成的`ucore.img`为`bootblock`和`kernel`以及0组成
+
+##### step 1. 生成`kernel`
+
+生成`kernel`的`makefile`语句
+
+````makefile
+$(kernel): tools/kernel.ld
+
+$(kernel): $(KOBJS)
+	@echo + ld $@
+	$(V)$(LD) $(LDFLAGS) -T tools/kernel.ld -o $@ $(KOBJS)
+	@$(OBJDUMP) -S $@ > $(call asmfile,kernel)
+	@$(OBJDUMP) -t $@ | $(SED) '1,/SYMBOL TABLE/d; s/ .* / /; /^$$/d' > $(call symfile,kernel)
+
+$(call create_target,kernel)
+````
+
+实际命令：
+
+````shell
++ ld bin/kernel
+ld -m    elf_i386 -nostdlib -T tools/kernel.ld -o bin/kernel  obj/kern/init/init.o obj/kern/libs/stdio.o obj/kern/libs/readline.o obj/kern/debug/panic.o obj/kern/debug/kdebug.o obj/kern/debug/kmonitor.o obj/kern/driver/clock.o obj/kern/driver/console.o obj/kern/driver/picirq.o obj/kern/driver/intr.o obj/kern/trap/trap.o obj/kern/trap/vectors.o obj/kern/trap/trapentry.o obj/kern/mm/pmm.o  obj/libs/string.o obj/libs/printfmt.o
+
+````
+
+（`malefile`中后面几句对应命令没有找到）
+
+表明`kernel`由一系列.o文件链接生成，它们均是操作系统的一些基础功能，且由如下`makefile`语句生成
+
+````makefile
+$(call add_files_cc,$(call listf_cc,$(KSRCDIR)),kernel,$(KCFLAGS))
+````
+
+表明这一系列.o文件均是由对应代码文件编译生成。
+
+##### step 2. 生成`bootblock`
+
+生成`bootblock`的makefile语句：
+
+```makefile
+$(bootblock): $(call toobj,$(bootfiles)) | $(call totarget,sign)
+	@echo + ld $@
+	$(V)$(LD) $(LDFLAGS) -N -e start -Ttext 0x7C00 $^ -o $(call toobj,bootblock)
+	@$(OBJDUMP) -S $(call objfile,bootblock) > $(call asmfile,bootblock)
+	@$(OBJCOPY) -S -O binary $(call objfile,bootblock) $(call outfile,bootblock)
+	@$(call totarget,sign) $(call outfile,bootblock) $(bootblock)
+
+$(call create_target,bootblock)
+```
+
+表明`bootblock`的生成依赖于`sign`,`$(bootfiles)`,其中`$(bootfiles)`为`bootmain.o`和`bootasm.o`。
+
+2.1 `$(bootfiles)`的生成
+
+`makefile`语句如下：
+
+````makefile
+bootfiles = $(call listf_cc,boot)
+$(foreach f,$(bootfiles),$(call cc_compile,$(f),$(CC),$(CFLAGS) -Os -nostdinc))
+````
+
+实际编译命令如下：
+
+````shell
++ cc boot/bootasm.S
+gcc -Iboot/ -fno-builtin -Wall -ggdb -m32 -gstabs -nostdinc  -fno-stack-protector -Ilibs/ -Os -nostdinc -c boot/bootasm.S -o obj/boot/bootasm.o
++ cc boot/bootmain.c
+gcc -Iboot/ -fno-builtin -Wall -ggdb -m32 -gstabs -nostdinc  -fno-stack-protector -Ilibs/ -Os -nostdinc -c boot/bootmain.c -o obj/boot/bootmain.o
+````
+
+以上命令表明：`bootasm.o`由`bootasm.S`编译得到，`bootmain.o`由`bootmain.c`编译得到
+
+2.2 `sign`的生成
+
+`makefile`中语句如下：
+
+````makefile
+$(call add_files_host,tools/sign.c,sign,sign)
+$(call create_target_host,sign,sign)
+````
+
+实际命令：
+
+````shell
+gcc -Itools/ -g -Wall -O2 -c tools/sign.c -o obj/sign/tools/sign.o
+gcc -g -Wall -O2 obj/sign/tools/sign.o -o bin/sign
+````
+
+首先编译`sign.c`得到`sign.o`，然后由`sign.o`链接生成`sign`。
+
+2.3 `bootblock`最终生成
+
+生成`bootblock`的命令：
+
+````shell
++ ld bin/bootblock
+ld -m    elf_i386 -nostdlib -N -e start -Ttext 0x7C00 obj/boot/bootasm.o obj/boot/bootmain.o -o obj/bootblock.o
+'obj/bootblock.out' size: 488 bytes
+build 512 bytes boot sector: 'bin/bootblock' success!
+````
+
+表明`bootblock.o`由`bootasm.o`和`bootmain.o`链接得到。
+
+没有发现makefile中以下语句对应命令
+
+````makefile
+	@$(OBJDUMP) -S $(call objfile,bootblock) > $(call asmfile,bootblock)
+	@$(OBJCOPY) -S -O binary $(call objfile,bootblock) $(call outfile,bootblock)
+	@$(call totarget,sign) $(call outfile,bootblock) $(bootblock)
+````
+
+查阅答案发现应还有命令（我的编译器并没有输出这几句）：
+
+````shell
+objcopy -S -O binary obj/bootblock.o obj/bootblock.out
+bin/sign obj/bootblock.out bin/bootblock
+````
+
+可知，首先将`bootblock.o`的二进制代码拷贝到`bootblock.out`，然后用`sign`工具处理`bootblock.out`得到最后的`bootblock`。
+
+##### step 3. `ucore.img`最终生成
+
+- `dd if=/dev/zero of=bin/ucore.img count=10000`：其中`/dev/zero`为linux系统中提供无限个0的文件，此句代表用10000个初始为0的,大小为默认大小512字节的块填充`ucore.img`
+- `dd if=bin/bootblock of=bin/ucore.img conv=notrunc`：将`bootblock`块拷贝到`ucore.img`的第一个块
+- `dd if=bin/kernel of=bin/ucore.img seek=1 conv=notrunc`：将`kernel`块拷贝到`ucore.img`中第一个块之后
+
+这三条命令导致最终生成的`ucore.img`为`bootblock`和`kernel`以及0组成
+
+
+
+> 1.2 一个被系统认为是符合规范的硬盘主引导扇区的特征是什么？
+
+因为sign将`bootblock`处理为了符合规范的硬盘主引导扇区，查看`sign.c`可知，符合规范的硬盘主引导扇区特征应该为大小为512字节，且最后两个字节为依次为：0x55，0xAA
+
+
+
+## 练习二
+
+> 2.1 从CPU加电后执行的第一条指令开始，单步跟踪BIOS的执行。
+
+按照附录中提示配置`gdbinit`如下：
+
+````shell
+file bin/kernel
+set architecture i8086
+target remote :1234
+break kern_init
+define hook-stop
+x /i $pc
+end
+````
+
+使用`make debug`命令执行后，停止在第一条指令处，使用`where`指令查看其地址为`0xfff0`，执行`si`命令可以单步跟踪并在每一步输出当前指令。
+
+运行结果：
+
+````
+(gdb) where 
+#0  0x0000fff0 in ?? ()
+(gdb) si
+=> 0xe05b:      add    %al,(%eax)
+0x0000e05b in ?? ()
+(gdb) si
+=> 0xe062:      add    %al,(%eax)
+0x0000e062 in ?? ()
+(gdb) c
+Continuing.
+=> 0x100000 <kern_init>:        push   %ebp
+
+Breakpoint 1, kern_init () at kern/init/init.c:17
+````
+
+
+
+> 2. 2在初始化位置`0x7c00`设置实地址断点,测试断点正常。
+
+修改`gdbinit`，将断点位置修改为`0x7c00`如下：
+
+````shell
+file bin/kernel
+target remote :1234
+set architecture i8086
+break *0x7c00
+define hook-stop
+x /i $pc
+end
+````
+
+经测试可以正常运行，运行结果如下：
+
+````shell
+0x0000fff0 in ?? ()
+The target architecture is assumed to be i8086
+Breakpoint 1 at 0x7c00
+(gdb) c  
+Continuing.
+=> 0x7c00:      cli
+
+Breakpoint 1, 0x00007c00 in ?? ()
+````
+
+
+
+> 2.3 从`0x7c00`开始跟踪代码运行,将单步跟踪反汇编得到的代码与`bootasm.S`和 `bootblock.asm`进行比较。
+
+在2.2到达断点之后执行命令查看汇编代码如下：
+
+````assembly
+(gdb) x /20i $pc
+=> 0x7c00:      cli
+   0x7c01:      cld
+   0x7c02:      xor    %eax,%eax
+   0x7c04:      mov    %eax,%ds
+   0x7c06:      mov    %eax,%es
+   0x7c08:      mov    %eax,%ss
+   0x7c0a:      in     $0x64,%al
+   0x7c0c:      test   $0x2,%al
+   0x7c0e:      jne    0x7c0a
+   0x7c10:      mov    $0xd1,%al
+   0x7c12:      out    %al,$0x64
+   0x7c14:      in     $0x64,%al
+   0x7c16:      test   $0x2,%al
+   0x7c18:      jne    0x7c14
+   0x7c1a:      mov    $0xdf,%al
+   0x7c1c:      out    %al,$0x60
+   0x7c1e:      lgdtl  (%esi)
+   0x7c21:      insb   (%dx),%es:(%edi)
+   0x7c22:      jl     0x7c33
+   0x7c24:      and    %al,%al
+````
+
+经过对照，与`bootblock.asm`和`bootasm.s`一致。
+
+> 2.4 自己找一个`bootloader`或内核中的代码位置，设置断点并进行测试。
+
+找到`kernel.asm`如下代码：
+
+````assembly
+int
+vcprintf(const char *fmt, va_list ap) {
+  100229:	55                   	push   %ebp
+  10022a:	89 e5                	mov    %esp,%ebp
+  10022c:	83 ec 28             	sub    $0x28,%esp
+    int cnt = 0;
+  10022f:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
+    vprintfmt((void*)cputch, &cnt, fmt, ap);
+  100236:	8b 45 0c             	mov    0xc(%ebp),%eax
+  100239:	89 44 24 0c          	mov    %eax,0xc(%esp)
+  10023d:	8b 45 08             	mov    0x8(%ebp),%eax
+  100240:	89 44 24 08          	mov    %eax,0x8(%esp)
+  100244:	8d 45 f4             	lea    -0xc(%ebp),%eax
+  100247:	89 44 24 04          	mov    %eax,0x4(%esp)
+  10024b:	c7 04 24 09 02 10 00 	movl   $0x100209,(%esp)
+  100252:	e8 0d 2b 00 00       	call   102d64 <vprintfmt>
+    return cnt;
+  100257:	8b 45 f4             	mov    -0xc(%ebp),%eax
+}
+````
+
+在内核运行过程中，设置断点，查看位置`0x100229`的汇编代码如下：
+
+````assembly
+The target architecture is assumed to be i8086
+Breakpoint 1 at 0x7c00
+(gdb) b 0x100229
+Function "0x100229" not defined.
+Make breakpoint pending on future shared library load? (y or [n]) n
+(gdb) b *0x100229
+Breakpoint 2 at 0x100229: file kern/libs/stdio.c, line 27.
+(gdb) c
+Continuing.
+=> 0x7c00:      cli
+
+Breakpoint 1, 0x00007c00 in ?? ()
+(gdb) c
+Continuing.
+=> 0x100229 <vcprintf>: push   %ebp
+
+Breakpoint 2, vcprintf (fmt=0x10323c "%s\n\n", ap=0x7ba4 " 2\020") at kern/libs/stdio.c:27
+(gdb) x /20i $pc
+=> 0x100229 <vcprintf>: push   %ebp
+   0x10022a <vcprintf+1>:       mov    %esp,%ebp
+   0x10022c <vcprintf+3>:       sub    $0x28,%esp
+   0x10022f <vcprintf+6>:       movl   $0x0,-0xc(%ebp)
+   0x100236 <vcprintf+13>:      mov    0xc(%ebp),%eax
+   0x100239 <vcprintf+16>:      mov    %eax,0xc(%esp)
+   0x10023d <vcprintf+20>:      mov    0x8(%ebp),%eax
+   0x100240 <vcprintf+23>:      mov    %eax,0x8(%esp)
+   0x100244 <vcprintf+27>:      lea    -0xc(%ebp),%eax
+   0x100247 <vcprintf+30>:      mov    %eax,0x4(%esp)
+   0x10024b <vcprintf+34>:      movl   $0x100209,(%esp)
+   0x100252 <vcprintf+41>:      call   0x102d64 <vprintfmt>
+   0x100257 <vcprintf+46>:      mov    -0xc(%ebp),%eax
+   0x10025a <vcprintf+49>:      leave
+   0x10025b <vcprintf+50>:      ret
+   0x10025c <cprintf>:  push   %ebp
+   0x10025d <cprintf+1>:        mov    %esp,%ebp
+   0x10025f <cprintf+3>:        sub    $0x28,%esp
+   0x100262 <cprintf+6>:        lea    0xc(%ebp),%eax
+   0x100265 <cprintf+9>:        mov    %eax,-0x10(%ebp)
+````
+
+对照可发现，二者一致。
+
+## 练习三
+
+> BIOS将通过读取硬盘主引导扇区到内存，并转跳到对应内存中的位置执行`bootloader`。请分析`bootloader`是如何完成从实模式进入保护模式的。
+
++ 清理寄存器
+
+  + 屏蔽中断
+  + 清理段寄存器
+
++ 开启`A20Gate`
+
+  + 原因：早期8086CPU提供了20根地址线，可寻址1MB空间，但是`segment:offset`的表示能力超过了1MB，因此在超过时直接采用回卷的方案来解决这个问题。下一代80286的CPU提供了24位地址线，可以访问超过1MB的内容，但是为了向下兼容，使用了`A20Gate`来模拟回卷特征。但是在保护模式下要使用32位地址线，因此`A20Gate`在保护模式下都必须打开。
+
+  + 打开步骤：
+
+    + 读取8042控制器的`0x64`端口，判断`input buffer`是否为空，并等待直到其为空。
+    + 向`0x64`端口写入写命令`0xdf`，再次执行上一步操作知道`input buffer`为空
+
+    + 向`0x60`端口写入`0xdf`，将第二位置为`1`,意味着打开`A20Gate`
+
++ 加载GDT
+
+  + 直接使用引导时建立的`GDT`，所以直接使用`lgdt gdtdesc`指令加载即可
+
++ 开启保护模式
+
+  + 直接将`%cr0`寄存器的`PE`位置`1`
+
++ 长跳转到`32`位模式，更新代码段基地址
+
++ 初始化段寄存器（DS，GS，ES，FS，SS）
+
++ 初始化栈指针，建立堆栈
+
++ 进入启动主程序`bootmain`
+
+
+
+## 练习四
+
+> 通过阅读bootmain.c，了解bootloader如何加载ELF文件。通过分析源代码和通过qemu来运行并调试bootloader&OS，
+>
+> - bootloader如何读取硬盘扇区的？
+> - bootloader是如何加载ELF格式的OS？
+>
+> 提示：可阅读“硬盘访问概述”，“ELF执行文件格式概述”这两小节。
+
+#### 读取硬盘扇区
+
+在`bootmain.c`中主要由
+
+`readseg(uintptr_t va, uint32_t count, uint32_t offset)`函数以及`readsect(void *dst, uint32_t secno)`执行。
+
+`readsect`函数执行过程：
+
+````C
+ 37 static void		//等待磁盘空闲函数
+ 38 waitdisk(void) {
+ 39     while ((inb(0x1F7) & 0xC0) != 0x40);	//通过读取状态寄存器实现
+ 41 }   
+ 42     
+ 43 
+ 44 static void
+ 45 readsect(void *dst, uint32_t secno) {
+ 46    
+ 47     waitdisk();  //等待磁盘空闲
+ 48     
+ 49     outb(0x1F2, 1);                         // 读取一个扇区
+ 		
+ 		//secno指定扇区号和地址，0-27位是偏移地址，29-31位强制设为1，28位(=0)表示访问"Disk 0"
+ 50     outb(0x1F3, secno & 0xFF);
+ 51     outb(0x1F4, (secno >> 8) & 0xFF);
+ 52     outb(0x1F5, (secno >> 16) & 0xFF);
+ 53     outb(0x1F6, ((secno >> 24) & 0xF) | 0xE0);
+ 
+ 54     outb(0x1F7, 0x20);         //读磁盘命令
+		//再次等待磁盘空闲
+ 57     waitdisk();
+ 58     
+ 59     // 从0x1F0读取数据到dst
+ 60     insl(0x1F0, dst, SECTSIZE / 4);
+ 61 }  
+````
+
+`readseg`对其进行了封装，实现了读取`count`字节数据的功能
+
+````c
+68 readseg(uintptr_t va, uint32_t count, uint32_t offset) {
+ 69     uintptr_t end_va = va + count;	//数据存储的结束位置
+ 70     
+ 71     // 为什么不end_va +=  offset % SECTSIZE ???
+ 72     va -= offset % SECTSIZE;
+ 73     
+ 74     // 从字节转换为扇区号，kernel扇区号1开始的
+ 75     uint32_t secno = (offset / SECTSIZE) + 1;
+ 76     
+ 77     // 循环读取
+ 80     for (; va < end_va; va += SECTSIZE, secno ++) {
+ 81         readsect((void *)va, secno);                                                                
+ 82     }
+ 83 }   
+
+````
+
+#### 加载ELF格式的OS
+
+在`void boootmain()`函数中实现
+
+````c
+86 void
+ 87 bootmain(void) {
+ 88     // 读取硬盘中的elf头
+ 89     readseg((uintptr_t)ELFHDR, SECTSIZE * 8, 0);
+ 90     
+ 91     // 判断elf头是否合法
+ 92     if (ELFHDR->e_magic != ELF_MAGIC) {
+ 93         goto bad;
+ 94     }
+ 95     
+ 96     struct proghdr *ph, *eph; //程序表指针
+ 97     
+ 98     
+ 99     ph = (struct proghdr *)((uintptr_t)ELFHDR + ELFHDR->e_phoff);//ph表的地址
+100     eph = ph + ELFHDR->e_phnum;	//ph表的结尾
+		//将每个程序段读取到对应在内存中的虚拟地址中去
+101     for (; ph < eph; ph ++) {
+102         readseg(ph->p_va & 0xFFFFFF, ph->p_memsz, ph->p_offset);
+103     }
+104     
+105     // 根据elf头部的入口信息，从程序入口启动内核
+107     ((void (*)(void))(ELFHDR->e_entry & 0xFFFFFF))();
+108     
+109 bad:	//读取出错
+110     outw(0x8A00, 0x8A00);                                                             
+111     outw(0x8A00, 0x8E00);
+112     
+113     /* do nothing */
+114     while (1);
+115 }   
+
+````
+
+## 练习五
+
+#### 实现过程
+
+> 按照注释中一步一步实现
+
+````c
+305     uint32_t ebp = read_ebp(); 	//当前栈底位置
+306     uint32_t eip = read_eip(); 	//当前pc
+307     int i; 
+308     for(i = 0;i < STACKFRAME_DEPTH;i++){	//循环打印整个调用栈信息，最多到栈的深度
+309         cprintf("ebp:0x%08x eip:0x%08x ",ebp,eip); //当前ebp,eip
+310         cprintf("args:"); 
+311         uint32_t *args = (uint32_t *)ebp + 2; //当前ebp向上四个为可能的参数**注意在指针上+2相当于在地址上+8
+312         cprintf("%08x %08x %08x %08x",args[0],args[1],args[2],args[3]); 
+313         cprintf("\n"); 
+314         print_debuginfo(eip - 1);//打印函数名等信息 
+315         eip =  ((uint32_t *) ebp)[1]; 	//caller的eip在当前函数返回地址，即ebp上一个
+316         ebp = ((uint32_t *) ebp)[0]; 	//caller的ebp就是当前ebp指向位置内数据
+317         if(ebp == 0) break; 			//到0后会发生循环，在此处停止
+318		}
+````
+
+#### 解释最后一行各个数值的含义
+
+打印出来的最后一行为
+
+```assembly
+ebp:0x00007bf8 eip:0x00007d68 args:0xc031fcfa 0xc08ed88e 0x64e4d08e 0xfa7502a8
+```
+
+对应第一个被调用的函数`bootmain`，其`caller`的起始地址是`0x7c00`，栈底是`0x7bf8`，故`bootmain`的`ebp`是`0x7bf8`。`eip`是`bootmain`返回后要执行的下一条指令地址，`args`是`bootmain`被调用可能的参数。
+
+## 练习六
+
+> 1.中断描述符表（也可简称为保护模式下的中断向量表）中一个表项占多少字节？其中哪几位代表中断处理代码的入口？
+
+8个字节，如下所示，第1-2字节和第7-8字节为偏移，第4-5字节为段选择子，他们一起构成了中断处理代码的入口。
+
+>   offset      P DPL...        ss                    offset
+>
+>   31----16   15--------0   31------16         15-----0
+
+
+
+> 2.请编程完善kern/trap/trap.c中对中断向量表进行初始化的函数idt_init。在idt_init函数中，依次对所有中断入口进行初始化。使用mmu.h中的SETGATE宏，填充idt数组内容。每个中断的入口由tools/vectors.c生成，使用trap.c中声明的vectors数组即可。
+
+这道题一开始没有找到`KERNEL_CS`以及中断号的宏定义，对`istrap`的使用有一些疑问。遇到了很多问题，看了一下答案实现了一个版本。由于文档中提示了中断号是`0-255`,所以我在实现时直接循环的`0-255`,题目中提示仅`T_SYSCALL`的DPL需要设置为USER，但是答案中`T_SWITCH_TOK`也存在特权级转换，于是将他们的DPL都设为了`USER`。
+
+找到`idr_pd`是一个内存单元：`./obj/kernel.sym:0010e560 idt_pd`，所以最后一句调用`lidt`使用内联汇编实现如下：
+
+````c
+asm ("lidt %0\n"::"m"(idt_pd));
+````
+
+
+
+> 3.请编程完善trap.c中的中断处理函数trap，在对时钟中断进行处理的部分填写trap函数中处理时钟中断的部分，使操作系统每遇到100次时钟中断后，调用print_ticks子程序，向屏幕上打印一行文字”100 ticks”。
+
+直接按照提示设置一个全局变量即可。
\ No newline at end of file
diff -urN lab2/tools/boot.ld lab1/tools/boot.ld
--- lab2/tools/boot.ld	2019-02-26 21:54:43.932194340 +0800
+++ lab1/tools/boot.ld	1970-01-01 08:00:00.000000000 +0800
@@ -1,15 +0,0 @@
-OUTPUT_FORMAT("elf32-i386")
-OUTPUT_ARCH(i386)
-
-SECTIONS {
-    . = 0x7C00;
-
-    .startup : {
-        *bootasm.o(.text)
-    }
-
-    .text : { *(.text) }
-    .data : { *(.data .rodata) }
-    
-    /DISCARD/ : { *(.eh_*) }
-}
diff -urN lab2/tools/gdbinit lab1/tools/gdbinit
--- lab2/tools/gdbinit	2019-02-26 21:54:43.932194340 +0800
+++ lab1/tools/gdbinit	2019-03-02 23:30:02.122497622 +0800
@@ -1,3 +1,7 @@
 file bin/kernel
 target remote :1234
-break kern_init
+set architecture i8086
+break *0x7c00
+define hook-stop
+x /i $pc
+end
diff -urN lab2/tools/grade.sh lab1/tools/grade.sh
--- lab2/tools/grade.sh	2019-02-26 21:54:43.932194340 +0800
+++ lab1/tools/grade.sh	2019-02-28 18:26:57.000000000 +0800
@@ -2,25 +2,25 @@
 
 verbose=false
 if [ "x$1" = "x-v" ]; then
-    verbose=true
-    out=/dev/stdout
-    err=/dev/stderr
+	verbose=true
+	out=/dev/stdout
+	err=/dev/stderr
 else
-    out=/dev/null
-    err=/dev/null
+	out=/dev/null
+	err=/dev/null
 fi
 
 ## make & makeopts
 if gmake --version > /dev/null 2>&1; then
-    make=gmake;
+	make=gmake;
 else
-    make=make;
+	make=make;
 fi
 
 makeopts="--quiet --no-print-directory -j"
 
 make_print() {
-    echo `$make $makeopts print-$1`
+	echo `$make $makeopts print-$1`
 }
 
 ## command tools
@@ -35,7 +35,7 @@
 sym_table='obj/kernel.sym'
 
 ## gdb & gdbopts
-gdb="$(make_print GDB)"
+gdb="$(make_print GCCPREFIX)gdb"
 gdbport='1234'
 
 gdb_in="$(make_print GRADE_GDB_IN)"
@@ -46,9 +46,9 @@
 qemu_out="$(make_print GRADE_QEMU_OUT)"
 
 if $qemu -nographic -help | grep -q '^-gdb'; then
-    qemugdb="-gdb tcp::$gdbport"
+	qemugdb="-gdb tcp::$gdbport"
 else
-    qemugdb="-s -p $gdbport"
+	qemugdb="-s -p $gdbport"
 fi
 
 ## default variables
@@ -63,248 +63,248 @@
 
 ## default functions
 update_score() {
-    total=`expr $total + $part`
-    total_pos=`expr $total_pos + $part_pos`
-    part=0
-    part_pos=0
+	total=`expr $total + $part`
+	total_pos=`expr $total_pos + $part_pos`
+	part=0
+	part_pos=0
 }
 
 get_time() {
-    echo `$date +%s.%N 2> /dev/null`
+	echo `$date +%s.%N 2> /dev/null`
 }
 
 show_part() {
-    echo "Part $1 Score: $part/$part_pos"
-    echo
-    update_score
+	echo "Part $1 Score: $part/$part_pos"
+	echo
+	update_score
 }
 
 show_final() {
-    update_score
-    echo "Total Score: $total/$total_pos"
-    if [ $total -lt $total_pos ]; then
-        exit 1
-    fi
+	update_score
+	echo "Total Score: $total/$total_pos"
+	if [ $total -lt $total_pos ]; then
+		exit 1
+	fi
 }
 
 show_time() {
-    t1=$(get_time)
-    time=`echo "scale=1; ($t1-$t0)/1" | $sed 's/.N/.0/g' | $bc 2> /dev/null`
-    echo "(${time}s)"
+	t1=$(get_time)
+	time=`echo "scale=1; ($t1-$t0)/1" | $sed 's/.N/.0/g' | $bc 2> /dev/null`
+	echo "(${time}s)"
 }
 
 show_build_tag() {
-    echo "$1:" | $awk '{printf "%-24s ", $0}'
+	echo "$1:" | $awk '{printf "%-24s ", $0}'
 }
 
 show_check_tag() {
-    echo "$1:" | $awk '{printf "  -%-40s  ", $0}'
+	echo "$1:" | $awk '{printf "  -%-40s  ", $0}'
 }
 
 show_msg() {
-    echo $1
-    shift
-    if [ $# -gt 0 ]; then
-        echo -e "$@" | awk '{printf "   %s\n", $0}'
-        echo
-    fi
+	echo $1
+	shift
+	if [ $# -gt 0 ]; then
+		echo -e "$@" | awk '{printf "   %s\n", $0}'
+		echo
+	fi
 }
 
 pass() {
-    show_msg OK "$@"
-    part=`expr $part + $pts`
-    part_pos=`expr $part_pos + $pts`
+	show_msg OK "$@"
+	part=`expr $part + $pts`
+	part_pos=`expr $part_pos + $pts`
 }
 
 fail() {
-    show_msg WRONG "$@"
-    part_pos=`expr $part_pos + $pts`
+	show_msg WRONG "$@"
+	part_pos=`expr $part_pos + $pts`
 }
 
 run_qemu() {
-    # Run qemu with serial output redirected to $qemu_out. If $brkfun is non-empty,
-    # wait until $brkfun is reached or $timeout expires, then kill QEMU
-    qemuextra=
-    if [ "$brkfun" ]; then
-        qemuextra="-S $qemugdb"
-    fi
-
-    if [ -z "$timeout" ] || [ $timeout -le 0 ]; then
-        timeout=$default_timeout;
-    fi
-
-    t0=$(get_time)
-    (
-        ulimit -t $timeout
-        exec $qemu -nographic $qemuopts -serial file:$qemu_out -monitor null -no-reboot $qemuextra
-    ) > $out 2> $err &
-    pid=$!
-
-    # wait for QEMU to start
-    sleep 1
-
-    if [ -n "$brkfun" ]; then
-        # find the address of the kernel $brkfun function
-        brkaddr=`$grep " $brkfun\$" $sym_table | $sed -e's/ .*$//g'`
-        brkaddr_phys=`echo $brkaddr | sed "s/^c0/00/g"`
-        (
-            echo "target remote localhost:$gdbport"
-            echo "break *0x$brkaddr"
-            if [ "$brkaddr" != "$brkaddr_phys" ]; then
-                echo "break *0x$brkaddr_phys"
-            fi
-            echo "continue"
-        ) > $gdb_in
-
-        $gdb -batch -nx -x $gdb_in > /dev/null 2>&1
-
-        # make sure that QEMU is dead
-        # on OS X, exiting gdb doesn't always exit qemu
-        kill $pid > /dev/null 2>&1
-    fi
+	# Run qemu with serial output redirected to $qemu_out. If $brkfun is non-empty,
+	# wait until $brkfun is reached or $timeout expires, then kill QEMU
+	qemuextra=
+	if [ "$brkfun" ]; then
+		qemuextra="-S $qemugdb"
+	fi
+
+	if [ -z "$timeout" ] || [ $timeout -le 0 ]; then
+		timeout=$default_timeout;
+	fi
+
+	t0=$(get_time)
+	(
+		ulimit -t $timeout
+		exec $qemu -nographic $qemuopts -serial file:$qemu_out -monitor null -no-reboot $qemuextra
+	) > $out 2> $err &
+	pid=$!
+
+	# wait for QEMU to start
+	sleep 1
+
+	if [ -n "$brkfun" ]; then
+		# find the address of the kernel $brkfun function
+		brkaddr=`$grep " $brkfun\$" $sym_table | $sed -e's/ .*$//g'`
+		brkaddr_phys=`echo $brkaddr | sed "s/^c0/00/g"`
+		(
+			echo "target remote localhost:$gdbport"
+			echo "break *0x$brkaddr"
+			if [ "$brkaddr" != "$brkaddr_phys" ]; then
+			    echo "break *0x$brkaddr_phys"
+			fi
+			echo "continue"
+		) > $gdb_in
+
+		$gdb -batch -nx -x $gdb_in > /dev/null 2>&1
+
+		# make sure that QEMU is dead
+		# on OS X, exiting gdb doesn't always exit qemu
+		kill $pid > /dev/null 2>&1
+	fi
 }
 
 build_run() {
-    # usage: build_run <tag> <args>
-    show_build_tag "$1"
-    shift
-
-    if $verbose; then
-        echo "$make $@ ..."
-    fi
-    $make $makeopts $@ 'DEFS+=-DDEBUG_GRADE' > $out 2> $err
-
-    if [ $? -ne 0 ]; then
-        echo $make $@ failed
-        exit 1
-    fi
+	# usage: build_run <tag> <args>
+	show_build_tag "$1"
+	shift
+
+	if $verbose; then
+		echo "$make $@ ..."
+	fi
+	$make $makeopts $@ 'DEFS+=-DDEBUG_GRADE' > $out 2> $err
+
+	if [ $? -ne 0 ]; then
+		echo $make $@ failed
+		exit 1
+	fi
 
-    # now run qemu and save the output
-    run_qemu
+	# now run qemu and save the output
+	run_qemu
 
-    show_time
+	show_time
 
-    cp $qemu_out .`echo $tag | tr '[:upper:]' '[:lower:]' | sed 's/ /_/g'`.log
+	cp $qemu_out .`echo $tag | tr '[:upper:]' '[:lower:]' | sed 's/ /_/g'`.log
 }
 
 check_result() {
-    # usage: check_result <tag> <check> <check args...>
-    show_check_tag "$1"
-    shift
-
-    # give qemu some time to run (for asynchronous mode)
-    if [ ! -s $qemu_out ]; then
-        sleep 4
-    fi
-
-    if [ ! -s $qemu_out ]; then
-        fail > /dev/null
-        echo 'no $qemu_out'
-    else
-        check=$1
-        shift
-        $check "$@"
-    fi
+	# usage: check_result <tag> <check> <check args...>
+	show_check_tag "$1"
+	shift
+
+	# give qemu some time to run (for asynchronous mode)
+	if [ ! -s $qemu_out ]; then
+		sleep 4
+	fi
+
+	if [ ! -s $qemu_out ]; then
+		fail > /dev/null
+		echo 'no $qemu_out'
+	else
+		check=$1
+		shift
+		$check "$@"
+	fi
 }
 
 check_regexps() {
-    okay=yes
-    not=0
-    reg=0
-    error=
-    for i do
-        if [ "x$i" = "x!" ]; then
-            not=1
-        elif [ "x$i" = "x-" ]; then
-            reg=1
-        else
-            if [ $reg -ne 0 ]; then
-                $grep '-E' "^$i\$" $qemu_out > /dev/null
-            else
-                $grep '-F' "$i" $qemu_out > /dev/null
-            fi
-            found=$(($? == 0))
-            if [ $found -eq $not ]; then
-                if [ $found -eq 0 ]; then
-                    msg="!! error: missing '$i'"
-                else
-                    msg="!! error: got unexpected line '$i'"
-                fi
-                okay=no
-                if [ -z "$error" ]; then
-                    error="$msg"
-                else
-                    error="$error\n$msg"
-                fi
-            fi
-            not=0
-            reg=0
-        fi
-    done
-    if [ "$okay" = "yes" ]; then
-        pass
-    else
-        fail "$error"
-        if $verbose; then
-            exit 1
-        fi
-    fi
+	okay=yes
+	not=0
+	reg=0
+	error=
+	for i do
+		if [ "x$i" = "x!" ]; then
+			not=1
+		elif [ "x$i" = "x-" ]; then
+			reg=1
+		else
+			if [ $reg -ne 0 ]; then
+				$grep '-E' "^$i\$" $qemu_out > /dev/null
+			else
+				$grep '-F' "$i" $qemu_out > /dev/null
+			fi
+			found=$(($? == 0))
+			if [ $found -eq $not ]; then
+				if [ $found -eq 0 ]; then
+					msg="!! error: missing '$i'"
+				else
+					msg="!! error: got unexpected line '$i'"
+				fi
+				okay=no
+				if [ -z "$error" ]; then
+					error="$msg"
+				else
+					error="$error\n$msg"
+				fi
+			fi
+			not=0
+			reg=0
+		fi
+	done
+	if [ "$okay" = "yes" ]; then
+		pass
+	else
+		fail "$error"
+		if $verbose; then
+			exit 1
+		fi
+	fi
 }
 
 run_test() {
-    # usage: run_test [-tag <tag>] [-Ddef...] [-check <check>] checkargs ...
-    tag=
-    check=check_regexps
-    while true; do
-        select=
-        case $1 in
-            -tag)
-                select=`expr substr $1 2 ${#1}`
-                eval $select='$2'
-                ;;
-        esac
-        if [ -z "$select" ]; then
-            break
-        fi
-        shift
-        shift
-    done
-    defs=
-    while expr "x$1" : "x-D.*" > /dev/null; do
-        defs="DEFS+='$1' $defs"
-        shift
-    done
-    if [ "x$1" = "x-check" ]; then
-        check=$2
-        shift
-        shift
-    fi
+	# usage: run_test [-tag <tag>] [-Ddef...] [-check <check>] checkargs ...
+	tag=
+	check=check_regexps
+	while true; do
+		select=
+		case $1 in
+			-tag)
+				select=`expr substr $1 2 ${#1}`
+				eval $select='$2'
+				;;
+		esac
+		if [ -z "$select" ]; then
+			break
+		fi
+		shift
+		shift
+	done
+	defs=
+	while expr "x$1" : "x-D.*" > /dev/null; do
+		defs="DEFS+='$1' $defs"
+		shift
+	done
+	if [ "x$1" = "x-check" ]; then
+		check=$2
+		shift
+		shift
+	fi
 
-    $make $makeopts touch > /dev/null 2>&1
-    build_run "$tag" "$defs"
+	$make $makeopts touch > /dev/null 2>&1
+	build_run "$tag" "$defs"
 
-    check_result 'check result' "$check" "$@"
+	check_result 'check result' "$check" "$@"
 }
 
 quick_run() {
-    # usage: quick_run <tag> [-Ddef...]
-    tag="$1"
-    shift
-    defs=
-    while expr "x$1" : "x-D.*" > /dev/null; do
-        defs="DEFS+='$1' $defs"
-        shift
-    done
+	# usage: quick_run <tag> [-Ddef...]
+	tag="$1"
+	shift
+	defs=
+	while expr "x$1" : "x-D.*" > /dev/null; do
+		defs="DEFS+='$1' $defs"
+		shift
+	done
 
-    $make $makeopts touch > /dev/null 2>&1
-    build_run "$tag" "$defs"
+	$make $makeopts touch > /dev/null 2>&1
+	build_run "$tag" "$defs"
 }
 
 quick_check() {
-    # usage: quick_check <tag> checkargs ...
-    tag="$1"
-    shift
-    check_result "$tag" check_regexps "$@"
+	# usage: quick_check <tag> checkargs ...
+	tag="$1"
+	shift
+	check_result "$tag" check_regexps "$@"
 }
 
 ## kernel image
@@ -318,28 +318,36 @@
 
 ## check now!!
 
-quick_run 'Check PMM'
-
-pts=20
-quick_check 'check pmm'                                         \
-    'memory management: default_pmm_manager'                     \
-    'check_alloc_page() succeeded!'                             \
-    'check_pgdir() succeeded!'                                  \
-    'check_boot_pgdir() succeeded!'
-
-pts=20
-quick_check 'check page table'                                  \
-    'PDE(0e0) c0000000-f8000000 38000000 urw'                   \
-    '  |-- PTE(38000) c0000000-f8000000 38000000 -rw'           \
-    'PDE(001) fac00000-fb000000 00400000 -rw'                   \
-    '  |-- PTE(000e0) faf00000-fafe0000 000e0000 urw'           \
-    '  |-- PTE(00001) fafeb000-fafec000 00001000 -rw'
+quick_run 'Check Output'
 
 pts=10
-quick_check 'check ticks'                                       \
-    '++ setup timer interrupts'                                 \
-    '100 ticks'                                                 \
-    'End of Test.'
+quick_check 'check ring 0'										\
+	'0: @ring 0'												\
+	'0:  cs = 8'												\
+	'0:  ds = 10'												\
+	'0:  es = 10'												\
+	'0:  ss = 10'
+
+quick_check 'check switch to ring 3'							\
+	'+++ switch to  user  mode +++'								\
+	'1: @ring 3'												\
+	'1:  cs = 1b'												\
+	'1:  ds = 23'												\
+	'1:  es = 23'												\
+	'1:  ss = 23'
+
+quick_check 'check switch to ring 0'							\
+	'+++ switch to kernel mode +++'								\
+	'2: @ring 0'												\
+	'2:  cs = 8'												\
+	'2:  ds = 10'												\
+	'2:  es = 10'												\
+	'2:  ss = 10'
+
+quick_check 'check ticks'										\
+	'++ setup timer interrupts'									\
+	'100 ticks'													\
+	'End of Test.'
 
 ## print final-score
 show_final
diff -urN lab2/tools/kernel.ld lab1/tools/kernel.ld
--- lab2/tools/kernel.ld	2019-02-26 21:54:43.932194340 +0800
+++ lab1/tools/kernel.ld	2019-02-28 18:26:57.000000000 +0800
@@ -1,63 +1,58 @@
-/* Simple linker script for the ucore kernel.
+/* Simple linker script for the JOS kernel.
    See the GNU ld 'info' manual ("info ld") to learn the syntax. */
 
 OUTPUT_FORMAT("elf32-i386", "elf32-i386", "elf32-i386")
 OUTPUT_ARCH(i386)
-ENTRY(kern_entry)
+ENTRY(kern_init)
 
 SECTIONS {
-    /* Load the kernel at this address: "." means the current address */
-    . = 0xC0100000;
+	/* Load the kernel at this address: "." means the current address */
+	. = 0x100000;
 
-    .text : {
-        *(.text .stub .text.* .gnu.linkonce.t.*)
-    }
-
-    PROVIDE(etext = .); /* Define the 'etext' symbol to this value */
-
-    .rodata : {
-        *(.rodata .rodata.* .gnu.linkonce.r.*)
-    }
-
-    /* Include debugging information in kernel memory */
-    .stab : {
-        PROVIDE(__STAB_BEGIN__ = .);
-        *(.stab);
-        PROVIDE(__STAB_END__ = .);
-        BYTE(0)     /* Force the linker to allocate space
-                   for this section */
-    }
-
-    .stabstr : {
-        PROVIDE(__STABSTR_BEGIN__ = .);
-        *(.stabstr);
-        PROVIDE(__STABSTR_END__ = .);
-        BYTE(0)     /* Force the linker to allocate space
-                   for this section */
-    }
-
-    /* Adjust the address for the data segment to the next page */
-    . = ALIGN(0x1000);
-
-    /* The data segment */
-    .data : {
-        *(.data)
-    }
-
-    . = ALIGN(0x1000);
-    .data.pgdir : {
-        *(.data.pgdir)
-    }
-
-    PROVIDE(edata = .);
-
-    .bss : {
-        *(.bss)
-    }
-
-    PROVIDE(end = .);
-
-    /DISCARD/ : {
-        *(.eh_frame .note.GNU-stack)
-    }
+	.text : {
+		*(.text .stub .text.* .gnu.linkonce.t.*)
+	}
+
+	PROVIDE(etext = .);	/* Define the 'etext' symbol to this value */
+
+	.rodata : {
+		*(.rodata .rodata.* .gnu.linkonce.r.*)
+	}
+
+	/* Include debugging information in kernel memory */
+	.stab : {
+		PROVIDE(__STAB_BEGIN__ = .);
+		*(.stab);
+		PROVIDE(__STAB_END__ = .);
+		BYTE(0)		/* Force the linker to allocate space
+				   for this section */
+	}
+
+	.stabstr : {
+		PROVIDE(__STABSTR_BEGIN__ = .);
+		*(.stabstr);
+		PROVIDE(__STABSTR_END__ = .);
+		BYTE(0)		/* Force the linker to allocate space
+				   for this section */
+	}
+
+	/* Adjust the address for the data segment to the next page */
+	. = ALIGN(0x1000);
+
+	/* The data segment */
+	.data : {
+		*(.data)
+	}
+
+	PROVIDE(edata = .);
+
+	.bss : {
+		*(.bss)
+	}
+
+	PROVIDE(end = .);
+
+	/DISCARD/ : {
+		*(.eh_frame .note.GNU-stack)
+	}
 }
diff -urN lab2/tools/kernel_nopage.ld lab1/tools/kernel_nopage.ld
--- lab2/tools/kernel_nopage.ld	2019-02-26 21:54:43.932194340 +0800
+++ lab1/tools/kernel_nopage.ld	1970-01-01 08:00:00.000000000 +0800
@@ -1,59 +0,0 @@
-/* Simple linker script for the ucore kernel.
-   See the GNU ld 'info' manual ("info ld") to learn the syntax. */
-
-OUTPUT_FORMAT("elf32-i386", "elf32-i386", "elf32-i386")
-OUTPUT_ARCH(i386)
-ENTRY(kern_entry)
-
-SECTIONS {
-    /* Load the kernel at this address: "." means the current address */
-    /* the phy addr of ucore (before ucore enable paging mechanism*/
-    . = 0x0100000;
-
-    .text : {
-        *(.text .stub .text.* .gnu.linkonce.t.*)
-    }
-
-    PROVIDE(etext = .); /* Define the 'etext' symbol to this value */
-
-    .rodata : {
-        *(.rodata .rodata.* .gnu.linkonce.r.*)
-    }
-
-    /* Include debugging information in kernel memory */
-    .stab : {
-        PROVIDE(__STAB_BEGIN__ = .);
-        *(.stab);
-        PROVIDE(__STAB_END__ = .);
-        BYTE(0)     /* Force the linker to allocate space
-                   for this section */
-    }
-
-    .stabstr : {
-        PROVIDE(__STABSTR_BEGIN__ = .);
-        *(.stabstr);
-        PROVIDE(__STABSTR_END__ = .);
-        BYTE(0)     /* Force the linker to allocate space
-                   for this section */
-    }
-
-    /* Adjust the address for the data segment to the next page */
-    . = ALIGN(0x1000);
-
-    /* The data segment */
-    .data : {
-        *(.data)
-    }
-
-    PROVIDE(edata = .);
-
-    .bss : {
-        *(.bss)
-    }
-
-    PROVIDE(end = .);
-
-    /DISCARD/ : {
-        *(.eh_frame .note.GNU-stack)
-    }
-}
