# lab4 report

2016011395 石景宜

## 练习1 分配并初始化一个进程控制块

##### 实现过程

参考实验手册**创建第0个内核线程`idleproc`**一节可知，这道题只需要将整个`proc_struct`结构初始化为0然后对`pid`，`state`和`cr3`赋初值即可，实现与手册中一致。

##### `trapframe`和`context`

这两个结构体都是用来保存进程的上下文信息，即进程切换时需要保存的寄存器信息等。

`trapframe`是运行在用户态的进程切换到内核态时保存的中断帧，只会保存进程在用户态的状态，在发生用户态/内核态切换时被保存或者加载（中断、异常、系统调用除外，它们的上下文是由硬件直接保存在内核栈中）

而`context`是进程在内核态的上下文，在切换进程时使用，只会保存进程在内核态的信息，在发生进程切换时被加载/保存。

##### 与参考答案不同

参考答案对每个成员变量逐个初始化，但最终整体效果和我的实现相同。

## 练习2  为新创建的内核线程分配资源

##### 实现过程

直接按照注释描述的步骤，实现即可，参考实验手册**创建第1个内核线程`initproc`**一节可知，需要对前三个步骤进行错误处理。

##### 每个fork的线程id是否唯一

在`ucore`中，分配`pid`实现在函数`get_pid`中，该函数在`[1,MAXPID)`中为进程分配未被使用的`pid`，该函数中有`next_safe`和`last_pid`两个重要变量，`next_safe`安全`pid`上界，初始为`MAXPID`，`last_pid`是上一次分配的`pid`值，`(last_pid,next_safe)`区间是安全区间，该函数通过循环遍历`proc`链表来查找`last_pid`后最近的安全的区间。因此，`ucore`中分配的线程id是唯一的。

##### 和参考答案不同

和参考答案相比，我没有设置线程的父线程遍历`proc->parent`，没有增加内核集数目`nr_process`,也没有获得线程`pid`，也没有临界区关中断。已按照参考答案对此进行修复。

## 练习3 阅读代码，理解proc_run 函数和它调用的函数如何完成进程切换的

##### 分析`proc_run`函数

+ 判断要转换的进程是否是当前进程，不是则继续
+ 关闭中断
+ 将TSS中的esp0修改为目标进程的esp
+ 将cr3寄存器的值修改为目标进程的页目录基址
+ 调用`switch_to`函数保存当前进程的`context`，装载下一进程的`context`，完成切换。

##### 在本实验的执行过程中，创建且运行了几个内核线程？

2个。

+ `idleproc`：每一次被调度时都主动调用`schedule`函数让出时间片给其他进程。
+ `initproc`:打印一些进程信息。

##### `local_intr_save(intr_flag);....local_intr_restore(intr_flag);`在这里有何作用?请说明理由

作用：关闭中断。

前一句根据`FL_IF`标志位判断当前是否已经处于关中断状态，将当前状态放在`intr_flag`中，若没有关中断，则关中断。

后一句根据`intr_flag`决定是否开中断，保证执行后恢复到前一句执行前的状态。

这两条语句能够保证在单处理器系统中，在进程切换的临界区不被中断打断。保证进程切换过程的安全。

## 知识点总结

本实验中包含的课程知识点

+ 进程控制块PCB
+ 内核线程的创建和切换
+ fork函数
+ 进程状态模型

本实验中没有涉及到的课程重要知识点

+ 挂起
+ 等待状态
+ 用户进程的创建和切换
+ exit()/exec()，COW